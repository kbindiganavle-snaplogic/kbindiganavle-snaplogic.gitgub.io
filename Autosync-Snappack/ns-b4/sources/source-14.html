


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > EltLoad</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/highlight-idea.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.snaplogic.snaps.elt</a>
</div>

<h1>Coverage Summary for Class: EltLoad (com.snaplogic.snaps.elt)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">EltLoad</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/272)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3741)
  </span>
</td>
</tr>
  <tr>
    <td class="name">EltLoad$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/273)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3742)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<div class="sourceCode" id="sourceCode"><i class="no-highlight">1</i>&nbsp;/*
<i class="no-highlight">2</i>&nbsp; * SnapLogic - Data Integration
<i class="no-highlight">3</i>&nbsp; *
<i class="no-highlight">4</i>&nbsp; * Copyright (C) 2020-2022, SnapLogic, Inc.  All rights reserved.
<i class="no-highlight">5</i>&nbsp; *
<i class="no-highlight">6</i>&nbsp; * This program is licensed under the terms of
<i class="no-highlight">7</i>&nbsp; * the SnapLogic Commercial Subscription agreement.
<i class="no-highlight">8</i>&nbsp; *
<i class="no-highlight">9</i>&nbsp; * &quot;SnapLogic&quot; is a trademark of SnapLogic, Inc.
<i class="no-highlight">10</i>&nbsp; */
<i class="no-highlight">11</i>&nbsp;package com.snaplogic.snaps.elt;
<i class="no-highlight">12</i>&nbsp;
<i class="no-highlight">13</i>&nbsp;import com.amazonaws.auth.AWSCredentialsProvider;
<i class="no-highlight">14</i>&nbsp;import com.amazonaws.auth.AWSStaticCredentialsProvider;
<i class="no-highlight">15</i>&nbsp;import com.amazonaws.auth.BasicAWSCredentials;
<i class="no-highlight">16</i>&nbsp;import com.amazonaws.auth.BasicSessionCredentials;
<i class="no-highlight">17</i>&nbsp;import com.amazonaws.regions.Regions;
<i class="no-highlight">18</i>&nbsp;import com.amazonaws.services.s3.AmazonS3;
<i class="no-highlight">19</i>&nbsp;import com.amazonaws.services.s3.AmazonS3Client;
<i class="no-highlight">20</i>&nbsp;import com.amazonaws.services.s3.AmazonS3ClientBuilder;
<i class="no-highlight">21</i>&nbsp;import com.amazonaws.services.s3.model.ListObjectsV2Request;
<i class="no-highlight">22</i>&nbsp;import com.amazonaws.services.s3.model.ListObjectsV2Result;
<i class="no-highlight">23</i>&nbsp;import com.amazonaws.services.s3.model.S3ObjectSummary;
<i class="no-highlight">24</i>&nbsp;import com.azure.storage.blob.BlobContainerClient;
<i class="no-highlight">25</i>&nbsp;import com.azure.storage.blob.BlobServiceClient;
<i class="no-highlight">26</i>&nbsp;import com.azure.storage.blob.models.BlobItem;
<i class="no-highlight">27</i>&nbsp;import com.azure.storage.blob.models.ListBlobsOptions;
<i class="no-highlight">28</i>&nbsp;import com.azure.storage.file.datalake.DataLakeFileSystemClient;
<i class="no-highlight">29</i>&nbsp;import com.azure.storage.file.datalake.DataLakeServiceClient;
<i class="no-highlight">30</i>&nbsp;import com.azure.storage.file.datalake.models.ListPathsOptions;
<i class="no-highlight">31</i>&nbsp;import com.azure.storage.file.datalake.models.PathItem;
<i class="no-highlight">32</i>&nbsp;
<i class="no-highlight">33</i>&nbsp;import com.google.api.gax.core.FixedCredentialsProvider;
<i class="no-highlight">34</i>&nbsp;import com.google.api.gax.rpc.ApiException;
<i class="no-highlight">35</i>&nbsp;import com.google.api.gax.rpc.DeadlineExceededException;
<i class="no-highlight">36</i>&nbsp;import com.google.api.gax.rpc.UnavailableException;
<i class="no-highlight">37</i>&nbsp;import com.google.auth.Credentials;
<i class="no-highlight">38</i>&nbsp;import com.google.cloud.bigquery.BigQuery;
<i class="no-highlight">39</i>&nbsp;import com.google.cloud.bigquery.BigQueryError;
<i class="no-highlight">40</i>&nbsp;import com.google.cloud.bigquery.BigQueryOptions;
<i class="no-highlight">41</i>&nbsp;import com.google.cloud.bigquery.CsvOptions;
<i class="no-highlight">42</i>&nbsp;import com.google.cloud.bigquery.FormatOptions;
<i class="no-highlight">43</i>&nbsp;import com.google.cloud.bigquery.Job;
<i class="no-highlight">44</i>&nbsp;import com.google.cloud.bigquery.JobInfo;
<i class="no-highlight">45</i>&nbsp;import com.google.cloud.bigquery.LoadJobConfiguration;
<i class="no-highlight">46</i>&nbsp;import com.google.cloud.bigquery.TableId;
<i class="no-highlight">47</i>&nbsp;import com.google.cloud.bigquery.datatransfer.v1.CreateTransferConfigRequest;
<i class="no-highlight">48</i>&nbsp;import com.google.cloud.bigquery.datatransfer.v1.DataTransferServiceClient;
<i class="no-highlight">49</i>&nbsp;import com.google.cloud.bigquery.datatransfer.v1.DataTransferServiceSettings;
<i class="no-highlight">50</i>&nbsp;import com.google.cloud.bigquery.datatransfer.v1.ProjectName;
<i class="no-highlight">51</i>&nbsp;import com.google.cloud.bigquery.datatransfer.v1.ScheduleOptions;
<i class="no-highlight">52</i>&nbsp;import com.google.cloud.bigquery.datatransfer.v1.StartManualTransferRunsRequest;
<i class="no-highlight">53</i>&nbsp;import com.google.cloud.bigquery.datatransfer.v1.StartManualTransferRunsResponse;
<i class="no-highlight">54</i>&nbsp;import com.google.cloud.bigquery.datatransfer.v1.TransferConfig;
<i class="no-highlight">55</i>&nbsp;import com.google.cloud.bigquery.datatransfer.v1.TransferState;
<i class="no-highlight">56</i>&nbsp;import com.google.common.annotations.VisibleForTesting;
<i class="no-highlight">57</i>&nbsp;import com.google.common.base.Throwables;
<i class="no-highlight">58</i>&nbsp;import com.google.common.collect.ImmutableMap;
<i class="no-highlight">59</i>&nbsp;import com.google.common.collect.ImmutableSet;
<i class="no-highlight">60</i>&nbsp;import com.google.common.collect.Lists;
<i class="no-highlight">61</i>&nbsp;import com.google.common.collect.Maps;
<i class="no-highlight">62</i>&nbsp;import com.google.inject.Inject;
<i class="no-highlight">63</i>&nbsp;import com.google.protobuf.Struct;
<i class="no-highlight">64</i>&nbsp;import com.google.protobuf.Timestamp;
<i class="no-highlight">65</i>&nbsp;import com.google.protobuf.Value;
<i class="no-highlight">66</i>&nbsp;import com.snaplogic.account.api.capabilities.Accounts;
<i class="no-highlight">67</i>&nbsp;import com.snaplogic.api.ConfigurationException;
<i class="no-highlight">68</i>&nbsp;import com.snaplogic.api.ExecutionException;
<i class="no-highlight">69</i>&nbsp;import com.snaplogic.api.Lint;
<i class="no-highlight">70</i>&nbsp;import com.snaplogic.api.Notification;
<i class="no-highlight">71</i>&nbsp;import com.snaplogic.api.SnapException;
<i class="no-highlight">72</i>&nbsp;import com.snaplogic.api.StatusMessage;
<i class="no-highlight">73</i>&nbsp;import com.snaplogic.api.SuggestExecutionProvider;
<i class="no-highlight">74</i>&nbsp;import com.snaplogic.common.SnapStatistic;
<i class="no-highlight">75</i>&nbsp;import com.snaplogic.common.SnapType;
<i class="no-highlight">76</i>&nbsp;import com.snaplogic.common.properties.SnapProperty;
<i class="no-highlight">77</i>&nbsp;import com.snaplogic.common.properties.builders.PropertyBuilder;
<i class="no-highlight">78</i>&nbsp;import com.snaplogic.common.properties.builders.SuggestionBuilder;
<i class="no-highlight">79</i>&nbsp;import com.snaplogic.snap.api.Document;
<i class="no-highlight">80</i>&nbsp;import com.snaplogic.snap.api.PropertyValues;
<i class="no-highlight">81</i>&nbsp;import com.snaplogic.snap.api.SnapCategory;
<i class="no-highlight">82</i>&nbsp;import com.snaplogic.snap.api.SnapDataException;
<i class="no-highlight">83</i>&nbsp;import com.snaplogic.snap.api.StatisticProvider;
<i class="no-highlight">84</i>&nbsp;import com.snaplogic.snap.api.StatusReporter;
<i class="no-highlight">85</i>&nbsp;import com.snaplogic.snap.api.capabilities.Category;
<i class="no-highlight">86</i>&nbsp;import com.snaplogic.snap.api.capabilities.General;
<i class="no-highlight">87</i>&nbsp;import com.snaplogic.snap.api.capabilities.Inputs;
<i class="no-highlight">88</i>&nbsp;import com.snaplogic.snap.api.capabilities.Outputs;
<i class="no-highlight">89</i>&nbsp;import com.snaplogic.snap.api.capabilities.Version;
<i class="no-highlight">90</i>&nbsp;import com.snaplogic.snap.api.capabilities.ViewType;
<i class="no-highlight">91</i>&nbsp;import com.snaplogic.snap.api.fs.s3.S3EncryptionType;
<i class="no-highlight">92</i>&nbsp;import com.snaplogic.snap.api.sql.DatabaseAccount;
<i class="no-highlight">93</i>&nbsp;import com.snaplogic.snap.api.sql.DatabaseCursor;
<i class="no-highlight">94</i>&nbsp;import com.snaplogic.snap.api.sql.JdbcOperations;
<i class="no-highlight">95</i>&nbsp;import com.snaplogic.snaps.elt.schema_detector.DefaultRedshiftFileSchemaDetector;
<i class="no-highlight">96</i>&nbsp;import com.snaplogic.snaps.elt.schema_detector.DefaultSnowflakeFileSchemaDetector;
<i class="no-highlight">97</i>&nbsp;import com.snaplogic.snaps.elt.schema_detector.FileSchemaDetector;
<i class="no-highlight">98</i>&nbsp;import com.snaplogic.snaps.elt.schema_detector.SchemaDetectionResult;
<i class="no-highlight">99</i>&nbsp;import com.snaplogic.snaps.elt.schema_detector.storage.AzureStorageApi;
<i class="no-highlight">100</i>&nbsp;import com.snaplogic.snaps.elt.suggest.ColumnNamesSuggestProvider;
<i class="no-highlight">101</i>&nbsp;import com.snaplogic.snaps.elt.utils.AzureSynapseUtils;
<i class="no-highlight">102</i>&nbsp;import com.snaplogic.snaps.elt.utils.EltUtils;
<i class="no-highlight">103</i>&nbsp;import com.snaplogic.snaps.elt.utils.QueryStatisticHolder.QueryStatisticHolderBuilder;
<i class="no-highlight">104</i>&nbsp;import com.snaplogic.snaps.elt.utils.StatisticHolder;
<i class="no-highlight">105</i>&nbsp;import com.snaplogic.snaps.elt.utils.SupportedDataTypesUtils;
<i class="no-highlight">106</i>&nbsp;import com.snaplogic.util.JsonPathBuilder;
<i class="no-highlight">107</i>&nbsp;
<i class="no-highlight">108</i>&nbsp;import org.apache.commons.collections.CollectionUtils;
<i class="no-highlight">109</i>&nbsp;import org.apache.commons.collections.MapUtils;
<i class="no-highlight">110</i>&nbsp;import org.apache.commons.lang3.StringUtils;
<i class="no-highlight">111</i>&nbsp;
<i class="no-highlight">112</i>&nbsp;import org.slf4j.Logger;
<i class="no-highlight">113</i>&nbsp;import org.slf4j.LoggerFactory;
<i class="no-highlight">114</i>&nbsp;
<i class="no-highlight">115</i>&nbsp;import java.io.IOException;
<i class="no-highlight">116</i>&nbsp;import java.math.BigInteger;
<i class="no-highlight">117</i>&nbsp;
<i class="no-highlight">118</i>&nbsp;import java.sql.PreparedStatement;
<i class="no-highlight">119</i>&nbsp;import java.sql.ResultSet;
<i class="no-highlight">120</i>&nbsp;import java.sql.ResultSetMetaData;
<i class="no-highlight">121</i>&nbsp;import java.sql.SQLException;
<i class="no-highlight">122</i>&nbsp;import java.sql.Statement;
<i class="no-highlight">123</i>&nbsp;
<i class="no-highlight">124</i>&nbsp;import java.time.Instant;
<i class="no-highlight">125</i>&nbsp;
<i class="no-highlight">126</i>&nbsp;import java.util.ArrayList;
<i class="no-highlight">127</i>&nbsp;import java.util.Collection;
<i class="no-highlight">128</i>&nbsp;import java.util.Collections;
<i class="no-highlight">129</i>&nbsp;import java.util.HashMap;
<i class="no-highlight">130</i>&nbsp;import java.util.HashSet;
<i class="no-highlight">131</i>&nbsp;import java.util.Iterator;
<i class="no-highlight">132</i>&nbsp;import java.util.LinkedHashMap;
<i class="no-highlight">133</i>&nbsp;import java.util.LinkedHashSet;
<i class="no-highlight">134</i>&nbsp;import java.util.List;
<i class="no-highlight">135</i>&nbsp;import java.util.ListIterator;
<i class="no-highlight">136</i>&nbsp;import java.util.Map;
<i class="no-highlight">137</i>&nbsp;import java.util.Optional;
<i class="no-highlight">138</i>&nbsp;import java.util.Random;
<i class="no-highlight">139</i>&nbsp;import java.util.Set;
<i class="no-highlight">140</i>&nbsp;import java.util.concurrent.TimeUnit;
<i class="no-highlight">141</i>&nbsp;import java.util.regex.Matcher;
<i class="no-highlight">142</i>&nbsp;import java.util.regex.Pattern;
<i class="no-highlight">143</i>&nbsp;import java.util.stream.Collectors;
<i class="no-highlight">144</i>&nbsp;import java.util.stream.Stream;
<i class="no-highlight">145</i>&nbsp;
<i class="no-highlight">146</i>&nbsp;import static com.snaplogic.snaps.elt.EltConstants.*;
<i class="no-highlight">147</i>&nbsp;import static com.snaplogic.snaps.elt.EltConstants.SnowflakeCopyOption.MATCH_BY_COLUMN_NAME;
<i class="no-highlight">148</i>&nbsp;import static com.snaplogic.snaps.elt.Messages.*;
<i class="no-highlight">149</i>&nbsp;import static com.snaplogic.snaps.elt.Messages.RES_TARGET_TABLE_SCHEMA_INFERENCE_FAILED;
<i class="no-highlight">150</i>&nbsp;import static com.snaplogic.snaps.elt.utils.AzureSynapseUtils.buildAzureSynapseCreateTableSql;
<i class="no-highlight">151</i>&nbsp;import static com.snaplogic.snaps.elt.utils.AzureSynapseUtils.buildAzureSynapseRenameTableSql;
<i class="no-highlight">152</i>&nbsp;import static com.snaplogic.snaps.elt.utils.AzureSynapseUtils.getAzureAADClients;
<i class="no-highlight">153</i>&nbsp;import static com.snaplogic.snaps.elt.utils.AzureSynapseUtils.getAzureSasTokenClients;
<i class="no-highlight">154</i>&nbsp;import static com.snaplogic.snaps.elt.utils.AzureSynapseUtils.getAzureSharedKeyClients;
<i class="no-highlight">155</i>&nbsp;import static com.snaplogic.snaps.elt.utils.AzureSynapseUtils
<i class="no-highlight">156</i>&nbsp;        .validateAzureSynapseAccountSettingsForLoad;
<i class="no-highlight">157</i>&nbsp;import static com.snaplogic.snaps.elt.utils.BigQueryUtils.BigQueryLoadOptionsConfig;
<i class="no-highlight">158</i>&nbsp;import static com.snaplogic.snaps.elt.utils.BigQueryUtils.buildBigQueryAlterTableAddDropColumnsSqls;
<i class="no-highlight">159</i>&nbsp;import static com.snaplogic.snaps.elt.utils.BigQueryUtils.buildBigQueryCreateOrReplaceTableSql;
<i class="no-highlight">160</i>&nbsp;import static com.snaplogic.snaps.elt.utils.BigQueryUtils.buildBigQueryLoadOptionsConfig;
<i class="no-highlight">161</i>&nbsp;import static com.snaplogic.snaps.elt.utils.BigQueryUtils.buildBigQueryRenameTableSql;
<i class="no-highlight">162</i>&nbsp;import static com.snaplogic.snaps.elt.utils.BigQueryUtils
<i class="no-highlight">163</i>&nbsp;        .buildBigQueryRestoreTargetTableToStartTimestampSql;
<i class="no-highlight">164</i>&nbsp;import static com.snaplogic.snaps.elt.utils.BigQueryUtils.getCredentialsFromBQAcct;
<i class="no-highlight">165</i>&nbsp;import static com.snaplogic.snaps.elt.utils.DLPUtils.buildDLPAlterTableSqls;
<i class="no-highlight">166</i>&nbsp;import static com.snaplogic.snaps.elt.utils.DLPUtils.buildDLPCreateOrReplaceTableSql;
<i class="no-highlight">167</i>&nbsp;import static com.snaplogic.snaps.elt.utils.DLPUtils.buildDLPRenameTableSql;
<i class="no-highlight">168</i>&nbsp;import static com.snaplogic.snaps.elt.utils.EltRedshiftUtils.buildRedshiftAlterTableSql;
<i class="no-highlight">169</i>&nbsp;import static com.snaplogic.snaps.elt.utils.EltUtils.*;
<i class="no-highlight">170</i>&nbsp;
<i class="no-highlight">171</i>&nbsp;/**
<i class="no-highlight">172</i>&nbsp; * COPY the data in bulk from one of the cloud storage provider stated in the account properties to
<i class="no-highlight">173</i>&nbsp; * respective DB
<i class="no-highlight">174</i>&nbsp; */
<i class="no-highlight">175</i>&nbsp;@Inputs(min = 0, max = 1, accepts = {ViewType.DOCUMENT})
<i class="no-highlight">176</i>&nbsp;@Outputs(min = 0, max = 1, offers = {ViewType.DOCUMENT})
<i class="no-highlight">177</i>&nbsp;@Version(snap = 1)
<i class="no-highlight">178</i>&nbsp;@Category(snap = SnapCategory.WRITE)
<b class="nc"><i class="no-highlight">179</i>&nbsp;@General(title = ELT_LOAD_TITLE, purpose = ELT_LOAD_PURPOSE, docLink = ELT_LOAD_DOC_LINK)</b>
<b class="nc"><i class="no-highlight">180</i>&nbsp;@Accounts(provides = {EltDatabaseAccount.class})</b>
<i class="no-highlight">181</i>&nbsp;public class EltLoad extends BaseElt implements SuggestExecutionProvider, StatisticProvider {
<i class="no-highlight">182</i>&nbsp;    private static final Logger LOGGER = LoggerFactory.getLogger(EltLoad.class);
<i class="no-highlight">183</i>&nbsp;    private static final String ALTER_COLUMN_PROP = &quot;alterColumnModifier&quot;;
<i class="no-highlight">184</i>&nbsp;    private static final String DATA_TYPE_PROP = &quot;dataType&quot;;
<i class="no-highlight">185</i>&nbsp;    private static final String ROWS_TO_RETURN_PROP = &quot;rowsToReturn&quot;;
<i class="no-highlight">186</i>&nbsp;    private static final String KMS_KEY_PROP = &quot;kmsKey&quot;;
<i class="no-highlight">187</i>&nbsp;    private static final String ENCRYPT_TYPE_PROP = &quot;encryptType&quot;;
<i class="no-highlight">188</i>&nbsp;    private static final String BQ_REDSHIFT_SCHEMA_NAME_PROP = &quot;bqRedshiftSchemaName&quot;;
<i class="no-highlight">189</i>&nbsp;    private static final String BQ_REDSHIFT_TABLE_NAME_PROP = &quot;bqRedshiftTableName&quot;;
<i class="no-highlight">190</i>&nbsp;    private static final String CLOUD_STORAGE_PATH_PROP = &quot;cloudStoragePath&quot;;
<i class="no-highlight">191</i>&nbsp;    private static final String COPY_OPTION_PROP = &quot;copyOption&quot;;
<i class="no-highlight">192</i>&nbsp;    private static final String COPY_OPTIONS_LIST_PROP = &quot;copyOptionList&quot;;
<i class="no-highlight">193</i>&nbsp;    private static final String FILE_FORMAT_OPTION_PROP = &quot;fileFormatOption&quot;;
<i class="no-highlight">194</i>&nbsp;    private static final String VALIDATION_MODE_PROP = &quot;validationMode&quot;;
<i class="no-highlight">195</i>&nbsp;    private static final String TABLE_COLUMN_PROP = &quot;columns&quot;;
<i class="no-highlight">196</i>&nbsp;    private static final String TABLE_COLUMN_LIST_PROP = &quot;columnList&quot;;
<i class="no-highlight">197</i>&nbsp;    private static final String TARGET_TO_SOURCE_COLUMNS_MAP_PROP =
<i class="no-highlight">198</i>&nbsp;            &quot;targetToSourceMappingTableProp&quot;;
<i class="no-highlight">199</i>&nbsp;    private static final String SOURCE_FILE_COLUMN_NAME_PROP =
<i class="no-highlight">200</i>&nbsp;            &quot;sourceTableColumnNameProp&quot;;
<i class="no-highlight">201</i>&nbsp;    private static final String SOURCE_FILE_COLUMN_POSITION_PROP =
<i class="no-highlight">202</i>&nbsp;            &quot;sourceTableColumnPositionProp&quot;;
<i class="no-highlight">203</i>&nbsp;    private static final String TARGET_TABLE_COLUMN_NAME_PROP =
<i class="no-highlight">204</i>&nbsp;            &quot;targetTableColumnNameProp&quot;;
<b class="nc"><i class="no-highlight">205</i>&nbsp;    private static final String ENABLE_SOURCE_COLUMN_POSITION_PROP =</b>
<i class="no-highlight">206</i>&nbsp;            &quot;enableSourceColumnPositionProp&quot;;
<b class="nc"><i class="no-highlight">207</i>&nbsp;    private static final String DATA_TYPE_ENABLE_COND = String.format(DATA_TYPE_COND,</b>
<i class="no-highlight">208</i>&nbsp;            LOAD_ACTION_PROP, DROP_CREATE_TABLE, LOAD_ACTION_PROP, ALTER_TABLE);
<b class="nc"><i class="no-highlight">209</i>&nbsp;    private static final String ALTER_COLUMN_ENABLE_COND = String.format(ENABLE_COND,</b>
<i class="no-highlight">210</i>&nbsp;            LOAD_ACTION_PROP, ALTER_TABLE);
<b class="nc"><i class="no-highlight">211</i>&nbsp;    private static final String NOT_ALTER_COLUMN_ENABLE_COND = String.format(DISABLE_COND,</b>
<i class="no-highlight">212</i>&nbsp;            LOAD_ACTION_PROP, ALTER_TABLE);
<i class="no-highlight">213</i>&nbsp;    private static final String COLUMN_LIST_ENABLE_COND = String.format(ENABLE_COLUMN_LIST_COND,
<b class="nc"><i class="no-highlight">214</i>&nbsp;            LOAD_ACTION_PROP, ALTER_TABLE,</b>
<b class="nc"><i class="no-highlight">215</i>&nbsp;            LOAD_ACTION_PROP, DROP_CREATE_TABLE);</b>
<i class="no-highlight">216</i>&nbsp;    private static final String TABLE_OPTION_LIST_ENABLE_COND =
<b class="nc"><i class="no-highlight">217</i>&nbsp;            String.format(ENABLE_TABLE_OPTION_LIST_COND,</b>
<b class="nc"><i class="no-highlight">218</i>&nbsp;            LOAD_ACTION_PROP, DROP_CREATE_TABLE);</b>
<b class="nc"><i class="no-highlight">219</i>&nbsp;    private static final String KMS_KEY_ENABLE_COND = String.format(ENABLE_COND,</b>
<i class="no-highlight">220</i>&nbsp;            ENCRYPT_TYPE_PROP, S3EncryptionType.SSE_KMS.toString());
<b class="nc"><i class="no-highlight">221</i>&nbsp;    private static final String ROWS_TO_RETURN_ENABLE_COND = String.format(ENABLE_COND,</b>
<b class="nc"><i class="no-highlight">222</i>&nbsp;            VALIDATION_MODE_PROP, RETURN_N_ROWS);</b>
<b class="nc"><i class="no-highlight">223</i>&nbsp;    private static final String FILE_LIST_PATH = new JsonPathBuilder(FILE_LIST_PROP)</b>
<b class="nc"><i class="no-highlight">224</i>&nbsp;            .appendAllListElements().build();</b>
<b class="nc"><i class="no-highlight">225</i>&nbsp;    private static final String COLUMN_LIST_PATH = new JsonPathBuilder(TABLE_COLUMN_LIST_PROP)</b>
<b class="nc"><i class="no-highlight">226</i>&nbsp;            .appendAllListElements().build();</b>
<b class="nc"><i class="no-highlight">227</i>&nbsp;    private static final String FILE_FORMAT_OPTION_LIST_PATH = new JsonPathBuilder</b>
<b class="nc"><i class="no-highlight">228</i>&nbsp;            (FILE_FORMAT_OPTIONS_LIST_PROP).appendAllListElements().build();</b>
<b class="nc"><i class="no-highlight">229</i>&nbsp;    private static final String TABLE_OPTION_LIST_PATH = new JsonPathBuilder</b>
<b class="nc"><i class="no-highlight">230</i>&nbsp;            (TABLE_OPTIONS_LIST_PROP).appendAllListElements().build();</b>
<b class="nc"><i class="no-highlight">231</i>&nbsp;    private static final String COPY_OPTION_LIST_PATH = new JsonPathBuilder</b>
<i class="no-highlight">232</i>&nbsp;            (COPY_OPTIONS_LIST_PROP).appendAllListElements().build();
<i class="no-highlight">233</i>&nbsp;    public static final ImmutableSet&lt;String&gt; DATA_TYPES_TO_CAST_DLP = ImmutableSet.of(
<i class="no-highlight">234</i>&nbsp;            BINARY_STR, DATE_STR);
<b class="nc"><i class="no-highlight">235</i>&nbsp;</b>
<i class="no-highlight">236</i>&nbsp;    @Notification(message = &quot;Status: %s Rows Written: %d Rows Updated: %d Rows Deleted: %s&quot;)
<i class="no-highlight">237</i>&nbsp;    private static final StatusMessage SNAP_STATS = new StatusMessage();
<i class="no-highlight">238</i>&nbsp;
<b class="nc"><i class="no-highlight">239</i>&nbsp;    @Notification(message = &quot;Skip Copy Option&quot;, reason = SKIP_COPY_OPTION_MSG)</b>
<b class="nc"><i class="no-highlight">240</i>&nbsp;    private static final Lint SKIPPING_COPY_OPTION = new Lint();</b>
<b class="nc"><i class="no-highlight">241</i>&nbsp;</b>
<i class="no-highlight">242</i>&nbsp;    @Notification(message = &quot;Skip Copy Option&quot;, reason = SKIP_COPY_OPTION_MSG2)
<b class="nc"><i class="no-highlight">243</i>&nbsp;    private static final Lint SKIPPING_COPY_OPTION2 = new Lint();</b>
<b class="nc"><i class="no-highlight">244</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">245</i>&nbsp;    @Inject</b>
<b class="nc"><i class="no-highlight">246</i>&nbsp;    private StatusReporter statusReporter;</b>
<b class="nc"><i class="no-highlight">247</i>&nbsp;    private final List&lt;String&gt; filePaths = new ArrayList&lt;&gt;();</b>
<b class="nc"><i class="no-highlight">248</i>&nbsp;    private final List&lt;String&gt; targetColumns = new ArrayList&lt;&gt;();</b>
<i class="no-highlight">249</i>&nbsp;    private final List&lt;String&gt; targetColumnsWithBacktick = new ArrayList&lt;&gt;();
<i class="no-highlight">250</i>&nbsp;    private boolean isThereBacktickWrappedElementAtTargetColumns;
<b class="nc"><i class="no-highlight">251</i>&nbsp;    private final List&lt;String&gt; targetDataTypes = new ArrayList&lt;&gt;();</b>
<b class="nc"><i class="no-highlight">252</i>&nbsp;    private final List&lt;String&gt; fileFormatOptions = new ArrayList&lt;&gt;();</b>
<b class="nc"><i class="no-highlight">253</i>&nbsp;    private final List&lt;String&gt; tableOptions = new ArrayList&lt;&gt;();</b>
<b class="nc"><i class="no-highlight">254</i>&nbsp;    private final List&lt;String&gt; copyOptions = new ArrayList&lt;&gt;();</b>
<i class="no-highlight">255</i>&nbsp;    private final List&lt;String&gt; alterColumnModifiers = new ArrayList&lt;&gt;();
<i class="no-highlight">256</i>&nbsp;    @VisibleForTesting
<i class="no-highlight">257</i>&nbsp;    protected List&lt;String&gt; files = new ArrayList&lt;&gt;();
<i class="no-highlight">258</i>&nbsp;    private static final String TARGET_TO_SOURCE_COLUMNS_MAP_PATH =
<i class="no-highlight">259</i>&nbsp;            new JsonPathBuilder(TARGET_TO_SOURCE_COLUMNS_MAP_PROP).appendAllListElements()
<i class="no-highlight">260</i>&nbsp;                    .build();
<i class="no-highlight">261</i>&nbsp;    private List&lt;String&gt; gcsSourceURIs = new ArrayList&lt;&gt;();
<i class="no-highlight">262</i>&nbsp;    private String s3StagingFolderURI = EMPTY_STRING;
<i class="no-highlight">263</i>&nbsp;    private BigQueryLoadOptionsConfig bigQueryLoadOptionsConfig;
<i class="no-highlight">264</i>&nbsp;    private String fileFormatType;
<i class="no-highlight">265</i>&nbsp;    private String filePattern;
<i class="no-highlight">266</i>&nbsp;    private String cloudStorageLocation;
<i class="no-highlight">267</i>&nbsp;    private String encryptionType;
<i class="no-highlight">268</i>&nbsp;    private String kmsKey;
<i class="no-highlight">269</i>&nbsp;    private String validationMode;
<i class="no-highlight">270</i>&nbsp;    private String rowsToReturn;
<i class="no-highlight">271</i>&nbsp;    private String awsSecretKey;
<i class="no-highlight">272</i>&nbsp;    private String awsAccessKey;
<i class="no-highlight">273</i>&nbsp;    private String storageIntegration;
<i class="no-highlight">274</i>&nbsp;    private String iamRole;
<i class="no-highlight">275</i>&nbsp;    private String s3BucketRegion;
<i class="no-highlight">276</i>&nbsp;    private String s3Bucket;
<i class="no-highlight">277</i>&nbsp;    private String s3Folder;
<i class="no-highlight">278</i>&nbsp;    private String gcsBucket;
<i class="no-highlight">279</i>&nbsp;    private String gcsFolder;
<i class="no-highlight">280</i>&nbsp;    private String dbfsFolder;
<i class="no-highlight">281</i>&nbsp;    private String bqTransferDisplayName;
<i class="no-highlight">282</i>&nbsp;    private String bqRedshiftJdbcUrl;
<i class="no-highlight">283</i>&nbsp;    private String bqRedshiftDbUserName;
<i class="no-highlight">284</i>&nbsp;    private String bqRedshiftDbPassword;
<i class="no-highlight">285</i>&nbsp;    private String bqRedshiftSchemaName;
<i class="no-highlight">286</i>&nbsp;    private String bqRedshiftTableName;
<i class="no-highlight">287</i>&nbsp;    private String loadAction;
<i class="no-highlight">288</i>&nbsp;    private String azureExternalLocation;
<i class="no-highlight">289</i>&nbsp;    private String azureAccountName;
<i class="no-highlight">290</i>&nbsp;    private String azureSasToken;
<i class="no-highlight">291</i>&nbsp;    private String azureContainer;
<i class="no-highlight">292</i>&nbsp;    private String azureFolder;
<i class="no-highlight">293</i>&nbsp;    private String azureSynapseCredential;
<i class="no-highlight">294</i>&nbsp;    private String azureIdentity;
<i class="no-highlight">295</i>&nbsp;    private String azureSecret;
<i class="no-highlight">296</i>&nbsp;    private String azureSynapseExternalStorage;
<i class="no-highlight">297</i>&nbsp;    private String azureSynapseAuthType;
<i class="no-highlight">298</i>&nbsp;    private String azureSynapseEndpoint;
<i class="no-highlight">299</i>&nbsp;    private String errFileAzureAuthType;
<b class="nc"><i class="no-highlight">300</i>&nbsp;    private String errFileAzureAccountName;</b>
<b class="nc"><i class="no-highlight">301</i>&nbsp;    private String errFileAzureEndpoint;</b>
<i class="no-highlight">302</i>&nbsp;    private String errFileAzureContainer;
<i class="no-highlight">303</i>&nbsp;    private String errFileAzureFolder;
<b class="nc"><i class="no-highlight">304</i>&nbsp;    private String errAzureFilePath;</b>
<b class="nc"><i class="no-highlight">305</i>&nbsp;    private String errAzureCredential;</b>
<i class="no-highlight">306</i>&nbsp;    private String errAzureIdentity;
<i class="no-highlight">307</i>&nbsp;    private String errAzureSecret;
<i class="no-highlight">308</i>&nbsp;    private String snowFlakeCredentials = &quot;&quot;;
<i class="no-highlight">309</i>&nbsp;    private String redshiftCredentials = &quot;&quot;;
<i class="no-highlight">310</i>&nbsp;    private boolean isErrFileEnabled;
<i class="no-highlight">311</i>&nbsp;    private boolean isErrFileNewConfigEnabled;
<i class="no-highlight">312</i>&nbsp;    private final StringBuilder queryBuilder = new StringBuilder(2048);
<i class="no-highlight">313</i>&nbsp;    private final List&lt;Object&gt; results = new ArrayList&lt;&gt;();
<i class="no-highlight">314</i>&nbsp;    private String sqlCreateTable;
<i class="no-highlight">315</i>&nbsp;    private String sqlDeleteTable;
<b class="nc"><i class="no-highlight">316</i>&nbsp;    private String sqlAlterTable;</b>
<i class="no-highlight">317</i>&nbsp;    private String sqlRenameTable;
<i class="no-highlight">318</i>&nbsp;    private String sqlInsertIntoSelectAs;
<b class="nc"><i class="no-highlight">319</i>&nbsp;    private String filePathStage;</b>
<i class="no-highlight">320</i>&nbsp;    private String sqlLoadPerFile;
<b class="nc"><i class="no-highlight">321</i>&nbsp;    private String sqlBulkLoad;</b>
<i class="no-highlight">322</i>&nbsp;    private AzureSynapseUtils.AzureDataLakeClient azureDataLakeClient;
<i class="no-highlight">323</i>&nbsp;    private DataLakeFileSystemClient dataLakeFileSystemClient;
<i class="no-highlight">324</i>&nbsp;    private boolean shouldRollbackOrCommit = false;
<i class="no-highlight">325</i>&nbsp;    private String sqlAlterTableDropColumns;
<i class="no-highlight">326</i>&nbsp;    private List&lt;String&gt; sqlDLPAlterTableList;
<i class="no-highlight">327</i>&nbsp;    private boolean doesTableExist = false;
<b class="nc"><i class="no-highlight">328</i>&nbsp;    private static final String DDL_SCRIPT = &quot;CREATE TABLE %s \n(%s \n %s) \n WITH (%s)&quot;;</b>
<i class="no-highlight">329</i>&nbsp;    private boolean isTableAltered = false;
<i class="no-highlight">330</i>&nbsp;    private boolean isColumnToBeDropped;
<b class="nc"><i class="no-highlight">331</i>&nbsp;    private String createBackUpSql;</b>
<b class="nc"><i class="no-highlight">332</i>&nbsp;</b>
<i class="no-highlight">333</i>&nbsp;    private EltDatabaseAccount eltDatabaseAccount;
<i class="no-highlight">334</i>&nbsp;    private boolean isFileFormatOptionHeaderTrue;
<i class="no-highlight">335</i>&nbsp;    private static String targetTableName;
<i class="no-highlight">336</i>&nbsp;    private boolean isSourceFileColumnListSizeDifferentFromTarget = false;
<i class="no-highlight">337</i>&nbsp;    // Target to source column map.
<i class="no-highlight">338</i>&nbsp;    private Map&lt;String, String&gt; columnMappingMap;
<i class="no-highlight">339</i>&nbsp;    protected boolean enableSourceColumnPosition = false;
<i class="no-highlight">340</i>&nbsp;    private boolean needTransformationPreaction = false;
<i class="no-highlight">341</i>&nbsp;    private String sqlCreateStage;
<b class="nc"><i class="no-highlight">342</i>&nbsp;    private String sqlCreateStagedTable;</b>
<i class="no-highlight">343</i>&nbsp;    private String insertSelectSql;
<i class="no-highlight">344</i>&nbsp;    private boolean isIntermediateTableCreated;
<i class="no-highlight">345</i>&nbsp;    private String fqIntermediateTargetTableName;
<i class="no-highlight">346</i>&nbsp;    private boolean isAlterTableAndNonEmptyTargetColumns;
<i class="no-highlight">347</i>&nbsp;    private AmazonS3 s3Client;
<i class="no-highlight">348</i>&nbsp;    protected Set&lt;String&gt; sourceFileColumnNames;
<i class="no-highlight">349</i>&nbsp;    protected List&lt;String&gt; sourceFileColumnTypes;
<i class="no-highlight">350</i>&nbsp;    private boolean isIntermediateTargetTableRequired;
<b class="nc"><i class="no-highlight">351</i>&nbsp;    private boolean checkUnknownType =</b>
<b class="nc"><i class="no-highlight">352</i>&nbsp;            CHECK_UNKNOWN_TYPE_DEFAULT_VALUE;</b>
<b class="nc"><i class="no-highlight">353</i>&nbsp;    private boolean inferSchemaEnabled;</b>
<b class="nc"><i class="no-highlight">354</i>&nbsp;    private boolean isJsonPathsOptionGivenForJson;</b>
<i class="no-highlight">355</i>&nbsp;    private List&lt;String&gt; targetColumnsAfterLoadAction;
<b class="nc"><i class="no-highlight">356</i>&nbsp;    private Set&lt;String&gt; sourceFileFieldNames;</b>
<b class="nc"><i class="no-highlight">357</i>&nbsp;    private List&lt;String&gt; filesForSchemaInference;</b>
<b class="nc"><i class="no-highlight">358</i>&nbsp;    private boolean isFilePatternProcessedAzureCloudStorage;</b>
<b class="nc"><i class="no-highlight">359</i>&nbsp;    // Common file format option variables</b>
<i class="no-highlight">360</i>&nbsp;    private String dateFormat = EMPTY_STRING;
<b class="nc"><i class="no-highlight">361</i>&nbsp;    private String timeFormat = EMPTY_STRING;</b>
<b class="nc"><i class="no-highlight">362</i>&nbsp;    private String encoding = UTF8;</b>
<b class="nc"><i class="no-highlight">363</i>&nbsp;    private String compressionType = EMPTY_STRING;</b>
<b class="nc"><i class="no-highlight">364</i>&nbsp;    // Redshift specific file format option variables</b>
<b class="nc"><i class="no-highlight">365</i>&nbsp;    private char fieldDelimiter = Character.MIN_VALUE;</b>
<b class="nc"><i class="no-highlight">366</i>&nbsp;    private char quoteChar = DOUBLE_QUOTE_CHAR;</b>
<i class="no-highlight">367</i>&nbsp;    private int ignoreHeader = 0;
<b class="nc"><i class="no-highlight">368</i>&nbsp;    private String nullAsStr = EMPTY_STRING;</b>
<b class="nc"><i class="no-highlight">369</i>&nbsp;    // Snowflake specific file format option variables</b>
<i class="no-highlight">370</i>&nbsp;    private int skipHeader = 0;
<i class="no-highlight">371</i>&nbsp;    private String timestampFormat = EMPTY_STRING;
<i class="no-highlight">372</i>&nbsp;    private String binaryFormat = HEX;
<i class="no-highlight">373</i>&nbsp;    private char escapeChar = Character.MIN_VALUE;
<b class="nc"><i class="no-highlight">374</i>&nbsp;    private char fieldOptionallyEnclosedBy = Character.MIN_VALUE;</b>
<b class="nc"><i class="no-highlight">375</i>&nbsp;    private String nullIf = EMPTY_STRING;</b>
<b class="nc"><i class="no-highlight">376</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">377</i>&nbsp;    private final StatisticHolder statistic = new StatisticHolder();</b>
<b class="nc"><i class="no-highlight">378</i>&nbsp;    private final Set&lt;String&gt; executedQueries = new LinkedHashSet&lt;&gt;();</b>
<b class="nc"><i class="no-highlight">379</i>&nbsp;    private boolean isCreatedExternalStageForSchemaInference;</b>
<b class="nc"><i class="no-highlight">380</i>&nbsp;    private boolean matchByColumnNameOption = false;</b>
<b class="nc"><i class="no-highlight">381</i>&nbsp;    /**</b>
<b class="nc"><i class="no-highlight">382</i>&nbsp;     * The next flag indicate we need two step approach for column mapping or transformation</b>
<b class="nc"><i class="no-highlight">383</i>&nbsp;     * since Snowflake does not support direct transformation for a semistructured file</b>
<b class="nc"><i class="no-highlight">384</i>&nbsp;     * type such as JSON or PARQUERT.</b>
<b class="nc"><i class="no-highlight">385</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">386</i>&nbsp;    private boolean isSnowflakeTransformPreprocessingRequired = false;</b>
<b class="nc"><i class="no-highlight">387</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">388</i>&nbsp;    @Override</b>
<b class="nc"><i class="no-highlight">389</i>&nbsp;    public void createSnapProperties(final PropertyBuilder builder) {</b>
<b class="nc"><i class="no-highlight">390</i>&nbsp;        createDatabaseNameProperty(builder);</b>
<b class="nc"><i class="no-highlight">391</i>&nbsp;        createSchemaNameProperty(builder);</b>
<b class="nc"><i class="no-highlight">392</i>&nbsp;        createTargetTableNameProperty(builder);</b>
<i class="no-highlight">393</i>&nbsp;        createHashDistributionColumn(builder);
<i class="no-highlight">394</i>&nbsp;        createAutoCreateTableProperty(builder);
<i class="no-highlight">395</i>&nbsp;        createTableColumnListProperty(builder);
<b class="nc"><i class="no-highlight">396</i>&nbsp;        createTableOptionListProperty(builder);</b>
<i class="no-highlight">397</i>&nbsp;        createBqRedshiftSchemaNameProperty(builder);
<b class="nc"><i class="no-highlight">398</i>&nbsp;        createBqRedshiftTableNameProperty(builder);</b>
<b class="nc"><i class="no-highlight">399</i>&nbsp;        createCloudStorageLocationProperty(builder);</b>
<b class="nc"><i class="no-highlight">400</i>&nbsp;        createFileListProperty(builder);</b>
<b class="nc"><i class="no-highlight">401</i>&nbsp;        createFilePatternProperty(builder);</b>
<i class="no-highlight">402</i>&nbsp;        createFileFormatProperty(builder);
<i class="no-highlight">403</i>&nbsp;        createEncryptionTypeProperty(builder);
<i class="no-highlight">404</i>&nbsp;        createCopyOptionsProperty(builder);
<b class="nc"><i class="no-highlight">405</i>&nbsp;        createValidationOptionsProperty(builder);</b>
<b class="nc"><i class="no-highlight">406</i>&nbsp;        createEnableSoureColumnPositionProperty(builder);</b>
<b class="nc"><i class="no-highlight">407</i>&nbsp;        createColumnsMapTableProperty(builder);</b>
<b class="nc"><i class="no-highlight">408</i>&nbsp;        super.hideSnapExecutionMode(builder);</b>
<b class="nc"><i class="no-highlight">409</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">410</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">411</i>&nbsp;    protected void createEnableSoureColumnPositionProperty(final PropertyBuilder builder) {</b>
<b class="nc"><i class="no-highlight">412</i>&nbsp;        builder.describe(ENABLE_SOURCE_COLUMN_POSITION_PROP, ENABLE_SOURCE_COLUMN_POSITION_LABEL,</b>
<b class="nc"><i class="no-highlight">413</i>&nbsp;                ENABLE_SOURCE_COLUMN_POSITION_DESC)</b>
<b class="nc"><i class="no-highlight">414</i>&nbsp;                .type(SnapType.BOOLEAN)</b>
<b class="nc"><i class="no-highlight">415</i>&nbsp;                .enableIf(NOT_ALTER_COLUMN_ENABLE_COND)</b>
<b class="nc"><i class="no-highlight">416</i>&nbsp;                .defaultValue(Boolean.FALSE)</b>
<i class="no-highlight">417</i>&nbsp;                .add();
<i class="no-highlight">418</i>&nbsp;    }
<i class="no-highlight">419</i>&nbsp;
<b class="nc"><i class="no-highlight">420</i>&nbsp;    private void createValidationOptionsProperty(final PropertyBuilder builder) {</b>
<i class="no-highlight">421</i>&nbsp;        builder.describe(VALIDATION_MODE_PROP, VALIDATION_MODE_LABEL, VALIDATION_MODE_DESC)
<b class="nc"><i class="no-highlight">422</i>&nbsp;                .type(SnapType.STRING)</b>
<b class="nc"><i class="no-highlight">423</i>&nbsp;                .expression()</b>
<b class="nc"><i class="no-highlight">424</i>&nbsp;                .defaultValue(NONE)</b>
<b class="nc"><i class="no-highlight">425</i>&nbsp;                .withSuggestions(this::suggestValidationOptions)</b>
<b class="nc"><i class="no-highlight">426</i>&nbsp;                .add();</b>
<b class="nc"><i class="no-highlight">427</i>&nbsp;        builder.describe(ROWS_TO_RETURN_PROP, ROWS_TO_RETURN_LABEL, ROWS_TO_RETURN_DESC)</b>
<b class="nc"><i class="no-highlight">428</i>&nbsp;                .type(SnapType.STRING)</b>
<i class="no-highlight">429</i>&nbsp;                .enableIf(ROWS_TO_RETURN_ENABLE_COND)
<i class="no-highlight">430</i>&nbsp;                .defaultValue(DEFAULT_ROWS_TO_RETURN)
<i class="no-highlight">431</i>&nbsp;                .expression()
<b class="nc"><i class="no-highlight">432</i>&nbsp;                .add();</b>
<b class="nc"><i class="no-highlight">433</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">434</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">435</i>&nbsp;    private void createCopyOptionsProperty(final PropertyBuilder builder) {</b>
<b class="nc"><i class="no-highlight">436</i>&nbsp;        SnapProperty copyOptionProp = builder.describe(COPY_OPTION_PROP, COPY_OPTION_LABEL,</b>
<b class="nc"><i class="no-highlight">437</i>&nbsp;                COPY_OPTION_DESC)</b>
<b class="nc"><i class="no-highlight">438</i>&nbsp;                .expression()</b>
<b class="nc"><i class="no-highlight">439</i>&nbsp;                .withSuggestions(this::suggestCopyOptions)</b>
<b class="nc"><i class="no-highlight">440</i>&nbsp;                .build();</b>
<b class="nc"><i class="no-highlight">441</i>&nbsp;        builder.describe(COPY_OPTIONS_LIST_PROP, COPY_OPTIONS_LIST_LABEL, COPY_OPTIONS_LIST_DESC)</b>
<i class="no-highlight">442</i>&nbsp;                .type(SnapType.TABLE)
<i class="no-highlight">443</i>&nbsp;                .withEntry(copyOptionProp)
<i class="no-highlight">444</i>&nbsp;                .add();
<b class="nc"><i class="no-highlight">445</i>&nbsp;    }</b>
<i class="no-highlight">446</i>&nbsp;
<b class="nc"><i class="no-highlight">447</i>&nbsp;    private void createEncryptionTypeProperty(final PropertyBuilder builder) {</b>
<i class="no-highlight">448</i>&nbsp;        builder.describe(ENCRYPT_TYPE_PROP, ENCRYPT_KEY_LABEL, ENCRYPT_KEY_DESC)
<b class="nc"><i class="no-highlight">449</i>&nbsp;                .withSuggestions(this::suggestEncryptionTypes)</b>
<b class="nc"><i class="no-highlight">450</i>&nbsp;                .defaultValue(NONE)</b>
<b class="nc"><i class="no-highlight">451</i>&nbsp;                .add();</b>
<i class="no-highlight">452</i>&nbsp;        builder.describe(KMS_KEY_PROP, KMS_KEY_LABEL, KMS_KEY_DESC)
<b class="nc"><i class="no-highlight">453</i>&nbsp;                .type(SnapType.STRING)</b>
<b class="nc"><i class="no-highlight">454</i>&nbsp;                .enableIf(KMS_KEY_ENABLE_COND)</b>
<i class="no-highlight">455</i>&nbsp;                .obfuscate()
<b class="nc"><i class="no-highlight">456</i>&nbsp;                .expression()</b>
<b class="nc"><i class="no-highlight">457</i>&nbsp;                .add();</b>
<b class="nc"><i class="no-highlight">458</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">459</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">460</i>&nbsp;    private void createTableColumnListProperty(final PropertyBuilder builder) {</b>
<i class="no-highlight">461</i>&nbsp;        SnapProperty columnNameProp = builder.describe(TABLE_COLUMN_PROP, TABLE_COLUMN_LABEL,
<b class="nc"><i class="no-highlight">462</i>&nbsp;                TABLE_COLUMN_DESC)</b>
<b class="nc"><i class="no-highlight">463</i>&nbsp;                .withSuggestions(new ColumnNamesSuggestProvider(this, TABLE_COLUMN_PROP,</b>
<b class="nc"><i class="no-highlight">464</i>&nbsp;                        TABLE_COLUMN_LIST_PROP))</b>
<b class="nc"><i class="no-highlight">465</i>&nbsp;                .expression()</b>
<b class="nc"><i class="no-highlight">466</i>&nbsp;                .build();</b>
<b class="nc"><i class="no-highlight">467</i>&nbsp;        SnapProperty columnDataTypeProp = builder.describe(DATA_TYPE_PROP, DATA_TYPE_LABEL,</b>
<b class="nc"><i class="no-highlight">468</i>&nbsp;                DATA_TYPE_DESC)</b>
<b class="nc"><i class="no-highlight">469</i>&nbsp;                .expression()</b>
<b class="nc"><i class="no-highlight">470</i>&nbsp;                .enableIf(DATA_TYPE_ENABLE_COND)</b>
<b class="nc"><i class="no-highlight">471</i>&nbsp;                .withSuggestions((suggestionBuilder, propertyValues) -&gt; suggestionBuilder</b>
<b class="nc"><i class="no-highlight">472</i>&nbsp;                        .node(TABLE_COLUMN_LIST_PROP)</b>
<i class="no-highlight">473</i>&nbsp;                        .over(DATA_TYPE_PROP)
<i class="no-highlight">474</i>&nbsp;                        .suggestions(SupportedDataTypesUtils.getSupportedDataTypes(getName())))
<i class="no-highlight">475</i>&nbsp;                .build();
<b class="nc"><i class="no-highlight">476</i>&nbsp;        SnapProperty alterColumnProp = builder.describe(ALTER_COLUMN_PROP, ALTER_COLUMN_LABEL,</b>
<b class="nc"><i class="no-highlight">477</i>&nbsp;                ALTER_COLUMN_DESC)</b>
<b class="nc"><i class="no-highlight">478</i>&nbsp;                .withAllowedValues(ALTER_COLUMN_MODIFIERS)</b>
<b class="nc"><i class="no-highlight">479</i>&nbsp;                .enableIf(ALTER_COLUMN_ENABLE_COND)</b>
<b class="nc"><i class="no-highlight">480</i>&nbsp;                .defaultValue(ADD)</b>
<b class="nc"><i class="no-highlight">481</i>&nbsp;                .build();</b>
<b class="nc"><i class="no-highlight">482</i>&nbsp;        builder.describe(TABLE_COLUMN_LIST_PROP, TABLE_COLUMNS_LIST_LABEL, TABLE_COLUMNS_LIST_DESC)</b>
<i class="no-highlight">483</i>&nbsp;                .type(SnapType.TABLE)
<b class="nc"><i class="no-highlight">484</i>&nbsp;                .enableIf(COLUMN_LIST_ENABLE_COND)</b>
<b class="nc"><i class="no-highlight">485</i>&nbsp;                .withEntry(columnNameProp)</b>
<b class="nc"><i class="no-highlight">486</i>&nbsp;                .withEntry(columnDataTypeProp)</b>
<b class="nc"><i class="no-highlight">487</i>&nbsp;                .withEntry(alterColumnProp)</b>
<i class="no-highlight">488</i>&nbsp;                .add();
<b class="nc"><i class="no-highlight">489</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">490</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">491</i>&nbsp;    private void createFileFormatProperty(final PropertyBuilder builder) {</b>
<i class="no-highlight">492</i>&nbsp;        builder.describe(FILE_FORMAT_TYPE_PROP, FILE_FORMAT_TYPE_LABEL, FILE_FORMAT_TYPE_DESC)
<i class="no-highlight">493</i>&nbsp;                .type(SnapType.STRING)
<i class="no-highlight">494</i>&nbsp;                .expression()
<b class="nc"><i class="no-highlight">495</i>&nbsp;                .defaultValue(NONE)</b>
<b class="nc"><i class="no-highlight">496</i>&nbsp;                .withSuggestions(this::suggestFileFormat)</b>
<b class="nc"><i class="no-highlight">497</i>&nbsp;                .add();</b>
<b class="nc"><i class="no-highlight">498</i>&nbsp;        SnapProperty fileFormatOptionProp = builder.describe(FILE_FORMAT_OPTION_PROP,</b>
<i class="no-highlight">499</i>&nbsp;                FILE_FORMAT_OPTION_LABEL, FILE_FORMAT_OPTION_DESC)
<i class="no-highlight">500</i>&nbsp;                .expression()
<i class="no-highlight">501</i>&nbsp;                .withSuggestions(this::suggestFileFormatOptions)
<b class="nc"><i class="no-highlight">502</i>&nbsp;                .build();</b>
<b class="nc"><i class="no-highlight">503</i>&nbsp;        builder.describe(FILE_FORMAT_OPTIONS_LIST_PROP, FILE_FORMAT_OPTIONS_LIST_LABEL,</b>
<b class="nc"><i class="no-highlight">504</i>&nbsp;                FILE_FORMAT_OPTIONS_LIST_DESC)</b>
<b class="nc"><i class="no-highlight">505</i>&nbsp;                .type(SnapType.TABLE)</b>
<b class="nc"><i class="no-highlight">506</i>&nbsp;                .withEntry(fileFormatOptionProp)</b>
<b class="nc"><i class="no-highlight">507</i>&nbsp;                .add();</b>
<b class="nc"><i class="no-highlight">508</i>&nbsp;    }</b>
<i class="no-highlight">509</i>&nbsp;
<i class="no-highlight">510</i>&nbsp;    private void createFilePatternProperty(final PropertyBuilder builder) {
<i class="no-highlight">511</i>&nbsp;        builder.describe(FILE_PATTERN_PROP, FILE_PATTERN_LABEL, FILE_PATTERN_DESC)
<b class="nc"><i class="no-highlight">512</i>&nbsp;                .type(SnapType.STRING)</b>
<i class="no-highlight">513</i>&nbsp;                .expression()
<i class="no-highlight">514</i>&nbsp;                .add();
<b class="nc"><i class="no-highlight">515</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">516</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">517</i>&nbsp;    private void createFileListProperty(final PropertyBuilder builder) {</b>
<i class="no-highlight">518</i>&nbsp;        SnapProperty file = builder.describe(FILE_PROP, FILE_LABEL, FILE_DESC)
<i class="no-highlight">519</i>&nbsp;                .expression()
<i class="no-highlight">520</i>&nbsp;                .build();
<b class="nc"><i class="no-highlight">521</i>&nbsp;        builder.describe(FILE_LIST_PROP, FILE_LIST_LABEL, FILE_LIST_DESC)</b>
<i class="no-highlight">522</i>&nbsp;                .type(SnapType.TABLE)
<i class="no-highlight">523</i>&nbsp;                .withEntry(file)
<b class="nc"><i class="no-highlight">524</i>&nbsp;                .add();</b>
<b class="nc"><i class="no-highlight">525</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">526</i>&nbsp;</b>
<i class="no-highlight">527</i>&nbsp;    private void createBqRedshiftSchemaNameProperty(final PropertyBuilder builder) {
<i class="no-highlight">528</i>&nbsp;        builder.describe(BQ_REDSHIFT_SCHEMA_NAME_PROP,
<i class="no-highlight">529</i>&nbsp;                BQ_REDSHIFT_SCHEMA_NAME_LABEL,
<b class="nc"><i class="no-highlight">530</i>&nbsp;                BQ_REDSHIFT_SCHEMA_NAME_DESC)</b>
<i class="no-highlight">531</i>&nbsp;                .type(SnapType.STRING)
<i class="no-highlight">532</i>&nbsp;                .expression()
<b class="nc"><i class="no-highlight">533</i>&nbsp;                .add();</b>
<b class="nc"><i class="no-highlight">534</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">535</i>&nbsp;</b>
<i class="no-highlight">536</i>&nbsp;    private void createBqRedshiftTableNameProperty(final PropertyBuilder builder) {
<i class="no-highlight">537</i>&nbsp;        builder.describe(BQ_REDSHIFT_TABLE_NAME_PROP,
<i class="no-highlight">538</i>&nbsp;                BQ_REDSHIFT_TABLE_NAME_LABEL,
<b class="nc"><i class="no-highlight">539</i>&nbsp;                BQ_REDSHIFT_TABLE_NAME_DESC)</b>
<b class="nc"><i class="no-highlight">540</i>&nbsp;                .type(SnapType.STRING)</b>
<b class="nc"><i class="no-highlight">541</i>&nbsp;                .expression()</b>
<b class="nc"><i class="no-highlight">542</i>&nbsp;                .add();</b>
<i class="no-highlight">543</i>&nbsp;    }
<i class="no-highlight">544</i>&nbsp;
<i class="no-highlight">545</i>&nbsp;    private void createCloudStorageLocationProperty(final PropertyBuilder builder) {
<b class="nc"><i class="no-highlight">546</i>&nbsp;        builder.describe(CLOUD_STORAGE_PATH_PROP,</b>
<b class="nc"><i class="no-highlight">547</i>&nbsp;                        CLOUD_STORAGE_PATH_LABEL,</b>
<b class="nc"><i class="no-highlight">548</i>&nbsp;                        CLOUD_STORAGE_PATH_DESC)</b>
<b class="nc"><i class="no-highlight">549</i>&nbsp;                .type(SnapType.STRING)</b>
<b class="nc"><i class="no-highlight">550</i>&nbsp;                .expression()</b>
<i class="no-highlight">551</i>&nbsp;                .add();
<b class="nc"><i class="no-highlight">552</i>&nbsp;    }</b>
<i class="no-highlight">553</i>&nbsp;
<i class="no-highlight">554</i>&nbsp;    private void createAutoCreateTableProperty(final PropertyBuilder builder) {
<b class="nc"><i class="no-highlight">555</i>&nbsp;        builder.describe(LOAD_ACTION_PROP, LOAD_ACTION_LABEL, LOAD_ACTION_DESC)</b>
<b class="nc"><i class="no-highlight">556</i>&nbsp;                .withAllowedValues(LOAD_ACTION_TYPE)</b>
<b class="nc"><i class="no-highlight">557</i>&nbsp;                .defaultValue(APPEND_ROWS_TABLE)</b>
<b class="nc"><i class="no-highlight">558</i>&nbsp;                .add();</b>
<b class="nc"><i class="no-highlight">559</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">560</i>&nbsp;</b>
<i class="no-highlight">561</i>&nbsp;    private void createColumnsMapTableProperty(final PropertyBuilder builder) {
<i class="no-highlight">562</i>&nbsp;        SnapProperty targetColumnProp = createTargetTableColumnNameProperty(builder);
<i class="no-highlight">563</i>&nbsp;        SnapProperty sourceColumnNameProp =
<b class="nc"><i class="no-highlight">564</i>&nbsp;                createSourceFileColumnNameProperty(builder);</b>
<i class="no-highlight">565</i>&nbsp;        SnapProperty sourceColumnPositionProp =
<b class="nc"><i class="no-highlight">566</i>&nbsp;                createSourceFileColumnPositionProperty(builder);</b>
<i class="no-highlight">567</i>&nbsp;
<i class="no-highlight">568</i>&nbsp;        builder.describe(TARGET_TO_SOURCE_COLUMNS_MAP_PROP,
<b class="nc"><i class="no-highlight">569</i>&nbsp;                TARGET_TO_SOURCE_COLUMNS_MAP_LABEL,</b>
<b class="nc"><i class="no-highlight">570</i>&nbsp;                TARGET_TO_SOURCE_COLUMNS_MAP_DESC)</b>
<i class="no-highlight">571</i>&nbsp;                .type(SnapType.TABLE)
<i class="no-highlight">572</i>&nbsp;                .enableIf(NOT_ALTER_COLUMN_ENABLE_COND)
<i class="no-highlight">573</i>&nbsp;                .withEntry(targetColumnProp)
<i class="no-highlight">574</i>&nbsp;                .withEntry(sourceColumnNameProp)
<b class="nc"><i class="no-highlight">575</i>&nbsp;                .withEntry(sourceColumnPositionProp)</b>
<i class="no-highlight">576</i>&nbsp;                .add();
<i class="no-highlight">577</i>&nbsp;    }
<b class="nc"><i class="no-highlight">578</i>&nbsp;</b>
<i class="no-highlight">579</i>&nbsp;    private SnapProperty createTargetTableColumnNameProperty(final PropertyBuilder builder) {
<i class="no-highlight">580</i>&nbsp;        return builder.describe(TARGET_TABLE_COLUMN_NAME_PROP,
<i class="no-highlight">581</i>&nbsp;                LOAD_TARGET_TABLE_COLUMN_NAME_LABEL, LOAD_TARGET_TABLE_COLUMN_NAME_DESC)
<i class="no-highlight">582</i>&nbsp;                .withSuggestions(new ColumnNamesSuggestProvider(this,
<b class="nc"><i class="no-highlight">583</i>&nbsp;                        TARGET_TABLE_COLUMN_NAME_PROP,</b>
<b class="nc"><i class="no-highlight">584</i>&nbsp;                        TARGET_TO_SOURCE_COLUMNS_MAP_PROP))</b>
<b class="nc"><i class="no-highlight">585</i>&nbsp;                .expression()</b>
<i class="no-highlight">586</i>&nbsp;                .build();
<i class="no-highlight">587</i>&nbsp;    }
<i class="no-highlight">588</i>&nbsp;
<i class="no-highlight">589</i>&nbsp;    private SnapProperty createSourceFileColumnNameProperty(
<b class="nc"><i class="no-highlight">590</i>&nbsp;            final PropertyBuilder builder) {</b>
<i class="no-highlight">591</i>&nbsp;        return builder.describe(SOURCE_FILE_COLUMN_NAME_PROP,
<i class="no-highlight">592</i>&nbsp;                SOURCE_FILE_COLUMN_NAME_LABEL,
<b class="nc"><i class="no-highlight">593</i>&nbsp;                SOURCE_FILE_COLUMN_NAME_DESC)</b>
<b class="nc"><i class="no-highlight">594</i>&nbsp;                .withSuggestions(new ColumnNamesSuggestProvider(this,</b>
<b class="nc"><i class="no-highlight">595</i>&nbsp;                        SOURCE_FILE_COLUMN_NAME_PROP,</b>
<i class="no-highlight">596</i>&nbsp;                        TARGET_TO_SOURCE_COLUMNS_MAP_PROP,
<i class="no-highlight">597</i>&nbsp;                        true
<i class="no-highlight">598</i>&nbsp;                        ))
<i class="no-highlight">599</i>&nbsp;                .expression()
<i class="no-highlight">600</i>&nbsp;                .enableIf(DO_NOT_ENABLE_SOURCE_COLUMN_POSITION_CONDITION)
<i class="no-highlight">601</i>&nbsp;                .build();
<i class="no-highlight">602</i>&nbsp;    }
<i class="no-highlight">603</i>&nbsp;
<i class="no-highlight">604</i>&nbsp;    private SnapProperty createSourceFileColumnPositionProperty(
<i class="no-highlight">605</i>&nbsp;            final PropertyBuilder builder) {
<i class="no-highlight">606</i>&nbsp;        return builder.describe(SOURCE_FILE_COLUMN_POSITION_PROP,
<b class="nc"><i class="no-highlight">607</i>&nbsp;                SOURCE_FILE_COLUMN_POSITION_LABEL,</b>
<i class="no-highlight">608</i>&nbsp;                SOURCE_FILE_COLUMN_POSITION_DESC)
<b class="nc"><i class="no-highlight">609</i>&nbsp;                .expression()</b>
<i class="no-highlight">610</i>&nbsp;                .enableIf(ENABLE_SOURCE_COLUMN_POSITION_CONDITION)
<b class="nc"><i class="no-highlight">611</i>&nbsp;                .build();</b>
<b class="nc"><i class="no-highlight">612</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">613</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">614</i>&nbsp;    /**</b>
<i class="no-highlight">615</i>&nbsp;     * Gets all the copy options for the field based on database selected in account settings
<b class="nc"><i class="no-highlight">616</i>&nbsp;     *</b>
<b class="nc"><i class="no-highlight">617</i>&nbsp;     * @param suggestionBuilder is passed to the suggestion provider to help</b>
<b class="nc"><i class="no-highlight">618</i>&nbsp;     *                          with suggestion building operation.</b>
<i class="no-highlight">619</i>&nbsp;     * @param propertyValues    holds all the property values configured for a snap.
<i class="no-highlight">620</i>&nbsp;     */
<b class="nc"><i class="no-highlight">621</i>&nbsp;    public void suggestCopyOptions(final SuggestionBuilder suggestionBuilder,</b>
<b class="nc"><i class="no-highlight">622</i>&nbsp;                                   final PropertyValues propertyValues) {</b>
<i class="no-highlight">623</i>&nbsp;        String dbName = getName();
<b class="nc"><i class="no-highlight">624</i>&nbsp;        Set&lt;String&gt; copyOpts;</b>
<i class="no-highlight">625</i>&nbsp;        switch (dbName) {
<b class="nc"><i class="no-highlight">626</i>&nbsp;            case JdbcOperations.SNOWFLAKE:</b>
<b class="nc"><i class="no-highlight">627</i>&nbsp;                suggestionBuilder.node(COPY_OPTIONS_LIST_PROP)</b>
<b class="nc"><i class="no-highlight">628</i>&nbsp;                        .over(COPY_OPTION_PROP)</b>
<b class="nc"><i class="no-highlight">629</i>&nbsp;                        .suggestions(SNOWFLAKE_COPY_OPTIONS.toArray(new String[0]));</b>
<b class="nc"><i class="no-highlight">630</i>&nbsp;                break;</b>
<i class="no-highlight">631</i>&nbsp;            case JdbcOperations.REDSHIFT:
<b class="nc"><i class="no-highlight">632</i>&nbsp;                fileFormatType =</b>
<b class="nc"><i class="no-highlight">633</i>&nbsp;                        propertyValues.getAsExpression(FILE_FORMAT_TYPE_PROP).eval(null);</b>
<b class="nc"><i class="no-highlight">634</i>&nbsp;                switch (fileFormatType) {</b>
<i class="no-highlight">635</i>&nbsp;                    case ORC:
<i class="no-highlight">636</i>&nbsp;                    case PARQUET:
<b class="nc"><i class="no-highlight">637</i>&nbsp;                        copyOpts = REDSHIFT_COPY_ORC_PARQUET_OPTIONS;</b>
<b class="nc"><i class="no-highlight">638</i>&nbsp;                        break;</b>
<i class="no-highlight">639</i>&nbsp;                    default:
<b class="nc"><i class="no-highlight">640</i>&nbsp;                        copyOpts = REDSHIFT_COPY_OPTIONS;</b>
<b class="nc"><i class="no-highlight">641</i>&nbsp;                }</b>
<i class="no-highlight">642</i>&nbsp;                suggestionBuilder.node(COPY_OPTIONS_LIST_PROP)
<b class="nc"><i class="no-highlight">643</i>&nbsp;                        .over(COPY_OPTION_PROP)</b>
<b class="nc"><i class="no-highlight">644</i>&nbsp;                        .suggestions(copyOpts.toArray(</b>
<b class="nc"><i class="no-highlight">645</i>&nbsp;                                new String[copyOpts.size()]));</b>
<i class="no-highlight">646</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">647</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:</b>
<b class="nc"><i class="no-highlight">648</i>&nbsp;                fileFormatType =</b>
<b class="nc"><i class="no-highlight">649</i>&nbsp;                        propertyValues.getAsExpression(FILE_FORMAT_TYPE_PROP).eval(null);</b>
<b class="nc"><i class="no-highlight">650</i>&nbsp;                switch (fileFormatType) {</b>
<i class="no-highlight">651</i>&nbsp;                    case ORC:
<b class="nc"><i class="no-highlight">652</i>&nbsp;                    case PARQUET:</b>
<b class="nc"><i class="no-highlight">653</i>&nbsp;                        copyOpts = AZURE_SYNAPSE_COPY_ORC_PARQUET_OPTIONS;</b>
<b class="nc"><i class="no-highlight">654</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">655</i>&nbsp;                    case CSV:</b>
<i class="no-highlight">656</i>&nbsp;                        copyOpts = AZURE_SYNAPSE_COPY_CSV_OPTIONS;
<b class="nc"><i class="no-highlight">657</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">658</i>&nbsp;                    default:</b>
<b class="nc"><i class="no-highlight">659</i>&nbsp;                        throw new ConfigurationException(ERR_SUGGESTING_COPY_OPT)</b>
<b class="nc"><i class="no-highlight">660</i>&nbsp;                                .withReason(ERR_SUGGESTING_COPY_OPT_REASON)</b>
<i class="no-highlight">661</i>&nbsp;                                .withResolution(ERR_SUGGESTING_COPY_OPT_RESOLUTION);
<b class="nc"><i class="no-highlight">662</i>&nbsp;                }</b>
<i class="no-highlight">663</i>&nbsp;                suggestionBuilder.node(COPY_OPTIONS_LIST_PROP)
<i class="no-highlight">664</i>&nbsp;                        .over(COPY_OPTION_PROP)
<i class="no-highlight">665</i>&nbsp;                        .suggestions(copyOpts.toArray(new String[0]));
<i class="no-highlight">666</i>&nbsp;                break;
<i class="no-highlight">667</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:
<i class="no-highlight">668</i>&nbsp;                suggestionBuilder.node(COPY_OPTIONS_LIST_PROP)
<i class="no-highlight">669</i>&nbsp;                        .over(COPY_OPTION_PROP)
<i class="no-highlight">670</i>&nbsp;                        .suggestions(DLP_COPY_OPTIONS.toArray(new String[0]));
<i class="no-highlight">671</i>&nbsp;                break;
<i class="no-highlight">672</i>&nbsp;            case JdbcOperations.BIGQUERY:
<i class="no-highlight">673</i>&nbsp;                suggestionBuilder.node(COPY_OPTIONS_LIST_PROP)
<i class="no-highlight">674</i>&nbsp;                        .over(COPY_OPTION_PROP)
<b class="nc"><i class="no-highlight">675</i>&nbsp;                        .suggestions(BIGQUERY_COPY_OPTIONS.toArray(new String[0]));</b>
<b class="nc"><i class="no-highlight">676</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">677</i>&nbsp;            default:</b>
<i class="no-highlight">678</i>&nbsp;                throwInvalidDbTypeException();
<b class="nc"><i class="no-highlight">679</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">680</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">681</i>&nbsp;</b>
<i class="no-highlight">682</i>&nbsp;    /**
<b class="nc"><i class="no-highlight">683</i>&nbsp;     * Gets all the format options for the field based on database selected in account settings</b>
<b class="nc"><i class="no-highlight">684</i>&nbsp;     *</b>
<i class="no-highlight">685</i>&nbsp;     * @param suggestionBuilder is passed to the suggestion provider to help
<b class="nc"><i class="no-highlight">686</i>&nbsp;     *                          with suggestion building operation.</b>
<b class="nc"><i class="no-highlight">687</i>&nbsp;     * @param propertyValues    holds all the property values configured for a snap.</b>
<i class="no-highlight">688</i>&nbsp;     */
<b class="nc"><i class="no-highlight">689</i>&nbsp;    public void suggestFileFormatOptions(final SuggestionBuilder suggestionBuilder,</b>
<b class="nc"><i class="no-highlight">690</i>&nbsp;                                         final PropertyValues propertyValues) {</b>
<i class="no-highlight">691</i>&nbsp;        String dbName = getName();
<b class="nc"><i class="no-highlight">692</i>&nbsp;        Set&lt;String&gt; fileFormatOpts = null;</b>
<b class="nc"><i class="no-highlight">693</i>&nbsp;        switch (dbName) {</b>
<i class="no-highlight">694</i>&nbsp;            case JdbcOperations.SNOWFLAKE:
<b class="nc"><i class="no-highlight">695</i>&nbsp;                fileFormatType =</b>
<b class="nc"><i class="no-highlight">696</i>&nbsp;                        propertyValues.getAsExpression(FILE_FORMAT_TYPE_PROP).eval(null);</b>
<i class="no-highlight">697</i>&nbsp;                switch (fileFormatType) {
<b class="nc"><i class="no-highlight">698</i>&nbsp;                    case CSV:</b>
<b class="nc"><i class="no-highlight">699</i>&nbsp;                        fileFormatOpts = SNOWFLAKE_FILE_FORMAT_CSV_OPTIONS;</b>
<i class="no-highlight">700</i>&nbsp;                        break;
<b class="nc"><i class="no-highlight">701</i>&nbsp;                    case JSON:</b>
<b class="nc"><i class="no-highlight">702</i>&nbsp;                        fileFormatOpts = SNOWFLAKE_FILE_FORMAT_JSON_OPTIONS;</b>
<b class="nc"><i class="no-highlight">703</i>&nbsp;                        break;</b>
<i class="no-highlight">704</i>&nbsp;                    case PARQUET:
<b class="nc"><i class="no-highlight">705</i>&nbsp;                        fileFormatOpts = SNOWFLAKE_FILE_FORMAT_PARQUET_OPTIONS;</b>
<i class="no-highlight">706</i>&nbsp;                        break;
<i class="no-highlight">707</i>&nbsp;                    case ORC:
<b class="nc"><i class="no-highlight">708</i>&nbsp;                        fileFormatOpts = SNOWFLAKE_FILE_FORMAT_ORC_OPTIONS;</b>
<b class="nc"><i class="no-highlight">709</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">710</i>&nbsp;                    case AVRO:</b>
<i class="no-highlight">711</i>&nbsp;                        fileFormatOpts = SNOWFLAKE_FILE_FORMAT_AVRO_OPTIONS;
<b class="nc"><i class="no-highlight">712</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">713</i>&nbsp;                    case XML:</b>
<i class="no-highlight">714</i>&nbsp;                        fileFormatOpts = SNOWFLAKE_FILE_FORMAT_XML_OPTIONS;
<b class="nc"><i class="no-highlight">715</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">716</i>&nbsp;                    default:</b>
<i class="no-highlight">717</i>&nbsp;                        throw new ConfigurationException(ERR_SUGGESTING_FILE_FORMAT_OPT)
<i class="no-highlight">718</i>&nbsp;                                .withReason(ERR_SUGGESTING_FILE_FORMAT_OPT_REASON)
<b class="nc"><i class="no-highlight">719</i>&nbsp;                                .withResolution(ERR_SUGGESTING_FILE_FORMAT_OPT_RESOLUTION);</b>
<b class="nc"><i class="no-highlight">720</i>&nbsp;                }</b>
<i class="no-highlight">721</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">722</i>&nbsp;            case JdbcOperations.REDSHIFT:</b>
<b class="nc"><i class="no-highlight">723</i>&nbsp;                // Find all parameters in COPY command for Redshift</b>
<i class="no-highlight">724</i>&nbsp;                fileFormatType =
<b class="nc"><i class="no-highlight">725</i>&nbsp;                        propertyValues.getAsExpression(FILE_FORMAT_TYPE_PROP).eval(null);</b>
<b class="nc"><i class="no-highlight">726</i>&nbsp;                switch (fileFormatType) {</b>
<b class="nc"><i class="no-highlight">727</i>&nbsp;                    case CSV:</b>
<i class="no-highlight">728</i>&nbsp;                        fileFormatOpts = REDSHIFT_FILE_FORMAT_CSV_OPTIONS;
<b class="nc"><i class="no-highlight">729</i>&nbsp;                        break;</b>
<i class="no-highlight">730</i>&nbsp;                    case JSON:
<b class="nc"><i class="no-highlight">731</i>&nbsp;                        fileFormatOpts = REDSHIFT_FILE_FORMAT_JSON_OPTIONS;</b>
<b class="nc"><i class="no-highlight">732</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">733</i>&nbsp;                    case PARQUET:</b>
<i class="no-highlight">734</i>&nbsp;                    case ORC:
<b class="nc"><i class="no-highlight">735</i>&nbsp;                        fileFormatOpts = REDSHIFT_FILE_FORMAT_ORC_PARQUET_OPTIONS;</b>
<b class="nc"><i class="no-highlight">736</i>&nbsp;                        break;</b>
<i class="no-highlight">737</i>&nbsp;                    case AVRO:
<b class="nc"><i class="no-highlight">738</i>&nbsp;                        fileFormatOpts = REDSHIFT_FILE_FORMAT_AVRO_OPTIONS;</b>
<b class="nc"><i class="no-highlight">739</i>&nbsp;                        break;</b>
<i class="no-highlight">740</i>&nbsp;                    default:
<b class="nc"><i class="no-highlight">741</i>&nbsp;                        throw new ConfigurationException(ERR_SUGGESTING_FILE_FORMAT_OPT)</b>
<b class="nc"><i class="no-highlight">742</i>&nbsp;                                .withReason(ERR_SUGGESTING_FILE_FORMAT_OPT_REASON)</b>
<i class="no-highlight">743</i>&nbsp;                                .withResolution(ERR_SUGGESTING_FILE_FORMAT_OPT_RESOLUTION);
<b class="nc"><i class="no-highlight">744</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">745</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">746</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:</b>
<i class="no-highlight">747</i>&nbsp;                fileFormatType =
<b class="nc"><i class="no-highlight">748</i>&nbsp;                        propertyValues.getAsExpression(FILE_FORMAT_TYPE_PROP).eval(null);</b>
<i class="no-highlight">749</i>&nbsp;                switch (fileFormatType) {
<b class="nc"><i class="no-highlight">750</i>&nbsp;                    case CSV:</b>
<b class="nc"><i class="no-highlight">751</i>&nbsp;                        fileFormatOpts = AZURE_SYNAPSE_FILE_FORMAT_CSV_OPTIONS;</b>
<i class="no-highlight">752</i>&nbsp;                        break;
<b class="nc"><i class="no-highlight">753</i>&nbsp;                    case ORC:</b>
<b class="nc"><i class="no-highlight">754</i>&nbsp;                        fileFormatOpts = AZURE_SYNAPSE_FILE_FORMAT_ORC_OPTIONS;</b>
<i class="no-highlight">755</i>&nbsp;                        break;
<b class="nc"><i class="no-highlight">756</i>&nbsp;                    case PARQUET:</b>
<b class="nc"><i class="no-highlight">757</i>&nbsp;                        fileFormatOpts = AZURE_SYNAPSE_FILE_FORMAT_PARQUET_OPTIONS;</b>
<i class="no-highlight">758</i>&nbsp;                        break;
<b class="nc"><i class="no-highlight">759</i>&nbsp;                    default:</b>
<b class="nc"><i class="no-highlight">760</i>&nbsp;                        throw new ConfigurationException(ERR_SUGGESTING_FILE_FORMAT_OPT)</b>
<i class="no-highlight">761</i>&nbsp;                                .withReason(ERR_SUGGESTING_FILE_FORMAT_OPT_REASON)
<b class="nc"><i class="no-highlight">762</i>&nbsp;                                .withResolution(ERR_SUGGESTING_FILE_FORMAT_OPT_RESOLUTION);</b>
<b class="nc"><i class="no-highlight">763</i>&nbsp;                }</b>
<i class="no-highlight">764</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">765</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:</b>
<b class="nc"><i class="no-highlight">766</i>&nbsp;                fileFormatType = propertyValues.getAsExpression(FILE_FORMAT_TYPE_PROP).eval(null);</b>
<i class="no-highlight">767</i>&nbsp;                switch (fileFormatType) {
<b class="nc"><i class="no-highlight">768</i>&nbsp;                    case CSV:</b>
<b class="nc"><i class="no-highlight">769</i>&nbsp;                        fileFormatOpts = DLP_FILE_FORMAT_CSV_OPTIONS;</b>
<b class="nc"><i class="no-highlight">770</i>&nbsp;                        break;</b>
<i class="no-highlight">771</i>&nbsp;                    case JSON:
<b class="nc"><i class="no-highlight">772</i>&nbsp;                        fileFormatOpts = DLP_FILE_FORMAT_JSON_OPTIONS;</b>
<i class="no-highlight">773</i>&nbsp;                        break;
<b class="nc"><i class="no-highlight">774</i>&nbsp;                    case PARQUET:</b>
<b class="nc"><i class="no-highlight">775</i>&nbsp;                        fileFormatOpts = DLP_FILE_FORMAT_PARQUET_OPTIONS;</b>
<i class="no-highlight">776</i>&nbsp;                        break;
<b class="nc"><i class="no-highlight">777</i>&nbsp;                    case ORC:</b>
<b class="nc"><i class="no-highlight">778</i>&nbsp;                        fileFormatOpts = DLP_FILE_FORMAT_ORC_OPTIONS;</b>
<i class="no-highlight">779</i>&nbsp;                        break;
<b class="nc"><i class="no-highlight">780</i>&nbsp;                    case AVRO:</b>
<b class="nc"><i class="no-highlight">781</i>&nbsp;                        fileFormatOpts = DLP_FILE_FORMAT_AVRO_OPTIONS;</b>
<i class="no-highlight">782</i>&nbsp;                        break;
<b class="nc"><i class="no-highlight">783</i>&nbsp;                    default:</b>
<b class="nc"><i class="no-highlight">784</i>&nbsp;                        throw new ConfigurationException(ERR_SUGGESTING_FILE_FORMAT_OPT)</b>
<i class="no-highlight">785</i>&nbsp;                                .withReason(ERR_SUGGESTING_FILE_FORMAT_OPT_REASON)
<b class="nc"><i class="no-highlight">786</i>&nbsp;                                .withResolution(ERR_SUGGESTING_FILE_FORMAT_OPT_RESOLUTION);</b>
<b class="nc"><i class="no-highlight">787</i>&nbsp;                }</b>
<i class="no-highlight">788</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">789</i>&nbsp;            case JdbcOperations.BIGQUERY:</b>
<b class="nc"><i class="no-highlight">790</i>&nbsp;                fileFormatType = propertyValues.getAsExpression(FILE_FORMAT_TYPE_PROP).eval(null);</b>
<i class="no-highlight">791</i>&nbsp;                switch (fileFormatType) {
<b class="nc"><i class="no-highlight">792</i>&nbsp;                    case CSV:</b>
<b class="nc"><i class="no-highlight">793</i>&nbsp;                        fileFormatOpts = BIGQUERY_FILE_FORMAT_CSV_OPTIONS;</b>
<b class="nc"><i class="no-highlight">794</i>&nbsp;                        break;</b>
<i class="no-highlight">795</i>&nbsp;                    case JSON:
<b class="nc"><i class="no-highlight">796</i>&nbsp;                        fileFormatOpts = BIGQUERY_FILE_FORMAT_JSON_OPTIONS;</b>
<i class="no-highlight">797</i>&nbsp;                        break;
<b class="nc"><i class="no-highlight">798</i>&nbsp;                    case PARQUET:</b>
<i class="no-highlight">799</i>&nbsp;                        fileFormatOpts = BIGQUERY_FILE_FORMAT_PARQUET_OPTIONS;
<b class="nc"><i class="no-highlight">800</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">801</i>&nbsp;                    case ORC:</b>
<b class="nc"><i class="no-highlight">802</i>&nbsp;                        fileFormatOpts = BIGQUERY_FILE_FORMAT_ORC_OPTIONS;</b>
<b class="nc"><i class="no-highlight">803</i>&nbsp;                        break;</b>
<i class="no-highlight">804</i>&nbsp;                    case AVRO:
<i class="no-highlight">805</i>&nbsp;                        fileFormatOpts = BIGQUERY_FILE_FORMAT_AVRO_OPTIONS;
<i class="no-highlight">806</i>&nbsp;                        break;
<i class="no-highlight">807</i>&nbsp;                    default:
<i class="no-highlight">808</i>&nbsp;                        throw new ConfigurationException(ERR_SUGGESTING_FILE_FORMAT_OPT)
<i class="no-highlight">809</i>&nbsp;                                .withReason(ERR_SUGGESTING_FILE_FORMAT_OPT_REASON)
<i class="no-highlight">810</i>&nbsp;                                .withResolution(ERR_SUGGESTING_FILE_FORMAT_OPT_RESOLUTION);
<i class="no-highlight">811</i>&nbsp;                }
<i class="no-highlight">812</i>&nbsp;                break;
<i class="no-highlight">813</i>&nbsp;            default:
<i class="no-highlight">814</i>&nbsp;                throwInvalidDbTypeException();
<b class="nc"><i class="no-highlight">815</i>&nbsp;        }</b>
<i class="no-highlight">816</i>&nbsp;        suggestionBuilder.node(FILE_FORMAT_OPTIONS_LIST_PROP)
<b class="nc"><i class="no-highlight">817</i>&nbsp;                .over(FILE_FORMAT_OPTION_PROP)</b>
<i class="no-highlight">818</i>&nbsp;                .suggestions(fileFormatOpts.toArray(
<b class="nc"><i class="no-highlight">819</i>&nbsp;                        new String[fileFormatOpts.size()]));</b>
<b class="nc"><i class="no-highlight">820</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">821</i>&nbsp;</b>
<i class="no-highlight">822</i>&nbsp;    /**
<b class="nc"><i class="no-highlight">823</i>&nbsp;     * Gets the validation mode options based on database type</b>
<b class="nc"><i class="no-highlight">824</i>&nbsp;     *</b>
<b class="nc"><i class="no-highlight">825</i>&nbsp;     * @param suggestionBuilder is passed to the suggestion provider to help</b>
<i class="no-highlight">826</i>&nbsp;     *                          with suggestion building operation.
<b class="nc"><i class="no-highlight">827</i>&nbsp;     * @param propertyValues    holds all the property values configured for a snap.</b>
<b class="nc"><i class="no-highlight">828</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">829</i>&nbsp;    public void suggestFileFormat(final SuggestionBuilder suggestionBuilder,</b>
<i class="no-highlight">830</i>&nbsp;                                  final PropertyValues propertyValues) {
<b class="nc"><i class="no-highlight">831</i>&nbsp;        String dbType = getName();</b>
<b class="nc"><i class="no-highlight">832</i>&nbsp;        String[] fileFormatters;</b>
<b class="nc"><i class="no-highlight">833</i>&nbsp;        switch (dbType) {</b>
<i class="no-highlight">834</i>&nbsp;            case JdbcOperations.SNOWFLAKE:
<b class="nc"><i class="no-highlight">835</i>&nbsp;                fileFormatters = FILE_FORMAT_TYPE_SNOWFLAKE.toArray(new String[0]);</b>
<b class="nc"><i class="no-highlight">836</i>&nbsp;                suggestionBuilder.node(FILE_FORMAT_TYPE_PROP).suggestions(fileFormatters);</b>
<b class="nc"><i class="no-highlight">837</i>&nbsp;                break;</b>
<i class="no-highlight">838</i>&nbsp;            case JdbcOperations.REDSHIFT:
<b class="nc"><i class="no-highlight">839</i>&nbsp;                fileFormatters = FILE_FORMAT_TYPE_REDSHIFT.toArray(new String[0]);</b>
<i class="no-highlight">840</i>&nbsp;                suggestionBuilder.node(FILE_FORMAT_TYPE_PROP).suggestions(fileFormatters);
<i class="no-highlight">841</i>&nbsp;                break;
<i class="no-highlight">842</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:
<i class="no-highlight">843</i>&nbsp;                fileFormatters = FILE_FORMAT_TYPE_AZURE_SYNAPSE.toArray(new String[0]);
<i class="no-highlight">844</i>&nbsp;                suggestionBuilder.node(FILE_FORMAT_TYPE_PROP).suggestions(fileFormatters);
<i class="no-highlight">845</i>&nbsp;                break;
<i class="no-highlight">846</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:
<i class="no-highlight">847</i>&nbsp;                fileFormatters = FILE_FORMAT_TYPE_DLP.toArray(new String[0]);
<i class="no-highlight">848</i>&nbsp;                suggestionBuilder.node(FILE_FORMAT_TYPE_PROP).suggestions(fileFormatters);
<i class="no-highlight">849</i>&nbsp;                break;
<i class="no-highlight">850</i>&nbsp;            case JdbcOperations.BIGQUERY:
<i class="no-highlight">851</i>&nbsp;                fileFormatters = FILE_FORMAT_TYPE_BIGQUERY.toArray(new String[0]);
<b class="nc"><i class="no-highlight">852</i>&nbsp;                suggestionBuilder.node(FILE_FORMAT_TYPE_PROP).suggestions(fileFormatters);</b>
<i class="no-highlight">853</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">854</i>&nbsp;            default:</b>
<i class="no-highlight">855</i>&nbsp;                throwInvalidDbTypeException();
<i class="no-highlight">856</i>&nbsp;        }
<b class="nc"><i class="no-highlight">857</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">858</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">859</i>&nbsp;    /**</b>
<i class="no-highlight">860</i>&nbsp;     * Gets the encryption type options based on database type
<b class="nc"><i class="no-highlight">861</i>&nbsp;     *</b>
<b class="nc"><i class="no-highlight">862</i>&nbsp;     * @param suggestionBuilder is passed to the suggestion provider to help</b>
<b class="nc"><i class="no-highlight">863</i>&nbsp;     *                          with suggestion building operation.</b>
<i class="no-highlight">864</i>&nbsp;     * @param propertyValues    holds all the property values configured for a snap.
<b class="nc"><i class="no-highlight">865</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">866</i>&nbsp;    public void suggestEncryptionTypes(final SuggestionBuilder suggestionBuilder,</b>
<b class="nc"><i class="no-highlight">867</i>&nbsp;                                       final PropertyValues propertyValues) {</b>
<i class="no-highlight">868</i>&nbsp;        String dbType = getName();
<b class="nc"><i class="no-highlight">869</i>&nbsp;        String[] encryptionTypes;</b>
<b class="nc"><i class="no-highlight">870</i>&nbsp;        switch (dbType) {</b>
<b class="nc"><i class="no-highlight">871</i>&nbsp;            case JdbcOperations.SNOWFLAKE:</b>
<i class="no-highlight">872</i>&nbsp;            case JdbcOperations.REDSHIFT:
<b class="nc"><i class="no-highlight">873</i>&nbsp;                encryptionTypes = ENCRYPT_TYPES.toArray(new String[0]);</b>
<i class="no-highlight">874</i>&nbsp;                suggestionBuilder.node(ENCRYPT_TYPE_PROP).suggestions(encryptionTypes);
<i class="no-highlight">875</i>&nbsp;                break;
<i class="no-highlight">876</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:
<i class="no-highlight">877</i>&nbsp;                encryptionTypes = ENCRYPT_TYPES_AZURE_SYNAPSE.toArray(new String[0]);
<i class="no-highlight">878</i>&nbsp;                suggestionBuilder.node(ENCRYPT_TYPE_PROP).suggestions(encryptionTypes);
<i class="no-highlight">879</i>&nbsp;                break;
<i class="no-highlight">880</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:
<i class="no-highlight">881</i>&nbsp;                encryptionTypes = ENCRYPT_TYPES_DLP.toArray(new String[0]);
<i class="no-highlight">882</i>&nbsp;                suggestionBuilder.node(ENCRYPT_TYPE_PROP).suggestions(encryptionTypes);
<i class="no-highlight">883</i>&nbsp;                break;
<i class="no-highlight">884</i>&nbsp;            case JdbcOperations.BIGQUERY:
<i class="no-highlight">885</i>&nbsp;                encryptionTypes = ENCRYPT_TYPES_BIGQUERY.toArray(new String[0]);
<b class="nc"><i class="no-highlight">886</i>&nbsp;                suggestionBuilder.node(ENCRYPT_TYPE_PROP).suggestions(encryptionTypes);</b>
<i class="no-highlight">887</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">888</i>&nbsp;            default:</b>
<i class="no-highlight">889</i>&nbsp;                throwInvalidDbTypeException();
<b class="nc"><i class="no-highlight">890</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">891</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">892</i>&nbsp;</b>
<i class="no-highlight">893</i>&nbsp;    /**
<b class="nc"><i class="no-highlight">894</i>&nbsp;     * Gets the validation mode options based on database type</b>
<b class="nc"><i class="no-highlight">895</i>&nbsp;     *</b>
<b class="nc"><i class="no-highlight">896</i>&nbsp;     * @param suggestionBuilder is passed to the suggestion provider to help</b>
<i class="no-highlight">897</i>&nbsp;     *                          with suggestion building operation.
<b class="nc"><i class="no-highlight">898</i>&nbsp;     * @param propertyValues    holds all the property values configured for a snap.</b>
<b class="nc"><i class="no-highlight">899</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">900</i>&nbsp;    public void suggestValidationOptions(final SuggestionBuilder suggestionBuilder,</b>
<i class="no-highlight">901</i>&nbsp;                                         final PropertyValues propertyValues) {
<b class="nc"><i class="no-highlight">902</i>&nbsp;        String dbType = getName();</b>
<b class="nc"><i class="no-highlight">903</i>&nbsp;        String[] validationOptions;</b>
<b class="nc"><i class="no-highlight">904</i>&nbsp;        switch (dbType) {</b>
<i class="no-highlight">905</i>&nbsp;            case JdbcOperations.SNOWFLAKE:
<b class="nc"><i class="no-highlight">906</i>&nbsp;                validationOptions = VALIDATION_LIST_SNOWFLAKE.toArray(new String[0]);</b>
<b class="nc"><i class="no-highlight">907</i>&nbsp;                suggestionBuilder.node(VALIDATION_MODE_PROP).suggestions(validationOptions);</b>
<b class="nc"><i class="no-highlight">908</i>&nbsp;                break;</b>
<i class="no-highlight">909</i>&nbsp;            case JdbcOperations.REDSHIFT:
<b class="nc"><i class="no-highlight">910</i>&nbsp;                validationOptions = VALIDATION_LIST_REDSHIFT.toArray(new String[0]);</b>
<i class="no-highlight">911</i>&nbsp;                suggestionBuilder.node(VALIDATION_MODE_PROP).suggestions(validationOptions);
<i class="no-highlight">912</i>&nbsp;                break;
<i class="no-highlight">913</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:
<i class="no-highlight">914</i>&nbsp;                validationOptions = VALIDATION_LIST_AZURE_SYNAPSE.toArray(new String[0]);
<i class="no-highlight">915</i>&nbsp;                suggestionBuilder.node(VALIDATION_MODE_PROP).suggestions(validationOptions);
<b class="nc"><i class="no-highlight">916</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">917</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:</b>
<b class="nc"><i class="no-highlight">918</i>&nbsp;                validationOptions = VALIDATION_LIST_DLP.toArray(new String[0]);</b>
<b class="nc"><i class="no-highlight">919</i>&nbsp;                suggestionBuilder.node(VALIDATION_MODE_PROP).suggestions(validationOptions);</b>
<b class="nc"><i class="no-highlight">920</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">921</i>&nbsp;            case JdbcOperations.BIGQUERY:</b>
<b class="nc"><i class="no-highlight">922</i>&nbsp;                validationOptions = VALIDATION_LIST_BIGQUERY.toArray(new String[0]);</b>
<b class="nc"><i class="no-highlight">923</i>&nbsp;                suggestionBuilder.node(VALIDATION_MODE_PROP).suggestions(validationOptions);</b>
<b class="nc"><i class="no-highlight">924</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">925</i>&nbsp;            default:</b>
<b class="nc"><i class="no-highlight">926</i>&nbsp;                throwInvalidDbTypeException();</b>
<b class="nc"><i class="no-highlight">927</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">928</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">929</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">930</i>&nbsp;    @Override</b>
<b class="nc"><i class="no-highlight">931</i>&nbsp;    public void configureSnap(final PropertyValues propertyValues) {</b>
<b class="nc"><i class="no-highlight">932</i>&nbsp;        setSnapLevelSubQueryPushDownParam(DISABLE_LOAD_SUBQUERY_PUSHDOWN);</b>
<b class="nc"><i class="no-highlight">933</i>&nbsp;        super.configureSnap(propertyValues);</b>
<b class="nc"><i class="no-highlight">934</i>&nbsp;        eltDatabaseAccount = (EltDatabaseAccount) account;</b>
<b class="nc"><i class="no-highlight">935</i>&nbsp;        configureDatabaseProps(propertyValues);</b>
<b class="nc"><i class="no-highlight">936</i>&nbsp;        doDatabasePropsErrorCheck();</b>
<b class="nc"><i class="no-highlight">937</i>&nbsp;        hashDistributionColumnName = getHashDistributionColumn(propertyValues);</b>
<b class="nc"><i class="no-highlight">938</i>&nbsp;        s3Folder = EMPTY_STRING;</b>
<b class="nc"><i class="no-highlight">939</i>&nbsp;        fileFormatType = propertyValues.getAsExpression(FILE_FORMAT_TYPE_PROP).eval(null);</b>
<b class="nc"><i class="no-highlight">940</i>&nbsp;        fileFormatType = StringUtils.isBlank(fileFormatType) ? getDefaultFileFormatType() :</b>
<b class="nc"><i class="no-highlight">941</i>&nbsp;                fileFormatType;</b>
<i class="no-highlight">942</i>&nbsp;        filePattern = propertyValues.getAsExpression(FILE_PATTERN_PROP).eval(null);
<i class="no-highlight">943</i>&nbsp;        bqRedshiftSchemaName =
<b class="nc"><i class="no-highlight">944</i>&nbsp;                propertyValues.getAsExpression(BQ_REDSHIFT_SCHEMA_NAME_PROP).eval(null);</b>
<b class="nc"><i class="no-highlight">945</i>&nbsp;        bqRedshiftTableName =</b>
<b class="nc"><i class="no-highlight">946</i>&nbsp;                propertyValues.getAsExpression(BQ_REDSHIFT_TABLE_NAME_PROP).eval(null);</b>
<b class="nc"><i class="no-highlight">947</i>&nbsp;        cloudStorageLocation =</b>
<b class="nc"><i class="no-highlight">948</i>&nbsp;                propertyValues.getAsExpression(CLOUD_STORAGE_PATH_PROP).eval(null);</b>
<b class="nc"><i class="no-highlight">949</i>&nbsp;        encryptionType = propertyValues.get(ENCRYPT_TYPE_PROP);</b>
<i class="no-highlight">950</i>&nbsp;        validationMode = propertyValues.getAsExpression(VALIDATION_MODE_PROP).eval(null);
<i class="no-highlight">951</i>&nbsp;        loadAction = propertyValues.get(LOAD_ACTION_PROP);
<b class="nc"><i class="no-highlight">952</i>&nbsp;        if (StringUtils.equals(encryptionType, S3EncryptionType.SSE_KMS.toString())) {</b>
<b class="nc"><i class="no-highlight">953</i>&nbsp;            kmsKey = propertyValues.getAsExpression(KMS_KEY_PROP).eval(null);</b>
<b class="nc"><i class="no-highlight">954</i>&nbsp;            if (StringUtils.isBlank(kmsKey)) {</b>
<b class="nc"><i class="no-highlight">955</i>&nbsp;                throw new ConfigurationException(ERR_BLANK_KMS_KEY)</b>
<i class="no-highlight">956</i>&nbsp;                        .withReason(REASON_BLANK_KMS_KEY)
<b class="nc"><i class="no-highlight">957</i>&nbsp;                        .withResolution(RESOLUTION_BLANK_KMS_KEY);</b>
<i class="no-highlight">958</i>&nbsp;            }
<i class="no-highlight">959</i>&nbsp;        }
<i class="no-highlight">960</i>&nbsp;        if (StringUtils.equals(validationMode, RETURN_N_ROWS)) {
<i class="no-highlight">961</i>&nbsp;            rowsToReturn = propertyValues.getAsExpression(ROWS_TO_RETURN_PROP).eval(null);
<i class="no-highlight">962</i>&nbsp;            if (rowsToReturn == null) {
<i class="no-highlight">963</i>&nbsp;                throw new ConfigurationException(ERR_BLANK_ROWS_TO_RETURN)
<i class="no-highlight">964</i>&nbsp;                        .withReason(REASON_BLANK_ROWS_TO_RETURN)
<i class="no-highlight">965</i>&nbsp;                        .withResolution(RESOLUTION_BLANK_ROWS_TO_RETURN);
<i class="no-highlight">966</i>&nbsp;            }
<b class="nc"><i class="no-highlight">967</i>&nbsp;        }</b>
<i class="no-highlight">968</i>&nbsp;        List&lt;Map&lt;String, String&gt;&gt; fileList = propertyValues.get(FILE_LIST_PATH);
<b class="nc"><i class="no-highlight">969</i>&nbsp;        configurePropertyList(propertyValues, loadAction, fileList, FILE_PROP, filePaths);</b>
<b class="nc"><i class="no-highlight">970</i>&nbsp;        List&lt;Map&lt;String, String&gt;&gt; columnList = propertyValues.get(COLUMN_LIST_PATH);</b>
<b class="nc"><i class="no-highlight">971</i>&nbsp;        configurePropertyList(propertyValues, loadAction, columnList, TABLE_COLUMN_PROP,</b>
<b class="nc"><i class="no-highlight">972</i>&nbsp;                targetColumns);</b>
<b class="nc"><i class="no-highlight">973</i>&nbsp;        if (isDeltalakeDb()) {</b>
<i class="no-highlight">974</i>&nbsp;            // For DLP, backticks are used to escape column names with special
<i class="no-highlight">975</i>&nbsp;            // characters, especially for DDL SQL statements like CREATE TABLE
<b class="nc"><i class="no-highlight">976</i>&nbsp;            // and DMLs like COPY INTO but SELECT or DESCRIBE TABLE SQL statement</b>
<b class="nc"><i class="no-highlight">977</i>&nbsp;            // results show column names without backticks. Thus,</b>
<i class="no-highlight">978</i>&nbsp;            // if there is a column name which is wrapped with backticks,
<b class="nc"><i class="no-highlight">979</i>&nbsp;            // &quot;isThereBacktickWrappedElementAtTargetColumns&quot; is set true.</b>
<i class="no-highlight">980</i>&nbsp;            // Also remove wrapping backticks from &quot;targetColumns&quot; and
<i class="no-highlight">981</i>&nbsp;            // build &quot;targetColumnsWithBacktick&quot; to be used
<b class="nc"><i class="no-highlight">982</i>&nbsp;            // to build CREATE TABLE and COPY INTO SQL statements.</b>
<b class="nc"><i class="no-highlight">983</i>&nbsp;            trimListEntries(targetColumns);</b>
<i class="no-highlight">984</i>&nbsp;            // make a copy to make the logic easier.
<b class="nc"><i class="no-highlight">985</i>&nbsp;            targetColumnsWithBacktick.addAll(targetColumns);</b>
<i class="no-highlight">986</i>&nbsp;            isThereBacktickWrappedElementAtTargetColumns =
<b class="nc"><i class="no-highlight">987</i>&nbsp;                    isThereEntryWithWrappingChar(targetColumns, BACK_TICK_CHAR);</b>
<i class="no-highlight">988</i>&nbsp;            if (isThereBacktickWrappedElementAtTargetColumns) {
<i class="no-highlight">989</i>&nbsp;                removeWrappingCharForColumnNamesIfExist(targetColumns, BACK_TICK_CHAR);
<i class="no-highlight">990</i>&nbsp;            }
<b class="nc"><i class="no-highlight">991</i>&nbsp;        }</b>
<i class="no-highlight">992</i>&nbsp;        validateFileListPattern();
<b class="nc"><i class="no-highlight">993</i>&nbsp;        configurePropertyList(propertyValues, loadAction, columnList, DATA_TYPE_PROP,</b>
<i class="no-highlight">994</i>&nbsp;                targetDataTypes);
<i class="no-highlight">995</i>&nbsp;        configurePropertyList(propertyValues, loadAction, columnList, ALTER_COLUMN_PROP,
<b class="nc"><i class="no-highlight">996</i>&nbsp;                alterColumnModifiers);</b>
<i class="no-highlight">997</i>&nbsp;
<b class="nc"><i class="no-highlight">998</i>&nbsp;        if (alterColumnModifiers.contains(DROP)) {</b>
<b class="nc"><i class="no-highlight">999</i>&nbsp;            isColumnToBeDropped = true;</b>
<b class="nc"><i class="no-highlight">1000</i>&nbsp;        }</b>
<i class="no-highlight">1001</i>&nbsp;        List&lt;Map&lt;String, String&gt;&gt; tableOptionList = propertyValues.get(
<b class="nc"><i class="no-highlight">1002</i>&nbsp;                TABLE_OPTION_LIST_PATH);</b>
<b class="nc"><i class="no-highlight">1003</i>&nbsp;        configurePropertyList(propertyValues, loadAction,</b>
<i class="no-highlight">1004</i>&nbsp;                tableOptionList, TABLE_OPTION_PROP,
<b class="nc"><i class="no-highlight">1005</i>&nbsp;                tableOptions);</b>
<b class="nc"><i class="no-highlight">1006</i>&nbsp;</b>
<i class="no-highlight">1007</i>&nbsp;        List&lt;Map&lt;String, String&gt;&gt; fileFormatOptionList = propertyValues.get(
<b class="nc"><i class="no-highlight">1008</i>&nbsp;                FILE_FORMAT_OPTION_LIST_PATH);</b>
<i class="no-highlight">1009</i>&nbsp;        configurePropertyList(propertyValues, loadAction,
<b class="nc"><i class="no-highlight">1010</i>&nbsp;                fileFormatOptionList, FILE_FORMAT_OPTION_PROP,</b>
<b class="nc"><i class="no-highlight">1011</i>&nbsp;                fileFormatOptions);</b>
<b class="nc"><i class="no-highlight">1012</i>&nbsp;        validateTableOptions(tableOptions);</b>
<i class="no-highlight">1013</i>&nbsp;
<b class="nc"><i class="no-highlight">1014</i>&nbsp;        if (isDeltalakeDb()) {</b>
<b class="nc"><i class="no-highlight">1015</i>&nbsp;            isFileFormatOptionHeaderTrue =</b>
<i class="no-highlight">1016</i>&nbsp;                    isHeaderFileFormatOptionTrueDLP(propertyValues, fileFormatOptionList);
<b class="nc"><i class="no-highlight">1017</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1018</i>&nbsp;        List&lt;Map&lt;String, String&gt;&gt; copyOptionList = propertyValues.get(COPY_OPTION_LIST_PATH);</b>
<b class="nc"><i class="no-highlight">1019</i>&nbsp;        configurePropertyList(propertyValues, loadAction, copyOptionList,</b>
<b class="nc"><i class="no-highlight">1020</i>&nbsp;                COPY_OPTION_PROP, copyOptions);</b>
<b class="nc"><i class="no-highlight">1021</i>&nbsp;        if (isDeltalakeDb()) {</b>
<b class="nc"><i class="no-highlight">1022</i>&nbsp;            targetTablePath = tableNameWithDbName;</b>
<i class="no-highlight">1023</i>&nbsp;        } else {
<i class="no-highlight">1024</i>&nbsp;            targetTablePath = tableNameWithDbAndSchemaNames;
<b class="nc"><i class="no-highlight">1025</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1026</i>&nbsp;        validateCopyFromFilesConfig();</b>
<b class="nc"><i class="no-highlight">1027</i>&nbsp;        fileFormatType = StringUtils.trim(fileFormatType);</b>
<i class="no-highlight">1028</i>&nbsp;        filePattern = StringUtils.trim(filePattern);
<b class="nc"><i class="no-highlight">1029</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1030</i>&nbsp;        enableSourceColumnPosition =</b>
<b class="nc"><i class="no-highlight">1031</i>&nbsp;                Boolean.TRUE.equals(propertyValues.get(ENABLE_SOURCE_COLUMN_POSITION_PROP));</b>
<b class="nc"><i class="no-highlight">1032</i>&nbsp;</b>
<i class="no-highlight">1033</i>&nbsp;        columnMappingMap = buildColumnMappingMap(propertyValues);
<b class="nc"><i class="no-highlight">1034</i>&nbsp;        setNeedTransformationPreactionForSnowflake();</b>
<b class="nc"><i class="no-highlight">1035</i>&nbsp;        if (isSnowflakeDb()) {</b>
<i class="no-highlight">1036</i>&nbsp;            if (needTransformationPreaction &amp;&amp; isSemiStructuredFileTypeSnowflake()) {
<b class="nc"><i class="no-highlight">1037</i>&nbsp;                // For this case, we perform two step transformations: first,</b>
<b class="nc"><i class="no-highlight">1038</i>&nbsp;                // create and load a semi-structured data file into a new staged table</b>
<i class="no-highlight">1039</i>&nbsp;                // with one VARIANT column, second insert select with transformations.
<b class="nc"><i class="no-highlight">1040</i>&nbsp;                isSnowflakeTransformPreprocessingRequired = true;</b>
<i class="no-highlight">1041</i>&nbsp;            }
<i class="no-highlight">1042</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1043</i>&nbsp;        if (isAzureSynapseDb() || isSnowflakeDb() &amp;&amp; !isSnowflakeTransformPreprocessingRequired) {</b>
<i class="no-highlight">1044</i>&nbsp;            if (MapUtils.isNotEmpty(columnMappingMap) &amp;&amp; enableSourceColumnPosition == false) {
<b class="nc"><i class="no-highlight">1045</i>&nbsp;                throw new ConfigurationException(ERR_UNSUPPORTED_COLUMN_MAP_OPTIONS)</b>
<b class="nc"><i class="no-highlight">1046</i>&nbsp;                        .withReason(REASON_UNSUPPORTED_COLUMN_MAP_OPTIONS)</b>
<i class="no-highlight">1047</i>&nbsp;                        .withResolution(RESOLUTION_UNSUPPORTED_COLUMN_MAP_OPTIONS);
<i class="no-highlight">1048</i>&nbsp;            }
<i class="no-highlight">1049</i>&nbsp;        }
<i class="no-highlight">1050</i>&nbsp;        if (isSnowflakeDb() &amp;&amp; isSnowflakeTransformPreprocessingRequired) {
<i class="no-highlight">1051</i>&nbsp;            // Make sure source column names are used for column mapping if JSON or PARQUET
<b class="nc"><i class="no-highlight">1052</i>&nbsp;            // file is used.</b>
<b class="nc"><i class="no-highlight">1053</i>&nbsp;            if (MapUtils.isNotEmpty(columnMappingMap) &amp;&amp; enableSourceColumnPosition == true) {</b>
<i class="no-highlight">1054</i>&nbsp;                throw new ConfigurationException(ERR_UNSUPPORTED_COLUMN_MAP_OPTIONS)
<b class="nc"><i class="no-highlight">1055</i>&nbsp;                        .withReason(REASON_UNSUPPORTED_COLUMN_MAP_OPTION_COLUMN_POSITION)</b>
<b class="nc"><i class="no-highlight">1056</i>&nbsp;                        .withResolution(RESOLUTION_UNSUPPORTED_COLUMN_MAP_OPTION_COLUMN_POSITION);</b>
<i class="no-highlight">1057</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1058</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1059</i>&nbsp;        if (isDeltalakeDb()) {</b>
<i class="no-highlight">1060</i>&nbsp;            if (StringUtils.equalsIgnoreCase(fileFormatType, CSV) &amp;&amp;
<b class="nc"><i class="no-highlight">1061</i>&nbsp;                    !isSepHeaderFileFormatOptionCommaOrDefaultDLP(</b>
<i class="no-highlight">1062</i>&nbsp;                            propertyValues, fileFormatOptionList) &amp;&amp;
<b class="nc"><i class="no-highlight">1063</i>&nbsp;                    MapUtils.isEmpty(columnMappingMap)) {</b>
<b class="nc"><i class="no-highlight">1064</i>&nbsp;                throw new ConfigurationException(ERR_UNSUPPORTED_SEP_FILE_FORMAT_OPTION)</b>
<b class="nc"><i class="no-highlight">1065</i>&nbsp;                        .withReason(REASON_UNSUPPORTED_SEP_FILE_FORMAT_OPTION)</b>
<i class="no-highlight">1066</i>&nbsp;                        .withResolution(RESOLUTION_UNSUPPORTED_SEP_FILE_FORMAT_OPTION);
<b class="nc"><i class="no-highlight">1067</i>&nbsp;            }</b>
<i class="no-highlight">1068</i>&nbsp;            isFileFormatOptionHeaderTrue =
<b class="nc"><i class="no-highlight">1069</i>&nbsp;                    isHeaderFileFormatOptionTrueDLP(propertyValues, fileFormatOptionList);</b>
<i class="no-highlight">1070</i>&nbsp;        }
<i class="no-highlight">1071</i>&nbsp;        if (isDeltalakeDb()) {
<i class="no-highlight">1072</i>&nbsp;            this.targetTableName = tableNameWithDbName;
<i class="no-highlight">1073</i>&nbsp;        } else {
<i class="no-highlight">1074</i>&nbsp;            this.targetTableName = tableNameWithDbAndSchemaNames;
<b class="nc"><i class="no-highlight">1075</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1076</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1077</i>&nbsp;        getFileFormatOptions(propertyValues, fileFormatOptionList);</b>
<i class="no-highlight">1078</i>&nbsp;
<i class="no-highlight">1079</i>&nbsp;        if (inferSchemaEnabled) {
<b class="nc"><i class="no-highlight">1080</i>&nbsp;            filesForSchemaInference = new ArrayList&lt;&gt;();</b>
<i class="no-highlight">1081</i>&nbsp;        }
<i class="no-highlight">1082</i>&nbsp;    }
<i class="no-highlight">1083</i>&nbsp;
<i class="no-highlight">1084</i>&nbsp;    private void getFileFormatOptions(final PropertyValues propertyValues,
<b class="nc"><i class="no-highlight">1085</i>&nbsp;                                      List&lt;Map&lt;String, String&gt;&gt; fileFormatOptionList) {</b>
<b class="nc"><i class="no-highlight">1086</i>&nbsp;        String dbType = getName();</b>
<i class="no-highlight">1087</i>&nbsp;        switch (dbType) {
<i class="no-highlight">1088</i>&nbsp;            case JdbcOperations.SNOWFLAKE:
<i class="no-highlight">1089</i>&nbsp;                getFileFormatOptionsSnowflake(propertyValues, fileFormatOptionList);
<i class="no-highlight">1090</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">1091</i>&nbsp;            case JdbcOperations.REDSHIFT:</b>
<b class="nc"><i class="no-highlight">1092</i>&nbsp;                getFileFormatOptionsRedshift(propertyValues, fileFormatOptionList);</b>
<i class="no-highlight">1093</i>&nbsp;                break;
<i class="no-highlight">1094</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:
<b class="nc"><i class="no-highlight">1095</i>&nbsp;                break;</b>
<i class="no-highlight">1096</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:
<i class="no-highlight">1097</i>&nbsp;                inferSchemaEnabled =
<i class="no-highlight">1098</i>&nbsp;                        isInferSchemaEnabledForDLP(propertyValues, fileFormatOptionList);
<i class="no-highlight">1099</i>&nbsp;                break;
<i class="no-highlight">1100</i>&nbsp;            case JdbcOperations.BIGQUERY:
<i class="no-highlight">1101</i>&nbsp;                break;
<i class="no-highlight">1102</i>&nbsp;            default:
<i class="no-highlight">1103</i>&nbsp;                throwInvalidDbTypeException();
<i class="no-highlight">1104</i>&nbsp;        }
<i class="no-highlight">1105</i>&nbsp;    }
<i class="no-highlight">1106</i>&nbsp;
<i class="no-highlight">1107</i>&nbsp;    private boolean isThereEntryWithWrappingChar(
<i class="no-highlight">1108</i>&nbsp;            final List&lt;String&gt; stringList, final char wchar) {
<i class="no-highlight">1109</i>&nbsp;        for (int i = 0; i &lt; stringList.size(); i++) {
<i class="no-highlight">1110</i>&nbsp;            if (isWrappedByChar(stringList.get(i), wchar)) {
<i class="no-highlight">1111</i>&nbsp;                return true;
<i class="no-highlight">1112</i>&nbsp;            }
<i class="no-highlight">1113</i>&nbsp;        }
<i class="no-highlight">1114</i>&nbsp;        return false;
<i class="no-highlight">1115</i>&nbsp;    }
<i class="no-highlight">1116</i>&nbsp;
<i class="no-highlight">1117</i>&nbsp;    private boolean isSemiStructuredFileTypeSnowflake() {
<i class="no-highlight">1118</i>&nbsp;        return StringUtils.equals(PARQUET, fileFormatType) ||
<i class="no-highlight">1119</i>&nbsp;                StringUtils.equals(JSON, fileFormatType);
<b class="nc"><i class="no-highlight">1120</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">1121</i>&nbsp;</b>
<i class="no-highlight">1122</i>&nbsp;    private void removeWrappingCharForColumnNamesIfExist(
<i class="no-highlight">1123</i>&nbsp;            List&lt;String&gt; columnNameList, final char wchar) {
<i class="no-highlight">1124</i>&nbsp;        for (int i = 0; i &lt; columnNameList.size(); i++) {
<b class="nc"><i class="no-highlight">1125</i>&nbsp;            columnNameList.set(i, unwrapCharFromColumnName(columnNameList.get(i), wchar));</b>
<b class="nc"><i class="no-highlight">1126</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1127</i>&nbsp;    }</b>
<i class="no-highlight">1128</i>&nbsp;
<i class="no-highlight">1129</i>&nbsp;    private boolean isWrappedByChar(final String str, final char wchar) {
<i class="no-highlight">1130</i>&nbsp;        if (StringUtils.isEmpty(str) || str.length() &lt; 2) {
<i class="no-highlight">1131</i>&nbsp;            return false;
<i class="no-highlight">1132</i>&nbsp;        }
<i class="no-highlight">1133</i>&nbsp;        
<i class="no-highlight">1134</i>&nbsp;        return str.charAt(0) == wchar &amp;&amp; str.charAt(str.length() - 1) == wchar;
<i class="no-highlight">1135</i>&nbsp;    }
<i class="no-highlight">1136</i>&nbsp;
<i class="no-highlight">1137</i>&nbsp;    /**
<i class="no-highlight">1138</i>&nbsp;     * Unwraps the given &#39;wchar&#39; from the the given &quot;columnName&quot;
<i class="no-highlight">1139</i>&nbsp;     * in the following manner.
<i class="no-highlight">1140</i>&nbsp;     *
<i class="no-highlight">1141</i>&nbsp;     * 1. This strips wchar at the start and at the end only one time.
<i class="no-highlight">1142</i>&nbsp;     * I.e., given &quot;```col1`&quot; as columnName and &#39;`&#39; as wchar, this function
<b class="nc"><i class="no-highlight">1143</i>&nbsp;     * returns &quot;``col1&quot; after removing wchar only one time at the start and at the end.</b>
<b class="nc"><i class="no-highlight">1144</i>&nbsp;     *</b>
<i class="no-highlight">1145</i>&nbsp;     * 2. This function does not strip wchar if the given &quot;columnName&quot;
<b class="nc"><i class="no-highlight">1146</i>&nbsp;     * does not have wchar both at the start and at the end.</b>
<b class="nc"><i class="no-highlight">1147</i>&nbsp;     * For example, given &quot;`col1&quot; or &quot;col1`&quot; as columnName with &#39;`&#39; as wchar,</b>
<i class="no-highlight">1148</i>&nbsp;     * this function does not strip wchar but returns &quot;columnName&quot; without modification.
<b class="nc"><i class="no-highlight">1149</i>&nbsp;     *</b>
<b class="nc"><i class="no-highlight">1150</i>&nbsp;     * 3. Given &quot;```col1&quot; as columnName and &#39;`&#39; as wchar, this returns &quot;`col&quot;.</b>
<i class="no-highlight">1151</i>&nbsp;     *    I.e., if unwrapped columnName has two&#39;s multiple number of wchar at the start or
<i class="no-highlight">1152</i>&nbsp;     *    at the end, strip wchar&#39;s by half of the number at the start and at the end so
<b class="nc"><i class="no-highlight">1153</i>&nbsp;     *    that the column name is accepted by the DLP.</b>
<b class="nc"><i class="no-highlight">1154</i>&nbsp;     * @param columnName</b>
<b class="nc"><i class="no-highlight">1155</i>&nbsp;     * @param wchar</b>
<b class="nc"><i class="no-highlight">1156</i>&nbsp;     * @return</b>
<i class="no-highlight">1157</i>&nbsp;     */
<b class="nc"><i class="no-highlight">1158</i>&nbsp;    private String unwrapCharFromColumnName(String columnName, final char wchar) {</b>
<b class="nc"><i class="no-highlight">1159</i>&nbsp;        if (StringUtils.isEmpty(columnName) || columnName.length() &lt; 2) {</b>
<i class="no-highlight">1160</i>&nbsp;            return columnName;
<i class="no-highlight">1161</i>&nbsp;        }
<i class="no-highlight">1162</i>&nbsp;
<b class="nc"><i class="no-highlight">1163</i>&nbsp;        // This conditional becomes true only when both sides has the given wchar.</b>
<i class="no-highlight">1164</i>&nbsp;        if (columnName.charAt(0) == wchar &amp;&amp; columnName.charAt(columnName.length() - 1) == wchar) {
<i class="no-highlight">1165</i>&nbsp;            int start = 1;
<b class="nc"><i class="no-highlight">1166</i>&nbsp;            int end = columnName.length() - 1;</b>
<i class="no-highlight">1167</i>&nbsp;
<i class="no-highlight">1168</i>&nbsp;            // If in DLP and the given wchar is back tick (escape char
<i class="no-highlight">1169</i>&nbsp;            // for DLP column names), reduce number of the backticks on both sides
<b class="nc"><i class="no-highlight">1170</i>&nbsp;            // (if the number % 2 is 0) by half from columnName.substring(1,</b>
<i class="no-highlight">1171</i>&nbsp;            // columnName.length() - 1)
<b class="nc"><i class="no-highlight">1172</i>&nbsp;            // so that the result can be used to check the output</b>
<b class="nc"><i class="no-highlight">1173</i>&nbsp;            // of DESCRIBE TABLE.</b>
<i class="no-highlight">1174</i>&nbsp;            // E.g., given &quot;```col1`&quot; -&gt; we get &quot;`col1&quot; this as result of this function.
<i class="no-highlight">1175</i>&nbsp;            // Note that &quot;```col1`&quot; is used for load action SQL, and
<b class="nc"><i class="no-highlight">1176</i>&nbsp;            // &quot;`col1&quot; is used for comparing the output of DESCRIBE TABLE since</b>
<i class="no-highlight">1177</i>&nbsp;            // DESCRIBE TABLE returns &quot;`col1&quot;.
<b class="nc"><i class="no-highlight">1178</i>&nbsp;            //</b>
<b class="nc"><i class="no-highlight">1179</i>&nbsp;            // Also note that if &quot;``col1`&quot; is given, this fuction returns &quot;`col1&quot;.</b>
<i class="no-highlight">1180</i>&nbsp;            // But &quot;``col1`&quot; will cause load action SQL to fail since number of backticks
<i class="no-highlight">1181</i>&nbsp;            // inside a pair of backticks is an odd number.
<b class="nc"><i class="no-highlight">1182</i>&nbsp;            if (isDeltalakeDb() &amp;&amp; wchar == BACK_TICK_CHAR) {</b>
<i class="no-highlight">1183</i>&nbsp;                int cursor = start;
<i class="no-highlight">1184</i>&nbsp;
<i class="no-highlight">1185</i>&nbsp;                while (cursor &lt; end &amp;&amp; columnName.charAt(cursor) == wchar) {
<b class="nc"><i class="no-highlight">1186</i>&nbsp;                    cursor++;</b>
<b class="nc"><i class="no-highlight">1187</i>&nbsp;                }</b>
<i class="no-highlight">1188</i>&nbsp;                if (cursor &gt; start &amp;&amp; (cursor - start) % 2 == 0) {
<b class="nc"><i class="no-highlight">1189</i>&nbsp;                    start += (cursor - start) / 2;</b>
<i class="no-highlight">1190</i>&nbsp;                }
<i class="no-highlight">1191</i>&nbsp;
<i class="no-highlight">1192</i>&nbsp;                int endIndex = end - 1;
<i class="no-highlight">1193</i>&nbsp;                cursor = endIndex;
<i class="no-highlight">1194</i>&nbsp;                while (cursor &gt; start &amp;&amp; columnName.charAt(cursor) == wchar) {
<i class="no-highlight">1195</i>&nbsp;                    cursor--;
<b class="nc"><i class="no-highlight">1196</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">1197</i>&nbsp;                if (cursor &lt; endIndex &amp;&amp; (endIndex - cursor) % 2 == 0) {</b>
<b class="nc"><i class="no-highlight">1198</i>&nbsp;                    end -= (endIndex - cursor) / 2;</b>
<b class="nc"><i class="no-highlight">1199</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">1200</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">1201</i>&nbsp;</b>
<i class="no-highlight">1202</i>&nbsp;            return columnName.substring(start, end);
<i class="no-highlight">1203</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1204</i>&nbsp;</b>
<i class="no-highlight">1205</i>&nbsp;        return columnName;
<b class="nc"><i class="no-highlight">1206</i>&nbsp;    }</b>
<i class="no-highlight">1207</i>&nbsp;
<i class="no-highlight">1208</i>&nbsp;    private String wrapWithCharIfNotYet(final String str, final char wchar) {
<i class="no-highlight">1209</i>&nbsp;        StringBuilder sb = new StringBuilder();
<i class="no-highlight">1210</i>&nbsp;
<i class="no-highlight">1211</i>&nbsp;        if (StringUtils.isBlank(str) || str.charAt(0) != wchar) {
<i class="no-highlight">1212</i>&nbsp;            sb.append(wchar);
<i class="no-highlight">1213</i>&nbsp;        }
<i class="no-highlight">1214</i>&nbsp;
<i class="no-highlight">1215</i>&nbsp;        sb.append(str);
<i class="no-highlight">1216</i>&nbsp;
<b class="nc"><i class="no-highlight">1217</i>&nbsp;        if (StringUtils.isBlank(str) || str.charAt(str.length() - 1) != wchar) {</b>
<b class="nc"><i class="no-highlight">1218</i>&nbsp;            sb.append(wchar);</b>
<b class="nc"><i class="no-highlight">1219</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1220</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1221</i>&nbsp;        return sb.toString();</b>
<b class="nc"><i class="no-highlight">1222</i>&nbsp;    }</b>
<i class="no-highlight">1223</i>&nbsp;
<i class="no-highlight">1224</i>&nbsp;    private String getDefaultFileFormatType() {
<b class="nc"><i class="no-highlight">1225</i>&nbsp;        if (isAzureSynapseDb()) {</b>
<i class="no-highlight">1226</i>&nbsp;            return CSV;
<b class="nc"><i class="no-highlight">1227</i>&nbsp;        } else {</b>
<i class="no-highlight">1228</i>&nbsp;            return NONE;
<i class="no-highlight">1229</i>&nbsp;        }
<i class="no-highlight">1230</i>&nbsp;    }
<i class="no-highlight">1231</i>&nbsp;
<i class="no-highlight">1232</i>&nbsp;    private boolean isHeaderFileFormatOptionTrueDLP(
<b class="nc"><i class="no-highlight">1233</i>&nbsp;            final PropertyValues propertyValues,</b>
<b class="nc"><i class="no-highlight">1234</i>&nbsp;            final List&lt;Map&lt;String, String&gt;&gt; fileFormatOptionList) {</b>
<b class="nc"><i class="no-highlight">1235</i>&nbsp;        if (CollectionUtils.isNotEmpty(fileFormatOptionList)) {</b>
<b class="nc"><i class="no-highlight">1236</i>&nbsp;            for (Map&lt;String, String&gt; item : fileFormatOptionList) {</b>
<i class="no-highlight">1237</i>&nbsp;                String path = propertyValues.getExpressionPropertyFor(item,
<b class="nc"><i class="no-highlight">1238</i>&nbsp;                        FILE_FORMAT_OPTION_PROP).eval(null);</b>
<b class="nc"><i class="no-highlight">1239</i>&nbsp;                if (StringUtils.containsIgnoreCase(path, DLP_FILE_FORMAT_OPTION_HEADER)) {</b>
<i class="no-highlight">1240</i>&nbsp;                    return StringUtils.containsIgnoreCase(
<b class="nc"><i class="no-highlight">1241</i>&nbsp;                            path, DLP_FILE_FORMAT_OPTION_HEADER_TRUE);</b>
<i class="no-highlight">1242</i>&nbsp;                }
<b class="nc"><i class="no-highlight">1243</i>&nbsp;            }</b>
<i class="no-highlight">1244</i>&nbsp;        }
<i class="no-highlight">1245</i>&nbsp;        return false;
<i class="no-highlight">1246</i>&nbsp;    }
<i class="no-highlight">1247</i>&nbsp;
<i class="no-highlight">1248</i>&nbsp;    /**
<b class="nc"><i class="no-highlight">1249</i>&nbsp;     * Returns true if comma (default) separator is specified or</b>
<b class="nc"><i class="no-highlight">1250</i>&nbsp;     * &#39;sep&#39; option is not specified in File Format Option List.</b>
<b class="nc"><i class="no-highlight">1251</i>&nbsp;     * Returns false only if non-comma separator is specivied.</b>
<b class="nc"><i class="no-highlight">1252</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">1253</i>&nbsp;    private boolean isSepHeaderFileFormatOptionCommaOrDefaultDLP(</b>
<b class="nc"><i class="no-highlight">1254</i>&nbsp;            final PropertyValues propertyValues,</b>
<b class="nc"><i class="no-highlight">1255</i>&nbsp;            final List&lt;Map&lt;String, String&gt;&gt; fileFormatOptionList) {</b>
<i class="no-highlight">1256</i>&nbsp;        if (CollectionUtils.isNotEmpty(fileFormatOptionList)) {
<b class="nc"><i class="no-highlight">1257</i>&nbsp;            for (Map&lt;String, String&gt; item : fileFormatOptionList) {</b>
<b class="nc"><i class="no-highlight">1258</i>&nbsp;                String path = propertyValues.getExpressionPropertyFor(item,</b>
<i class="no-highlight">1259</i>&nbsp;                        FILE_FORMAT_OPTION_PROP).eval(null);
<b class="nc"><i class="no-highlight">1260</i>&nbsp;                if (StringUtils.containsIgnoreCase(path, DLP_FILE_FORMAT_OPTION_SEP)) {</b>
<b class="nc"><i class="no-highlight">1261</i>&nbsp;                    return StringUtils.containsIgnoreCase(</b>
<i class="no-highlight">1262</i>&nbsp;                            path, DLP_FILE_FORMAT_OPTION_SEP_COMMA);
<b class="nc"><i class="no-highlight">1263</i>&nbsp;                }</b>
<i class="no-highlight">1264</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1265</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1266</i>&nbsp;        return true;</b>
<i class="no-highlight">1267</i>&nbsp;    }
<b class="nc"><i class="no-highlight">1268</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1269</i>&nbsp;    private boolean isInferSchemaEnabledForDLP(</b>
<i class="no-highlight">1270</i>&nbsp;            final PropertyValues propertyValues,
<b class="nc"><i class="no-highlight">1271</i>&nbsp;            final List&lt;Map&lt;String, String&gt;&gt; fileFormatOptionList) {</b>
<b class="nc"><i class="no-highlight">1272</i>&nbsp;        if (CollectionUtils.isNotEmpty(fileFormatOptionList)) {</b>
<i class="no-highlight">1273</i>&nbsp;            for (Map&lt;String, String&gt; item : fileFormatOptionList) {
<b class="nc"><i class="no-highlight">1274</i>&nbsp;                String path = propertyValues.getExpressionPropertyFor(item,</b>
<b class="nc"><i class="no-highlight">1275</i>&nbsp;                        FILE_FORMAT_OPTION_PROP).eval(null);</b>
<i class="no-highlight">1276</i>&nbsp;
<b class="nc"><i class="no-highlight">1277</i>&nbsp;                if (StringUtils.containsIgnoreCase(path, &quot;inferSchema&quot;)) {</b>
<b class="nc"><i class="no-highlight">1278</i>&nbsp;                    return EltUtils.grepBooleanValueFileFormatOption(path);</b>
<i class="no-highlight">1279</i>&nbsp;                }
<b class="nc"><i class="no-highlight">1280</i>&nbsp;            }</b>
<i class="no-highlight">1281</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1282</i>&nbsp;        return false;</b>
<b class="nc"><i class="no-highlight">1283</i>&nbsp;    }</b>
<i class="no-highlight">1284</i>&nbsp;
<b class="nc"><i class="no-highlight">1285</i>&nbsp;    private void getFileFormatOptionsRedshift(</b>
<b class="nc"><i class="no-highlight">1286</i>&nbsp;            final PropertyValues propertyValues,</b>
<i class="no-highlight">1287</i>&nbsp;            final List&lt;Map&lt;String, String&gt;&gt; fileFormatOptionList) {
<b class="nc"><i class="no-highlight">1288</i>&nbsp;        if (CollectionUtils.isNotEmpty(fileFormatOptionList)) {</b>
<b class="nc"><i class="no-highlight">1289</i>&nbsp;            ListIterator&lt;Map&lt;String, String&gt;&gt; itr = fileFormatOptionList.listIterator();</b>
<i class="no-highlight">1290</i>&nbsp;            while (itr.hasNext()) {
<b class="nc"><i class="no-highlight">1291</i>&nbsp;                Map&lt;String, String&gt; item = itr.next();</b>
<b class="nc"><i class="no-highlight">1292</i>&nbsp;                String path = propertyValues.getExpressionPropertyFor(item,</b>
<i class="no-highlight">1293</i>&nbsp;                        FILE_FORMAT_OPTION_PROP).eval(null);
<b class="nc"><i class="no-highlight">1294</i>&nbsp;                if (StringUtils.containsIgnoreCase(path,</b>
<b class="nc"><i class="no-highlight">1295</i>&nbsp;                        REDSHIFT_FF_OPTION_DELIMITER)) {</b>
<b class="nc"><i class="no-highlight">1296</i>&nbsp;                    fieldDelimiter = EltUtils.grepCharValueFileFormatOption(path);</b>
<i class="no-highlight">1297</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,
<i class="no-highlight">1298</i>&nbsp;                        REDSHIFT_FF_OPTION_IGNOREHEADER)) {
<b class="nc"><i class="no-highlight">1299</i>&nbsp;                    ignoreHeader =</b>
<i class="no-highlight">1300</i>&nbsp;                            EltUtils.grepIntegerValueFileFormatOption(path,
<i class="no-highlight">1301</i>&nbsp;                                    REDSHIFT_FF_OPTION_IGNOREHEADER, AS_STRING);
<b class="nc"><i class="no-highlight">1302</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,</b>
<b class="nc"><i class="no-highlight">1303</i>&nbsp;                        REDSHIFT_FF_OPTION_QUOTE)) {</b>
<b class="nc"><i class="no-highlight">1304</i>&nbsp;                    quoteChar = EltUtils.grepCharValueFileFormatOption(path);</b>
<i class="no-highlight">1305</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,
<i class="no-highlight">1306</i>&nbsp;                        REDSHIFT_FF_OPTION_DATEFORMAT)) {
<i class="no-highlight">1307</i>&nbsp;                    dateFormat = EltUtils.grepStringValueFileFormatOption(path);
<i class="no-highlight">1308</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,
<b class="nc"><i class="no-highlight">1309</i>&nbsp;                        REDSHIFT_FF_OPTION_NULL)) {</b>
<i class="no-highlight">1310</i>&nbsp;                    nullAsStr = EltUtils.grepStringValueFileFormatOption(path);
<i class="no-highlight">1311</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,
<i class="no-highlight">1312</i>&nbsp;                        REDSHIFT_FF_OPTION_TIMEFORMAT)) {
<i class="no-highlight">1313</i>&nbsp;                    timeFormat = EltUtils.grepStringValueFileFormatOption(path);
<b class="nc"><i class="no-highlight">1314</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,</b>
<b class="nc"><i class="no-highlight">1315</i>&nbsp;                        INFER_SCHEMA_OPTION_NAME)) {</b>
<b class="nc"><i class="no-highlight">1316</i>&nbsp;                    inferSchemaEnabled = EltUtils.grepBooleanValueFileFormatOption(path);</b>
<i class="no-highlight">1317</i>&nbsp;                    fileFormatOptions.removeIf(o -&gt; StringUtils.containsIgnoreCase(o,
<b class="nc"><i class="no-highlight">1318</i>&nbsp;                            INFER_SCHEMA_OPTION_NAME));</b>
<b class="nc"><i class="no-highlight">1319</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,</b>
<i class="no-highlight">1320</i>&nbsp;                        REDSHIFT_COMPRESSION_GZIP)) {
<i class="no-highlight">1321</i>&nbsp;                    compressionType = REDSHIFT_COMPRESSION_GZIP;
<i class="no-highlight">1322</i>&nbsp;                }  else if (StringUtils.containsIgnoreCase(path,
<i class="no-highlight">1323</i>&nbsp;                        REDSHIFT_COMPRESSION_LZOP)) {
<i class="no-highlight">1324</i>&nbsp;                    compressionType = REDSHIFT_COMPRESSION_LZOP;
<i class="no-highlight">1325</i>&nbsp;                }  else if (StringUtils.containsIgnoreCase(path,
<i class="no-highlight">1326</i>&nbsp;                        REDSHIFT_COMPRESSION_BZIP2)) {
<i class="no-highlight">1327</i>&nbsp;                    compressionType = REDSHIFT_COMPRESSION_BZIP2;
<i class="no-highlight">1328</i>&nbsp;                }  else if (StringUtils.containsIgnoreCase(path,
<b class="nc"><i class="no-highlight">1329</i>&nbsp;                        REDSHIFT_COMPRESSION_ZSTD)) {</b>
<b class="nc"><i class="no-highlight">1330</i>&nbsp;                    compressionType = REDSHIFT_COMPRESSION_ZSTD;</b>
<b class="nc"><i class="no-highlight">1331</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,</b>
<b class="nc"><i class="no-highlight">1332</i>&nbsp;                        JSON)) {</b>
<b class="nc"><i class="no-highlight">1333</i>&nbsp;                    if (StringUtils.startsWith(</b>
<b class="nc"><i class="no-highlight">1334</i>&nbsp;                            EltUtils.grepStringValueFileFormatOption(path), &quot;s3://&quot;)) {</b>
<b class="nc"><i class="no-highlight">1335</i>&nbsp;                        isJsonPathsOptionGivenForJson = true;</b>
<b class="nc"><i class="no-highlight">1336</i>&nbsp;                    }</b>
<b class="nc"><i class="no-highlight">1337</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">1338</i>&nbsp;            }</b>
<i class="no-highlight">1339</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1340</i>&nbsp;        // Assign default value if fieldDelimiter is not set above.</b>
<i class="no-highlight">1341</i>&nbsp;        if (fieldDelimiter == Character.MIN_VALUE) {
<i class="no-highlight">1342</i>&nbsp;            fieldDelimiter =
<i class="no-highlight">1343</i>&nbsp;                    StringUtils.equals(fileFormatType, CSV) ? COMMA : PIPE;
<i class="no-highlight">1344</i>&nbsp;        }
<i class="no-highlight">1345</i>&nbsp;    }
<i class="no-highlight">1346</i>&nbsp;
<b class="nc"><i class="no-highlight">1347</i>&nbsp;    private void validateFileListPattern() {</b>
<b class="nc"><i class="no-highlight">1348</i>&nbsp;        if (isSnowflakeDb()) {</b>
<b class="nc"><i class="no-highlight">1349</i>&nbsp;            // When target database is Snowflake,</b>
<b class="nc"><i class="no-highlight">1350</i>&nbsp;            // we do not support a file name pattern if the source</b>
<b class="nc"><i class="no-highlight">1351</i>&nbsp;            // cloud storage authentication type is Storage Integration.d</b>
<b class="nc"><i class="no-highlight">1352</i>&nbsp;            // Thus we throw an exception for such a case.</b>
<b class="nc"><i class="no-highlight">1353</i>&nbsp;            if (StringUtils.isNotBlank(this.filePattern) &amp;&amp;</b>
<i class="no-highlight">1354</i>&nbsp;                    StringUtils.isNotBlank(eltDatabaseAccount.getStorageIntegration())) {
<b class="nc"><i class="no-highlight">1355</i>&nbsp;                throw new ConfigurationException(</b>
<b class="nc"><i class="no-highlight">1356</i>&nbsp;                        ERR_UNSUPPORTED_AUTHTYPE_FOR_FILE_PATTERN_SNOWFLAKE)</b>
<i class="no-highlight">1357</i>&nbsp;                        .withReason(REASON_UNSUPPORTED_AUTHTYPE_FOR_FILE_PATTERN_SNOWFLAKE)
<b class="nc"><i class="no-highlight">1358</i>&nbsp;                        .withResolution(</b>
<i class="no-highlight">1359</i>&nbsp;                                RESOLUTION_UNSUPPORTED_AUTHTYPE_FOR_FILE_PATTERN_SNOWFLAKE);
<b class="nc"><i class="no-highlight">1360</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">1361</i>&nbsp;        }</b>
<i class="no-highlight">1362</i>&nbsp;    }
<b class="nc"><i class="no-highlight">1363</i>&nbsp;</b>
<i class="no-highlight">1364</i>&nbsp;    public static void configurePropertyList(final PropertyValues propertyValues,
<b class="nc"><i class="no-highlight">1365</i>&nbsp;                                       final String loadAction,</b>
<b class="nc"><i class="no-highlight">1366</i>&nbsp;                                       final List&lt;Map&lt;String, String&gt;&gt; fieldList, String prop,</b>
<i class="no-highlight">1367</i>&nbsp;                                       List&lt;String&gt; field) {
<b class="nc"><i class="no-highlight">1368</i>&nbsp;        if (CollectionUtils.isNotEmpty(fieldList)) {</b>
<i class="no-highlight">1369</i>&nbsp;            for (Map&lt;String, String&gt; item : fieldList) {
<b class="nc"><i class="no-highlight">1370</i>&nbsp;                String path = propertyValues.getExpressionPropertyFor(item,</b>
<i class="no-highlight">1371</i>&nbsp;                        prop).eval(null);
<b class="nc"><i class="no-highlight">1372</i>&nbsp;                if (StringUtils.isNotBlank(path) ||</b>
<b class="nc"><i class="no-highlight">1373</i>&nbsp;                        ((StringUtils.equals(prop, DATA_TYPE_PROP) ||</b>
<i class="no-highlight">1374</i>&nbsp;                                StringUtils.equals(prop, TABLE_COLUMN_PROP)) &amp;&amp;
<b class="nc"><i class="no-highlight">1375</i>&nbsp;                                (StringUtils.equals(loadAction, ALTER_TABLE) ||</b>
<i class="no-highlight">1376</i>&nbsp;                                        StringUtils.equals(loadAction, DROP_CREATE_TABLE)))) {
<b class="nc"><i class="no-highlight">1377</i>&nbsp;                    field.add(path);</b>
<i class="no-highlight">1378</i>&nbsp;                }
<b class="nc"><i class="no-highlight">1379</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">1380</i>&nbsp;        }</b>
<i class="no-highlight">1381</i>&nbsp;    }
<b class="nc"><i class="no-highlight">1382</i>&nbsp;</b>
<i class="no-highlight">1383</i>&nbsp;    private void getFileFormatOptionsSnowflake(
<b class="nc"><i class="no-highlight">1384</i>&nbsp;            final PropertyValues propertyValues,</b>
<i class="no-highlight">1385</i>&nbsp;            final List&lt;Map&lt;String, String&gt;&gt; fileFormatOptionList) {
<b class="nc"><i class="no-highlight">1386</i>&nbsp;        if (CollectionUtils.isNotEmpty(fileFormatOptionList)) {</b>
<b class="nc"><i class="no-highlight">1387</i>&nbsp;            ListIterator&lt;Map&lt;String, String&gt;&gt; itr = fileFormatOptionList.listIterator();</b>
<i class="no-highlight">1388</i>&nbsp;            while (itr.hasNext()) {
<b class="nc"><i class="no-highlight">1389</i>&nbsp;                Map&lt;String, String&gt; item = itr.next();</b>
<i class="no-highlight">1390</i>&nbsp;                String path = propertyValues.getExpressionPropertyFor(item,
<b class="nc"><i class="no-highlight">1391</i>&nbsp;                        FILE_FORMAT_OPTION_PROP).eval(null);</b>
<b class="nc"><i class="no-highlight">1392</i>&nbsp;                if (StringUtils.containsIgnoreCase(path,</b>
<i class="no-highlight">1393</i>&nbsp;                        SNOWFLAKE_FFO_FIELD_DELIMITER)) {
<b class="nc"><i class="no-highlight">1394</i>&nbsp;                    if (!EltUtils.isOptionTheGivenValue(path, NONE)) {</b>
<i class="no-highlight">1395</i>&nbsp;                        fieldDelimiter = EltUtils.grepCharValueFileFormatOption(path);
<b class="nc"><i class="no-highlight">1396</i>&nbsp;                    }</b>
<b class="nc"><i class="no-highlight">1397</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,</b>
<i class="no-highlight">1398</i>&nbsp;                        SNOWFLAKE_FFO_SKIP_HEADER)) {
<b class="nc"><i class="no-highlight">1399</i>&nbsp;                    skipHeader =</b>
<b class="nc"><i class="no-highlight">1400</i>&nbsp;                            EltUtils.grepIntegerValueFileFormatOption(path,</b>
<i class="no-highlight">1401</i>&nbsp;                                    SNOWFLAKE_FFO_SKIP_HEADER, EQUAL_TO);
<b class="nc"><i class="no-highlight">1402</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,</b>
<b class="nc"><i class="no-highlight">1403</i>&nbsp;                        SNOWFLAKE_FFO_DATE_FORMAT)) {</b>
<i class="no-highlight">1404</i>&nbsp;                    if (EltUtils.isOptionTheGivenValue(path, AUTO)) {
<b class="nc"><i class="no-highlight">1405</i>&nbsp;                        dateFormat = AUTO;</b>
<b class="nc"><i class="no-highlight">1406</i>&nbsp;                    } else {</b>
<i class="no-highlight">1407</i>&nbsp;                        dateFormat = EltUtils.grepStringValueFileFormatOption(path);
<b class="nc"><i class="no-highlight">1408</i>&nbsp;                    }</b>
<b class="nc"><i class="no-highlight">1409</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,</b>
<i class="no-highlight">1410</i>&nbsp;                        SNOWFLAKE_FFO_TIME_FORMAT)) {
<i class="no-highlight">1411</i>&nbsp;                    if (EltUtils.isOptionTheGivenValue(path, AUTO)) {
<b class="nc"><i class="no-highlight">1412</i>&nbsp;                        timeFormat = AUTO;</b>
<i class="no-highlight">1413</i>&nbsp;                    } else {
<i class="no-highlight">1414</i>&nbsp;                        timeFormat = EltUtils.grepStringValueFileFormatOption(path);
<i class="no-highlight">1415</i>&nbsp;                    }
<b class="nc"><i class="no-highlight">1416</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,</b>
<b class="nc"><i class="no-highlight">1417</i>&nbsp;                        SNOWFLAKE_FFO_TIMESTAMP_FORMAT)) {</b>
<i class="no-highlight">1418</i>&nbsp;                    if (EltUtils.isOptionTheGivenValue(path, AUTO)) {
<i class="no-highlight">1419</i>&nbsp;                        timestampFormat = AUTO;
<i class="no-highlight">1420</i>&nbsp;                    } else {
<i class="no-highlight">1421</i>&nbsp;                        timestampFormat = EltUtils.grepStringValueFileFormatOption(path);
<i class="no-highlight">1422</i>&nbsp;                    }
<i class="no-highlight">1423</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,
<i class="no-highlight">1424</i>&nbsp;                        SNOWFLAKE_FFO_BINARY_FORMAT)) {
<i class="no-highlight">1425</i>&nbsp;                    binaryFormat = EltUtils
<i class="no-highlight">1426</i>&nbsp;                            .grepStringValueWithoutQuotesFileFormatOption(
<i class="no-highlight">1427</i>&nbsp;                                    path, SNOWFLAKE_FFO_BINARY_FORMAT, EQUAL_TO);
<i class="no-highlight">1428</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,
<i class="no-highlight">1429</i>&nbsp;                        INFER_SCHEMA_OPTION_NAME)) {
<i class="no-highlight">1430</i>&nbsp;                    inferSchemaEnabled = EltUtils.grepBooleanValueFileFormatOption(path);
<i class="no-highlight">1431</i>&nbsp;                    fileFormatOptions.removeIf(o -&gt; StringUtils.containsIgnoreCase(o,
<i class="no-highlight">1432</i>&nbsp;                            INFER_SCHEMA_OPTION_NAME));
<i class="no-highlight">1433</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,
<b class="nc"><i class="no-highlight">1434</i>&nbsp;                        SNOWFLAKE_FFO_ESCAPE)) {</b>
<b class="nc"><i class="no-highlight">1435</i>&nbsp;                    escapeChar = EltUtils.grepCharValueFileFormatOption(path);</b>
<b class="nc"><i class="no-highlight">1436</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,</b>
<b class="nc"><i class="no-highlight">1437</i>&nbsp;                        SNOWFLAKE_FFO_FIELD_OPTIONALLY_ENCLOSED_BY)) {</b>
<b class="nc"><i class="no-highlight">1438</i>&nbsp;                    fieldOptionallyEnclosedBy = EltUtils.grepCharValueFileFormatOption(path);</b>
<b class="nc"><i class="no-highlight">1439</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,</b>
<b class="nc"><i class="no-highlight">1440</i>&nbsp;                        SNOWFLAKE_FFO_NULL_IF)) {</b>
<b class="nc"><i class="no-highlight">1441</i>&nbsp;                    nullIf = EltUtils.grepStringValueFileFormatOption(path);</b>
<b class="nc"><i class="no-highlight">1442</i>&nbsp;                } else if (StringUtils.containsIgnoreCase(path,</b>
<b class="nc"><i class="no-highlight">1443</i>&nbsp;                        SNOWFLAKE_FFO_ENCODING)) {</b>
<b class="nc"><i class="no-highlight">1444</i>&nbsp;                    encoding = EltUtils.grepStringValueFileFormatOption(path);</b>
<b class="nc"><i class="no-highlight">1445</i>&nbsp;                }  else if (StringUtils.containsIgnoreCase(path,</b>
<i class="no-highlight">1446</i>&nbsp;                        SNOWFLAKE_FFO_COMPRESSION)) {
<b class="nc"><i class="no-highlight">1447</i>&nbsp;                    compressionType = EltUtils</b>
<i class="no-highlight">1448</i>&nbsp;                            .grepStringValueWithoutQuotesFileFormatOption(
<b class="nc"><i class="no-highlight">1449</i>&nbsp;                                    path, SNOWFLAKE_FFO_COMPRESSION, EQUAL_TO);</b>
<b class="nc"><i class="no-highlight">1450</i>&nbsp;                }</b>
<i class="no-highlight">1451</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1452</i>&nbsp;        }</b>
<i class="no-highlight">1453</i>&nbsp;
<i class="no-highlight">1454</i>&nbsp;        // Assign default value if fieldDelimiter is not set above.
<b class="nc"><i class="no-highlight">1455</i>&nbsp;        if (fieldDelimiter == Character.MIN_VALUE) {</b>
<b class="nc"><i class="no-highlight">1456</i>&nbsp;            fieldDelimiter = COMMA;</b>
<b class="nc"><i class="no-highlight">1457</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1458</i>&nbsp;    }</b>
<i class="no-highlight">1459</i>&nbsp;
<b class="nc"><i class="no-highlight">1460</i>&nbsp;    /**</b>
<i class="no-highlight">1461</i>&nbsp;     * Build a columnMap with non-empty entries &lt;target column name,
<b class="nc"><i class="no-highlight">1462</i>&nbsp;     * source column name or position&gt;</b>
<i class="no-highlight">1463</i>&nbsp;     * from the given propertyValues using TARGET_TO_SOURCE_COLUMNS_MAP_PATH.
<i class="no-highlight">1464</i>&nbsp;     *
<i class="no-highlight">1465</i>&nbsp;     * Note that this function may return empty map and this is OK.
<b class="nc"><i class="no-highlight">1466</i>&nbsp;     * Also note that validateColumnMappingMap() is called right after calling</b>
<b class="nc"><i class="no-highlight">1467</i>&nbsp;     * this function to validate the entries of the newly created map.</b>
<b class="nc"><i class="no-highlight">1468</i>&nbsp;     *</b>
<i class="no-highlight">1469</i>&nbsp;     * @param propertyValues
<i class="no-highlight">1470</i>&nbsp;     * @return A new column map
<b class="nc"><i class="no-highlight">1471</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">1472</i>&nbsp;    private Map&lt;String, String&gt; buildColumnMappingMap(final PropertyValues propertyValues) {</b>
<i class="no-highlight">1473</i>&nbsp;        List&lt;Map&lt;String, Object&gt;&gt; columnMappingTable =
<i class="no-highlight">1474</i>&nbsp;                propertyValues.get(TARGET_TO_SOURCE_COLUMNS_MAP_PATH);
<b class="nc"><i class="no-highlight">1475</i>&nbsp;        Map&lt;String, String&gt; columnMap = Maps.newLinkedHashMap();</b>
<i class="no-highlight">1476</i>&nbsp;        if (CollectionUtils.isNotEmpty(columnMappingTable)) {
<b class="nc"><i class="no-highlight">1477</i>&nbsp;            for (Map&lt;String, Object&gt; insertValuesRow : columnMappingTable) {</b>
<i class="no-highlight">1478</i>&nbsp;                String key = propertyValues
<i class="no-highlight">1479</i>&nbsp;                        .getExpressionPropertyFor(insertValuesRow, TARGET_TABLE_COLUMN_NAME_PROP)
<i class="no-highlight">1480</i>&nbsp;                        .eval(null);
<i class="no-highlight">1481</i>&nbsp;                String value = EMPTY_STRING;
<i class="no-highlight">1482</i>&nbsp;                if (enableSourceColumnPosition) {
<i class="no-highlight">1483</i>&nbsp;                    value = propertyValues
<b class="nc"><i class="no-highlight">1484</i>&nbsp;                            .getExpressionPropertyFor(insertValuesRow,</b>
<i class="no-highlight">1485</i>&nbsp;                                    SOURCE_FILE_COLUMN_POSITION_PROP)
<i class="no-highlight">1486</i>&nbsp;                            .eval(null);
<i class="no-highlight">1487</i>&nbsp;                } else {
<i class="no-highlight">1488</i>&nbsp;                    value = propertyValues
<i class="no-highlight">1489</i>&nbsp;                            .getExpressionPropertyFor(insertValuesRow,
<b class="nc"><i class="no-highlight">1490</i>&nbsp;                                    SOURCE_FILE_COLUMN_NAME_PROP)</b>
<b class="nc"><i class="no-highlight">1491</i>&nbsp;                            .eval(null);</b>
<i class="no-highlight">1492</i>&nbsp;                }
<i class="no-highlight">1493</i>&nbsp;
<b class="nc"><i class="no-highlight">1494</i>&nbsp;                key = transformSql(propertyValues, key);</b>
<b class="nc"><i class="no-highlight">1495</i>&nbsp;                value = transformSql(propertyValues, value);</b>
<b class="nc"><i class="no-highlight">1496</i>&nbsp;                if (columnMap.containsKey(key)) {</b>
<i class="no-highlight">1497</i>&nbsp;                    throw new ConfigurationException(String.format(ERR_DUPLICATE_FIELDS,
<i class="no-highlight">1498</i>&nbsp;                            TARGET_TO_SOURCE_COLUMNS_MAP_LABEL))
<b class="nc"><i class="no-highlight">1499</i>&nbsp;                            .withReason(String.format(REASON_DUPLICATE_FIELDS,</b>
<i class="no-highlight">1500</i>&nbsp;                                    TARGET_TO_SOURCE_COLUMNS_MAP_LABEL))
<i class="no-highlight">1501</i>&nbsp;                            .withResolution(String.format(RES_DUPLICATE_FIELDS,
<i class="no-highlight">1502</i>&nbsp;                                    TARGET_TO_SOURCE_COLUMNS_MAP_LABEL));
<i class="no-highlight">1503</i>&nbsp;                }
<b class="nc"><i class="no-highlight">1504</i>&nbsp;                // Allow empty value for Redshift, Azure Synapse, and Snowflake.</b>
<b class="nc"><i class="no-highlight">1505</i>&nbsp;                if (isRedshiftDb() || isAzureSynapseDb() || isSnowflakeDb()) {</b>
<i class="no-highlight">1506</i>&nbsp;                    if (StringUtils.isNotBlank(key)) {
<i class="no-highlight">1507</i>&nbsp;                        columnMap.put(key, value);
<i class="no-highlight">1508</i>&nbsp;                    }
<i class="no-highlight">1509</i>&nbsp;                } else {
<i class="no-highlight">1510</i>&nbsp;                    if (StringUtils.isNotBlank(key) &amp;&amp; StringUtils.isNotBlank(value)) {
<b class="nc"><i class="no-highlight">1511</i>&nbsp;                        columnMap.put(key, value);</b>
<b class="nc"><i class="no-highlight">1512</i>&nbsp;                    }</b>
<b class="nc"><i class="no-highlight">1513</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">1514</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">1515</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1516</i>&nbsp;        return columnMap;</b>
<i class="no-highlight">1517</i>&nbsp;    }
<i class="no-highlight">1518</i>&nbsp;
<i class="no-highlight">1519</i>&nbsp;    /**
<i class="no-highlight">1520</i>&nbsp;     * Sets &quot;needTransformationPreaction&quot; flag if necessary
<b class="nc"><i class="no-highlight">1521</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">1522</i>&nbsp;    private void setNeedTransformationPreactionForSnowflake() {</b>
<i class="no-highlight">1523</i>&nbsp;        // If this is for Snowflake, enableSourceColumnPosition is true,
<i class="no-highlight">1524</i>&nbsp;        // columnMappingMap.values() has all non-empty entries,
<i class="no-highlight">1525</i>&nbsp;        // columnMappingMap.values() is not a number sequence starting from 1
<i class="no-highlight">1526</i>&nbsp;        // (i.e., a shuffled number sequence or with a missing positions) and
<i class="no-highlight">1527</i>&nbsp;        // &quot;filePaths&quot; not empty,
<i class="no-highlight">1528</i>&nbsp;        // then set true to &quot;needTransformationPreaction&quot;.
<i class="no-highlight">1529</i>&nbsp;        if (isSnowflakeDb()) {
<i class="no-highlight">1530</i>&nbsp;            if (enableSourceColumnPosition &amp;&amp;
<b class="nc"><i class="no-highlight">1531</i>&nbsp;                    EltUtils.isAllValuesOfMapNotBlank(this.columnMappingMap.values()) &amp;&amp;</b>
<b class="nc"><i class="no-highlight">1532</i>&nbsp;                    !EltUtils.isNumberSequenceStartingFromOne(</b>
<b class="nc"><i class="no-highlight">1533</i>&nbsp;                            this.columnMappingMap.values()) &amp;&amp;</b>
<b class="nc"><i class="no-highlight">1534</i>&nbsp;                    (EltUtils.isSourceFileListNotEmpty(this.filePaths) ||</b>
<b class="nc"><i class="no-highlight">1535</i>&nbsp;                            StringUtils.isNotBlank(this.filePattern)</b>
<b class="nc"><i class="no-highlight">1536</i>&nbsp;                    )) {</b>
<b class="nc"><i class="no-highlight">1537</i>&nbsp;                needTransformationPreaction = true;</b>
<i class="no-highlight">1538</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1539</i>&nbsp;            if (isSemiStructuredFileTypeSnowflake() &amp;&amp;</b>
<i class="no-highlight">1540</i>&nbsp;                    EltUtils.isAllValuesOfMapNotBlank(this.columnMappingMap.values()) &amp;&amp;
<i class="no-highlight">1541</i>&nbsp;                    (EltUtils.isSourceFileListNotEmpty(this.filePaths) ||
<i class="no-highlight">1542</i>&nbsp;                            StringUtils.isNotBlank(this.filePattern)
<i class="no-highlight">1543</i>&nbsp;                    )) {
<i class="no-highlight">1544</i>&nbsp;                needTransformationPreaction = true;
<b class="nc"><i class="no-highlight">1545</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">1546</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1547</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">1548</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1549</i>&nbsp;    /**</b>
<i class="no-highlight">1550</i>&nbsp;     * Validate &quot;this.columnMappingMap&quot; if it is not empty.
<i class="no-highlight">1551</i>&nbsp;     */
<i class="no-highlight">1552</i>&nbsp;    private void validateColumnMappingMap() {
<b class="nc"><i class="no-highlight">1553</i>&nbsp;        if (MapUtils.isEmpty(columnMappingMap)) {</b>
<b class="nc"><i class="no-highlight">1554</i>&nbsp;            return;</b>
<b class="nc"><i class="no-highlight">1555</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1556</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1557</i>&nbsp;        // 1. Verify &quot;this.targetColumns&quot; entries and &quot;columnMappingMap&quot;</b>
<i class="no-highlight">1558</i>&nbsp;        // target column key values depending on the load action.
<i class="no-highlight">1559</i>&nbsp;        if (StringUtils.equals(loadAction, OVERWRITE_TABLE) ||
<i class="no-highlight">1560</i>&nbsp;                StringUtils.equals(loadAction, APPEND_ROWS_TABLE)) {
<i class="no-highlight">1561</i>&nbsp;            // Verify that target columns from &quot;columnMappingMap.keySet()&quot;
<i class="no-highlight">1562</i>&nbsp;            // exist in the target table.
<b class="nc"><i class="no-highlight">1563</i>&nbsp;            verifyTargetColumnExistence(</b>
<b class="nc"><i class="no-highlight">1564</i>&nbsp;                    new ArrayList(this.columnMappingMap.keySet()));</b>
<b class="nc"><i class="no-highlight">1565</i>&nbsp;        } else if (StringUtils.equals(loadAction, DROP_CREATE_TABLE)) {</b>
<b class="nc"><i class="no-highlight">1566</i>&nbsp;            // Verify that target columns from &quot;columnMappingMap.keySet()&quot;</b>
<b class="nc"><i class="no-highlight">1567</i>&nbsp;            // have a matching entry in &quot;targetColumns&quot; list if DROP_CREATE.</b>
<i class="no-highlight">1568</i>&nbsp;            verifyColumnMapTargetColumnNamesExistInTargetColumns();
<b class="nc"><i class="no-highlight">1569</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1570</i>&nbsp;</b>
<i class="no-highlight">1571</i>&nbsp;        // 2. Verify that &quot;columnMappingMap&quot; source column values have
<i class="no-highlight">1572</i>&nbsp;        // matching source file column header entries if Deltalake
<b class="nc"><i class="no-highlight">1573</i>&nbsp;        if (isDeltalakeDb()) {</b>
<b class="nc"><i class="no-highlight">1574</i>&nbsp;            verifyColumnMappingMapSourceColumnNamesExistInSourceFileHeader(</b>
<i class="no-highlight">1575</i>&nbsp;                    sourceFileFieldNames);
<i class="no-highlight">1576</i>&nbsp;        }
<i class="no-highlight">1577</i>&nbsp;
<i class="no-highlight">1578</i>&nbsp;        // 3. &#39;Enable source column position&#39; option should not be enabled except
<i class="no-highlight">1579</i>&nbsp;        //    Snowflake and Azure Synapse.
<i class="no-highlight">1580</i>&nbsp;        if (enableSourceColumnPosition &amp;&amp;
<i class="no-highlight">1581</i>&nbsp;                !(isSnowflakeDb() || isAzureSynapseDb())) {
<b class="nc"><i class="no-highlight">1582</i>&nbsp;            throw new ConfigurationException(ERR_INVALID_SOURCE_COLUMN_POSITIONS_FOUND)</b>
<b class="nc"><i class="no-highlight">1583</i>&nbsp;                    .withReason(String.format(</b>
<b class="nc"><i class="no-highlight">1584</i>&nbsp;                            REASON_INVALID_SOURCE_COLUMN_POSITIONS_FOUND, this.getName()))</b>
<i class="no-highlight">1585</i>&nbsp;                    .withResolution(RESOLUTION_INVALID_SOURCE_COLUMN_POSITIONS_FOUND);
<b class="nc"><i class="no-highlight">1586</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1587</i>&nbsp;</b>
<i class="no-highlight">1588</i>&nbsp;        // 4. Validate source column position values from the
<i class="no-highlight">1589</i>&nbsp;        // &quot;columnMappingMap&quot;.
<i class="no-highlight">1590</i>&nbsp;        if (enableSourceColumnPosition) {
<b class="nc"><i class="no-highlight">1591</i>&nbsp;            verifySourceColumnPositionValues();</b>
<i class="no-highlight">1592</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1593</i>&nbsp;</b>
<i class="no-highlight">1594</i>&nbsp;        // 5. Error out for BigQuery if auto_detect is not true but
<i class="no-highlight">1595</i>&nbsp;        // columnMappingMap is not blank.
<b class="nc"><i class="no-highlight">1596</i>&nbsp;        if (isFileFormatOptionAutoDetectNotSetTrueForBigQuery()) {</b>
<b class="nc"><i class="no-highlight">1597</i>&nbsp;            throw new ConfigurationException(ERR_INVALID_AUTODETECT_VALUE_FOUND)</b>
<b class="nc"><i class="no-highlight">1598</i>&nbsp;                    .withReason(String.format(</b>
<i class="no-highlight">1599</i>&nbsp;                            REASON_INVALID_AUTODETECT_VALUE_FOUND, this.getName()))
<b class="nc"><i class="no-highlight">1600</i>&nbsp;                    .withResolution(RESOLUTION_INVALID_AUTODETECT_VALUE_FOUND);</b>
<i class="no-highlight">1601</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1602</i>&nbsp;</b>
<i class="no-highlight">1603</i>&nbsp;        // 6. Error out if the map.values() has an empty element.
<i class="no-highlight">1604</i>&nbsp;        if (isRedshiftDb()) {
<b class="nc"><i class="no-highlight">1605</i>&nbsp;            if (isThereEmptyElementAtColumnMappingMapValues()) {</b>
<b class="nc"><i class="no-highlight">1606</i>&nbsp;                throw new ConfigurationException(ERR_INVALID_SOURCE_COLUMN_NAME_FOUND)</b>
<i class="no-highlight">1607</i>&nbsp;                        .withReason(REASON_EMPTY_SOURCE_COLUMN_NAME_FOUND)
<i class="no-highlight">1608</i>&nbsp;                        .withResolution(RESOLUTION_EMPTY_SOURCE_COLUMN_NAME_FOUND);
<i class="no-highlight">1609</i>&nbsp;            }
<i class="no-highlight">1610</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1611</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1612</i>&nbsp;        // 7. Error out if it is BigQuery and the cloud storage is not GCS but</b>
<i class="no-highlight">1613</i>&nbsp;        // columnMappingMap is not blank
<b class="nc"><i class="no-highlight">1614</i>&nbsp;        if (isBigQueryDb()) {</b>
<b class="nc"><i class="no-highlight">1615</i>&nbsp;            String sourceLocation = eltDatabaseAccount.getSourceLocation();</b>
<b class="nc"><i class="no-highlight">1616</i>&nbsp;            if (!StringUtils.equalsIgnoreCase(sourceLocation, GOOGLE_CLOUD_STORAGE)) {</b>
<i class="no-highlight">1617</i>&nbsp;                throw new ConfigurationException(
<b class="nc"><i class="no-highlight">1618</i>&nbsp;                        String.format(ERR_UNSUPPORTED_STORAGE_TYPE_FOR_COLUMN_MAP_BIGQUERY,</b>
<b class="nc"><i class="no-highlight">1619</i>&nbsp;                                sourceLocation))</b>
<i class="no-highlight">1620</i>&nbsp;                        .withReason(
<b class="nc"><i class="no-highlight">1621</i>&nbsp;                                String.format(</b>
<i class="no-highlight">1622</i>&nbsp;                                        REASON_UNSUPPORTED_STORAGE_TYPE_FOR_COLUMN_MAP_BIGQUERY,
<b class="nc"><i class="no-highlight">1623</i>&nbsp;                                sourceLocation))</b>
<i class="no-highlight">1624</i>&nbsp;                        .withResolution(
<i class="no-highlight">1625</i>&nbsp;                                String.format(
<i class="no-highlight">1626</i>&nbsp;                                        RESOLUTION_UNSUPPORTED_STORAGE_TYPE_FOR_COLUMN_MAP_BIGQUERY,
<i class="no-highlight">1627</i>&nbsp;                                        sourceLocation));
<b class="nc"><i class="no-highlight">1628</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">1629</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1630</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">1631</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1632</i>&nbsp;    private boolean isThereEmptyElementAtColumnMappingMapValues() {</b>
<b class="nc"><i class="no-highlight">1633</i>&nbsp;        for (String v : columnMappingMap.values()) {</b>
<i class="no-highlight">1634</i>&nbsp;            if (StringUtils.isBlank(v)) {
<i class="no-highlight">1635</i>&nbsp;                return true;
<b class="nc"><i class="no-highlight">1636</i>&nbsp;            }</b>
<i class="no-highlight">1637</i>&nbsp;        }
<i class="no-highlight">1638</i>&nbsp;        return false;
<i class="no-highlight">1639</i>&nbsp;    }
<b class="nc"><i class="no-highlight">1640</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1641</i>&nbsp;    private boolean isFileFormatOptionAutoDetectNotSetTrueForBigQuery() {</b>
<b class="nc"><i class="no-highlight">1642</i>&nbsp;        if (!isBigQueryDb()) {</b>
<b class="nc"><i class="no-highlight">1643</i>&nbsp;            // Return false if not BigQuery</b>
<i class="no-highlight">1644</i>&nbsp;            return false;
<i class="no-highlight">1645</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1646</i>&nbsp;</b>
<i class="no-highlight">1647</i>&nbsp;        for (String fileFormatOption : fileFormatOptions) {
<b class="nc"><i class="no-highlight">1648</i>&nbsp;            String[] fileFormatNameValuePair = fileFormatOption.trim().split(&quot;=&quot;);</b>
<i class="no-highlight">1649</i>&nbsp;            if (StringUtils.equalsIgnoreCase(fileFormatNameValuePair[0].trim(),
<i class="no-highlight">1650</i>&nbsp;                    AUTO_DETECT_OPTION_NAME)) {
<i class="no-highlight">1651</i>&nbsp;                if (StringUtils.equalsIgnoreCase(fileFormatNameValuePair[1].trim(),
<b class="nc"><i class="no-highlight">1652</i>&nbsp;                        TRUE_BOOLEAN_STR)) {</b>
<b class="nc"><i class="no-highlight">1653</i>&nbsp;                    return false;</b>
<b class="nc"><i class="no-highlight">1654</i>&nbsp;                }</b>
<i class="no-highlight">1655</i>&nbsp;            }
<i class="no-highlight">1656</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1657</i>&nbsp;        return true;</b>
<b class="nc"><i class="no-highlight">1658</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">1659</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1660</i>&nbsp;    private void verifyColumnMappingMapSourceColumnNamesExistInSourceFileHeader(</b>
<b class="nc"><i class="no-highlight">1661</i>&nbsp;            Set&lt;String&gt; sourceColumnNames) {</b>
<i class="no-highlight">1662</i>&nbsp;        Set&lt;String&gt; sourceColumnUpperCaseNames = toUpperCase(sourceColumnNames);
<b class="nc"><i class="no-highlight">1663</i>&nbsp;        Set&lt;String&gt; mapSourceColumnNames = toUpperCase(this.columnMappingMap.values());</b>
<b class="nc"><i class="no-highlight">1664</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1665</i>&nbsp;        for (String currentsourceEntry : mapSourceColumnNames) {</b>
<b class="nc"><i class="no-highlight">1666</i>&nbsp;            if (!sourceColumnUpperCaseNames.contains(currentsourceEntry) &amp;&amp;</b>
<b class="nc"><i class="no-highlight">1667</i>&nbsp;                    !isColumnNameInsideSqlExpression(</b>
<b class="nc"><i class="no-highlight">1668</i>&nbsp;                            currentsourceEntry, sourceColumnUpperCaseNames)) {</b>
<b class="nc"><i class="no-highlight">1669</i>&nbsp;                throw new ConfigurationException(ERR_INVALID_SOURCE_COLUMN_NAMES_FOUND)</b>
<i class="no-highlight">1670</i>&nbsp;                        .withReason(String.format(
<i class="no-highlight">1671</i>&nbsp;                                REASON_SOURCE_COLUMN_NAMES_NOT_FOUND, currentsourceEntry))
<i class="no-highlight">1672</i>&nbsp;                        .withResolution(RESOLUTION_SOURCE_COLUMN_NAMES_NOT_FOUND);
<b class="nc"><i class="no-highlight">1673</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">1674</i>&nbsp;        }</b>
<i class="no-highlight">1675</i>&nbsp;    }
<i class="no-highlight">1676</i>&nbsp;
<i class="no-highlight">1677</i>&nbsp;    private boolean isColumnNameInsideSqlExpression(
<b class="nc"><i class="no-highlight">1678</i>&nbsp;            String expression, Set&lt;String&gt; sourceColumnUpperCaseNames) {</b>
<b class="nc"><i class="no-highlight">1679</i>&nbsp;        String separators = &quot;,( +-*/)&quot;;</b>
<b class="nc"><i class="no-highlight">1680</i>&nbsp;        String[] strs =</b>
<b class="nc"><i class="no-highlight">1681</i>&nbsp;                StringUtils.split(expression.trim(), separators, 0);</b>
<i class="no-highlight">1682</i>&nbsp;        for (String str : strs) {
<b class="nc"><i class="no-highlight">1683</i>&nbsp;            if (sourceColumnUpperCaseNames.contains(str)) {</b>
<b class="nc"><i class="no-highlight">1684</i>&nbsp;                return true;</b>
<i class="no-highlight">1685</i>&nbsp;            }
<i class="no-highlight">1686</i>&nbsp;        }
<i class="no-highlight">1687</i>&nbsp;        return false;
<i class="no-highlight">1688</i>&nbsp;    }
<b class="nc"><i class="no-highlight">1689</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1690</i>&nbsp;    private void verifyColumnMapTargetColumnNamesExistInTargetColumns() {</b>
<b class="nc"><i class="no-highlight">1691</i>&nbsp;        for (String currentTargetColName : this.columnMappingMap.keySet()) {</b>
<i class="no-highlight">1692</i>&nbsp;            if (!this.targetColumns.contains(currentTargetColName)) {
<b class="nc"><i class="no-highlight">1693</i>&nbsp;                throw new ConfigurationException(ERR_INVALID_TARGET_COLUMN_NAMES_FOUND)</b>
<i class="no-highlight">1694</i>&nbsp;                        .withReason(String.format(
<b class="nc"><i class="no-highlight">1695</i>&nbsp;                                REASON_INVALID_TARGET_COLUMN_NAMES_FOUND,</b>
<b class="nc"><i class="no-highlight">1696</i>&nbsp;                                currentTargetColName))</b>
<b class="nc"><i class="no-highlight">1697</i>&nbsp;                        .withResolution(RESOLUTION_INVALID_TARGET_COLUMN_NAMES_FOUND);</b>
<b class="nc"><i class="no-highlight">1698</i>&nbsp;            }</b>
<i class="no-highlight">1699</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1700</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">1701</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1702</i>&nbsp;    private void verifySourceColumnPositionValues() {</b>
<b class="nc"><i class="no-highlight">1703</i>&nbsp;        for (String sourceColPosition : this.columnMappingMap.values()) {</b>
<i class="no-highlight">1704</i>&nbsp;            if (StringUtils.isBlank(sourceColPosition)) {
<b class="nc"><i class="no-highlight">1705</i>&nbsp;                continue;</b>
<b class="nc"><i class="no-highlight">1706</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">1707</i>&nbsp;            try {</b>
<b class="nc"><i class="no-highlight">1708</i>&nbsp;                BigInteger position = new BigInteger((sourceColPosition));</b>
<i class="no-highlight">1709</i>&nbsp;                if (position.compareTo(BigInteger.valueOf(1)) &lt; 0) {
<i class="no-highlight">1710</i>&nbsp;                    throw new ConfigurationException(ERR_INVALID_COLUMN_MAP_CONFIGURATION)
<b class="nc"><i class="no-highlight">1711</i>&nbsp;                            .withReason(String.format(SOURCE_COLUMN_POSITION_VALUE_ERROR, 1))</b>
<b class="nc"><i class="no-highlight">1712</i>&nbsp;                            .withResolution(RESOLUTION_SET_SOURCE_COLUMN_POSITION_CORRECTLY);</b>
<b class="nc"><i class="no-highlight">1713</i>&nbsp;                }</b>
<i class="no-highlight">1714</i>&nbsp;            } catch (NumberFormatException ex) {
<b class="nc"><i class="no-highlight">1715</i>&nbsp;                Throwable t = Throwables.getRootCause(ex);</b>
<i class="no-highlight">1716</i>&nbsp;                throw new ConfigurationException(ex, ERR_MSG_INVALID_SOURCE_POSITION_FORMAT)
<b class="nc"><i class="no-highlight">1717</i>&nbsp;                        .withReason(t.getMessage())</b>
<i class="no-highlight">1718</i>&nbsp;                        .withResolution(ERR_RES_INVALID_SOURCE_POSITION_FORMAT);
<b class="nc"><i class="no-highlight">1719</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">1720</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1721</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">1722</i>&nbsp;</b>
<i class="no-highlight">1723</i>&nbsp;    private void verifyTargetColumnExistence(List&lt;String&gt; targetColumnNameList) {
<b class="nc"><i class="no-highlight">1724</i>&nbsp;        String columnList = StringUtils.EMPTY;</b>
<b class="nc"><i class="no-highlight">1725</i>&nbsp;        String checkColumnsInTableSql = StringUtils.EMPTY;</b>
<b class="nc"><i class="no-highlight">1726</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1727</i>&nbsp;        // All the column names from &quot;this.targetColumns&quot;</b>
<i class="no-highlight">1728</i>&nbsp;        // should be present in the target table
<i class="no-highlight">1729</i>&nbsp;        if (CollectionUtils.isNotEmpty(targetColumnNameList)) {
<b class="nc"><i class="no-highlight">1730</i>&nbsp;            columnList = String.join(COMMA_SPACE, targetColumnNameList);</b>
<b class="nc"><i class="no-highlight">1731</i>&nbsp;            checkColumnsInTableSql =</b>
<b class="nc"><i class="no-highlight">1732</i>&nbsp;                    String.format(</b>
<i class="no-highlight">1733</i>&nbsp;                            CHECK_IF_COLUMN_PRESENT_SQL, columnList, targetTableName);
<b class="nc"><i class="no-highlight">1734</i>&nbsp;            checkIfColumnsExistInTable(checkColumnsInTableSql,</b>
<i class="no-highlight">1735</i>&nbsp;                    String.format(TARGET_TABLE, targetTableName));
<b class="nc"><i class="no-highlight">1736</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1737</i>&nbsp;    }</b>
<i class="no-highlight">1738</i>&nbsp;
<i class="no-highlight">1739</i>&nbsp;    private void buildQueryBuilder() {
<b class="nc"><i class="no-highlight">1740</i>&nbsp;        String dbType = getName();</b>
<b class="nc"><i class="no-highlight">1741</i>&nbsp;        String sourceLocation = eltDatabaseAccount.getSourceLocation();</b>
<b class="nc"><i class="no-highlight">1742</i>&nbsp;        switch (dbType) {</b>
<b class="nc"><i class="no-highlight">1743</i>&nbsp;            case JdbcOperations.SNOWFLAKE:</b>
<i class="no-highlight">1744</i>&nbsp;                switch (sourceLocation) {
<b class="nc"><i class="no-highlight">1745</i>&nbsp;                    case AMAZON_S3:</b>
<b class="nc"><i class="no-highlight">1746</i>&nbsp;                        retrieveAwsS3Info();</b>
<b class="nc"><i class="no-highlight">1747</i>&nbsp;                        buildingCopyCommandForAws();</b>
<i class="no-highlight">1748</i>&nbsp;                        buildQuery(sourceLocation);
<b class="nc"><i class="no-highlight">1749</i>&nbsp;                        break;</b>
<i class="no-highlight">1750</i>&nbsp;                    case AZURE:
<b class="nc"><i class="no-highlight">1751</i>&nbsp;                        retrieveAzureInfo();</b>
<b class="nc"><i class="no-highlight">1752</i>&nbsp;                        buildingCopyCommandForAzure();</b>
<b class="nc"><i class="no-highlight">1753</i>&nbsp;                        buildQuery(sourceLocation);</b>
<b class="nc"><i class="no-highlight">1754</i>&nbsp;                        break;</b>
<i class="no-highlight">1755</i>&nbsp;                    case GOOGLE_CLOUD_STORAGE:
<b class="nc"><i class="no-highlight">1756</i>&nbsp;                        retrieveGCSInfo();</b>
<i class="no-highlight">1757</i>&nbsp;                        buildingCopyCommandForGCS(GCS);
<b class="nc"><i class="no-highlight">1758</i>&nbsp;                        buildQuery(sourceLocation);</b>
<b class="nc"><i class="no-highlight">1759</i>&nbsp;                        break;</b>
<i class="no-highlight">1760</i>&nbsp;                    case NONE:
<b class="nc"><i class="no-highlight">1761</i>&nbsp;                    default:</b>
<b class="nc"><i class="no-highlight">1762</i>&nbsp;                        throw new ConfigurationException(ERR_BLANK_SOURCE_LOCATION)</b>
<b class="nc"><i class="no-highlight">1763</i>&nbsp;                                .withReason(REASON_BLANK_SOURCE_LOCATION)</b>
<i class="no-highlight">1764</i>&nbsp;                                .withResolution(RESOLUTION_BLANK_SOURCE_LOCATION);
<b class="nc"><i class="no-highlight">1765</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">1766</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">1767</i>&nbsp;            case JdbcOperations.REDSHIFT:</b>
<i class="no-highlight">1768</i>&nbsp;                switch (sourceLocation) {
<b class="nc"><i class="no-highlight">1769</i>&nbsp;                    case AMAZON_S3:</b>
<b class="nc"><i class="no-highlight">1770</i>&nbsp;                        retrieveAwsS3Info();</b>
<i class="no-highlight">1771</i>&nbsp;                        buildingCopyCommandForAws();
<b class="nc"><i class="no-highlight">1772</i>&nbsp;                        buildQuery(sourceLocation);</b>
<b class="nc"><i class="no-highlight">1773</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">1774</i>&nbsp;                    case AZURE:</b>
<b class="nc"><i class="no-highlight">1775</i>&nbsp;                        retrieveAzureInfo();</b>
<b class="nc"><i class="no-highlight">1776</i>&nbsp;                        buildingCopyCommandForAzure();</b>
<b class="nc"><i class="no-highlight">1777</i>&nbsp;                        buildQuery(sourceLocation);</b>
<b class="nc"><i class="no-highlight">1778</i>&nbsp;                        break;</b>
<i class="no-highlight">1779</i>&nbsp;                    case NONE:
<i class="no-highlight">1780</i>&nbsp;                    default:
<b class="nc"><i class="no-highlight">1781</i>&nbsp;                        throw new ConfigurationException(ERR_BLANK_SOURCE_LOCATION)</b>
<b class="nc"><i class="no-highlight">1782</i>&nbsp;                                .withReason(REASON_BLANK_SOURCE_LOCATION)</b>
<b class="nc"><i class="no-highlight">1783</i>&nbsp;                                .withResolution(RESOLUTION_BLANK_SOURCE_LOCATION);</b>
<i class="no-highlight">1784</i>&nbsp;                }
<b class="nc"><i class="no-highlight">1785</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">1786</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:</b>
<i class="no-highlight">1787</i>&nbsp;                azureSynapseExternalStorage = eltDatabaseAccount.getExternalStorageAzureSynapse();
<b class="nc"><i class="no-highlight">1788</i>&nbsp;                switch (azureSynapseExternalStorage) {</b>
<b class="nc"><i class="no-highlight">1789</i>&nbsp;                    case AZURE_SYNAPSE_BLOB_STORAGE:</b>
<b class="nc"><i class="no-highlight">1790</i>&nbsp;                    case AZURE_SYNAPSE_ADLSGEN2_STORAGE:</b>
<b class="nc"><i class="no-highlight">1791</i>&nbsp;                        retrieveAzureSynapseAccountInfo();</b>
<i class="no-highlight">1792</i>&nbsp;                        retrieveErrorFileAzureSynapseAccountInfo();
<i class="no-highlight">1793</i>&nbsp;                        buildQuery(azureSynapseExternalStorage);
<i class="no-highlight">1794</i>&nbsp;                        break;
<i class="no-highlight">1795</i>&nbsp;                    default:
<b class="nc"><i class="no-highlight">1796</i>&nbsp;                        throw new ConfigurationException(ERR_STORAGE_TYPE_NOT_SUPPORTED)</b>
<b class="nc"><i class="no-highlight">1797</i>&nbsp;                                .withReason(REASON_STORAGE_TYPE_NOT_SUPPORTED)</b>
<i class="no-highlight">1798</i>&nbsp;                                .withResolution(RESOLUTION_STORAGE_TYPE_NOT_SUPPORTED);
<i class="no-highlight">1799</i>&nbsp;                }
<i class="no-highlight">1800</i>&nbsp;                break;
<i class="no-highlight">1801</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:
<i class="no-highlight">1802</i>&nbsp;                retrieveDBFSFolderPathInfo();
<i class="no-highlight">1803</i>&nbsp;                buildingCopyCommandForDBFSFolderPath();
<b class="nc"><i class="no-highlight">1804</i>&nbsp;                buildQuery(sourceLocation);</b>
<i class="no-highlight">1805</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">1806</i>&nbsp;            case JdbcOperations.BIGQUERY:</b>
<b class="nc"><i class="no-highlight">1807</i>&nbsp;                switch (sourceLocation) {</b>
<i class="no-highlight">1808</i>&nbsp;                    case AMAZON_S3:
<b class="nc"><i class="no-highlight">1809</i>&nbsp;                        retrieveAwsS3Info();</b>
<b class="nc"><i class="no-highlight">1810</i>&nbsp;                        bigQueryLoadOptionsConfig = buildBigQueryLoadOptionsConfig(</b>
<b class="nc"><i class="no-highlight">1811</i>&nbsp;                                fileFormatOptions);</b>
<b class="nc"><i class="no-highlight">1812</i>&nbsp;                        retrieveBqTransferDisplayName();</b>
<b class="nc"><i class="no-highlight">1813</i>&nbsp;                        buildQuery(sourceLocation);</b>
<b class="nc"><i class="no-highlight">1814</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">1815</i>&nbsp;                    case GOOGLE_CLOUD_STORAGE:</b>
<i class="no-highlight">1816</i>&nbsp;                        retrieveGCSInfo();
<b class="nc"><i class="no-highlight">1817</i>&nbsp;                        buildGCSSourceURIsListFromFilesOrPatternTypeBigQuery();</b>
<b class="nc"><i class="no-highlight">1818</i>&nbsp;                        bigQueryLoadOptionsConfig = buildBigQueryLoadOptionsConfig(</b>
<b class="nc"><i class="no-highlight">1819</i>&nbsp;                                fileFormatOptions);</b>
<b class="nc"><i class="no-highlight">1820</i>&nbsp;                        buildQuery(sourceLocation);</b>
<b class="nc"><i class="no-highlight">1821</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">1822</i>&nbsp;                    case AMAZON_REDSHIFT:</b>
<i class="no-highlight">1823</i>&nbsp;                        retrieveAwsS3Info();
<b class="nc"><i class="no-highlight">1824</i>&nbsp;                        retrieveBqRedshiftJdbcUrlAndCredentialsInfo();</b>
<b class="nc"><i class="no-highlight">1825</i>&nbsp;                        buildS3StagingFolderUriForBqRedshiftTransferLoad();</b>
<b class="nc"><i class="no-highlight">1826</i>&nbsp;                        retrieveBqRedshiftSchemaAndTableNames();</b>
<b class="nc"><i class="no-highlight">1827</i>&nbsp;                        retrieveBqTransferDisplayName();</b>
<i class="no-highlight">1828</i>&nbsp;                        buildQuery(sourceLocation);
<b class="nc"><i class="no-highlight">1829</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">1830</i>&nbsp;                    case NONE:</b>
<b class="nc"><i class="no-highlight">1831</i>&nbsp;                    default:</b>
<b class="nc"><i class="no-highlight">1832</i>&nbsp;                        throw new ConfigurationException(ERR_BLANK_SOURCE_LOCATION)</b>
<b class="nc"><i class="no-highlight">1833</i>&nbsp;                                .withReason(REASON_BLANK_SOURCE_LOCATION)</b>
<b class="nc"><i class="no-highlight">1834</i>&nbsp;                                .withResolution(RESOLUTION_BLANK_SOURCE_LOCATION);</b>
<i class="no-highlight">1835</i>&nbsp;                }
<i class="no-highlight">1836</i>&nbsp;                validateColumnMappingMap();
<i class="no-highlight">1837</i>&nbsp;                break;
<i class="no-highlight">1838</i>&nbsp;            default:
<b class="nc"><i class="no-highlight">1839</i>&nbsp;                throw new ConfigurationException(ERR_DATABASE_NOT_SUPPORTED)</b>
<i class="no-highlight">1840</i>&nbsp;                        .formatWith(dbType)
<b class="nc"><i class="no-highlight">1841</i>&nbsp;                        .withReason(REASON_DATABASE_NOT_SUPPORTED)</b>
<b class="nc"><i class="no-highlight">1842</i>&nbsp;                        .withResolution(RESOLUTION_DATABASE_NOT_SUPPORTED);</b>
<b class="nc"><i class="no-highlight">1843</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1844</i>&nbsp;    }</b>
<i class="no-highlight">1845</i>&nbsp;
<i class="no-highlight">1846</i>&nbsp;    private void buildQuery(final String sourceLocation) {
<i class="no-highlight">1847</i>&nbsp;        if (!validationInProgress &amp;&amp;
<i class="no-highlight">1848</i>&nbsp;                StringUtils.equals(loadAction, ALTER_TABLE) &amp;&amp; !hasAlterTableBeenExecuted) {
<b class="nc"><i class="no-highlight">1849</i>&nbsp;            // If it is not in validation, the load action is ALTER_TABLE,</b>
<b class="nc"><i class="no-highlight">1850</i>&nbsp;            // and ALTER TABLE load action is not yet executed, return.</b>
<b class="nc"><i class="no-highlight">1851</i>&nbsp;            return;</b>
<b class="nc"><i class="no-highlight">1852</i>&nbsp;        }</b>
<i class="no-highlight">1853</i>&nbsp;
<b class="nc"><i class="no-highlight">1854</i>&nbsp;        // Set up &quot;files&quot; if needed.</b>
<b class="nc"><i class="no-highlight">1855</i>&nbsp;        getInputFileListIfNeeded();</b>
<b class="nc"><i class="no-highlight">1856</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1857</i>&nbsp;        String dbType = getName();</b>
<i class="no-highlight">1858</i>&nbsp;        switch (dbType) {
<b class="nc"><i class="no-highlight">1859</i>&nbsp;            case JdbcOperations.SNOWFLAKE:</b>
<b class="nc"><i class="no-highlight">1860</i>&nbsp;                appendStageFilePathWithProvidedColumnsSnowflake();</b>
<b class="nc"><i class="no-highlight">1861</i>&nbsp;                appendCredentialsWithSpecifiedEncryptionTypeSnowflake(sourceLocation);</b>
<i class="no-highlight">1862</i>&nbsp;                appendFilesOrPatternTypeSnowflake();
<b class="nc"><i class="no-highlight">1863</i>&nbsp;                appendFileFormatOptionsSnowflake();</b>
<i class="no-highlight">1864</i>&nbsp;                appendCopyOptions();
<b class="nc"><i class="no-highlight">1865</i>&nbsp;                appendValidationModeSnowflake();</b>
<i class="no-highlight">1866</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">1867</i>&nbsp;            case JdbcOperations.REDSHIFT:</b>
<b class="nc"><i class="no-highlight">1868</i>&nbsp;                appendStageFilePathWithProvidedColumnsRedshift();</b>
<b class="nc"><i class="no-highlight">1869</i>&nbsp;                appendCredentialsWithSpecifiedEncryptionTypeRedshift(sourceLocation);</b>
<i class="no-highlight">1870</i>&nbsp;                appendFileFormatOptionsRedshift();
<i class="no-highlight">1871</i>&nbsp;                appendCopyOptions();
<i class="no-highlight">1872</i>&nbsp;                appendValidationModeRedshift();
<i class="no-highlight">1873</i>&nbsp;                break;
<i class="no-highlight">1874</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:
<i class="no-highlight">1875</i>&nbsp;                appendTargetTableNameAndColumnsAzureSynapse();
<b class="nc"><i class="no-highlight">1876</i>&nbsp;                appendFilesOrPatternTypeAzureSynapse();</b>
<b class="nc"><i class="no-highlight">1877</i>&nbsp;                appendFormatOptionsAzureSynapse();</b>
<b class="nc"><i class="no-highlight">1878</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">1879</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:</b>
<i class="no-highlight">1880</i>&nbsp;                appendStageFilePathWithProvidedColumnsDLP();
<i class="no-highlight">1881</i>&nbsp;                appendFileFormatTypeDLP();
<i class="no-highlight">1882</i>&nbsp;                appendFilesOrPatternTypeDLP();
<i class="no-highlight">1883</i>&nbsp;                appendFileFormatOptionsDLP();
<i class="no-highlight">1884</i>&nbsp;                appendCopyOptionsDLP();
<b class="nc"><i class="no-highlight">1885</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">1886</i>&nbsp;            case JdbcOperations.BIGQUERY:</b>
<b class="nc"><i class="no-highlight">1887</i>&nbsp;                // NOOP: For BigQuery we don&#39;t build COPY INTO statement,</b>
<b class="nc"><i class="no-highlight">1888</i>&nbsp;                // rather we call BigQuery Client library APIs and get load job executed</b>
<b class="nc"><i class="no-highlight">1889</i>&nbsp;                // in method executeBigQueryBulkLoadWithRollback()</b>
<b class="nc"><i class="no-highlight">1890</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">1891</i>&nbsp;            default:</b>
<i class="no-highlight">1892</i>&nbsp;                throw new ConfigurationException(ERR_DATABASE_NOT_SUPPORTED)
<b class="nc"><i class="no-highlight">1893</i>&nbsp;                        .formatWith(dbType)</b>
<b class="nc"><i class="no-highlight">1894</i>&nbsp;                        .withReason(REASON_DATABASE_NOT_SUPPORTED)</b>
<b class="nc"><i class="no-highlight">1895</i>&nbsp;                        .withResolution(RESOLUTION_DATABASE_NOT_SUPPORTED);</b>
<b class="nc"><i class="no-highlight">1896</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1897</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">1898</i>&nbsp;</b>
<i class="no-highlight">1899</i>&nbsp;    private void appendValidationModeSnowflake() {
<b class="nc"><i class="no-highlight">1900</i>&nbsp;        if (!VALIDATION_LIST_SNOWFLAKE.contains(validationMode)) {</b>
<i class="no-highlight">1901</i>&nbsp;            throw new ConfigurationException(ERR_INVALID_VALIDATION_MODE)
<b class="nc"><i class="no-highlight">1902</i>&nbsp;                    .withReason(REASON_INVALID_VALIDATION_MODE)</b>
<b class="nc"><i class="no-highlight">1903</i>&nbsp;                    .withResolution(RESOLUTION_INVALID_VALIDATION_MODE);</b>
<i class="no-highlight">1904</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1905</i>&nbsp;        if (validationInProgress) {</b>
<b class="nc"><i class="no-highlight">1906</i>&nbsp;            if (!matchByColumnNameOption) {</b>
<i class="no-highlight">1907</i>&nbsp;                if (!StringUtils.equals(validationMode, RETURN_N_ROWS)) {
<i class="no-highlight">1908</i>&nbsp;                    queryBuilder.append(String.format(VALIDATION_MODE_RETURN_N_ROWS_OPTION,
<b class="nc"><i class="no-highlight">1909</i>&nbsp;                            String.valueOf(actualPreviewCount)));</b>
<b class="nc"><i class="no-highlight">1910</i>&nbsp;                } else {</b>
<i class="no-highlight">1911</i>&nbsp;                    String validationRows = Integer.parseInt(rowsToReturn) &gt; actualPreviewCount ?
<i class="no-highlight">1912</i>&nbsp;                            String.valueOf(actualPreviewCount) : rowsToReturn;
<i class="no-highlight">1913</i>&nbsp;                    queryBuilder.append(String.format(VALIDATION_MODE_RETURN_N_ROWS_OPTION,
<i class="no-highlight">1914</i>&nbsp;                            validationRows));
<i class="no-highlight">1915</i>&nbsp;                }
<b class="nc"><i class="no-highlight">1916</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">1917</i>&nbsp;            // Note that, if matchByColumnNameOption is true, we don&#39;t execute</b>
<i class="no-highlight">1918</i>&nbsp;            // COPY INTO from executeSnowflakeBulkLoadWithRollback() since we are not adding
<i class="no-highlight">1919</i>&nbsp;            // validation mode here.
<i class="no-highlight">1920</i>&nbsp;        } else {
<i class="no-highlight">1921</i>&nbsp;            if (!StringUtils.equals(validationMode, NONE) &amp;&amp; !StringUtils.equals(validationMode,
<b class="nc"><i class="no-highlight">1922</i>&nbsp;                    RETURN_N_ROWS)) {</b>
<b class="nc"><i class="no-highlight">1923</i>&nbsp;                queryBuilder.append(String.format(VALIDATION_MODE_OPTION, validationMode));</b>
<b class="nc"><i class="no-highlight">1924</i>&nbsp;            } else if (!StringUtils.equals(validationMode, NONE)) {</b>
<i class="no-highlight">1925</i>&nbsp;                queryBuilder.append(String.format(VALIDATION_MODE_RETURN_N_ROWS_OPTION,
<i class="no-highlight">1926</i>&nbsp;                        rowsToReturn));
<i class="no-highlight">1927</i>&nbsp;            }
<i class="no-highlight">1928</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1929</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">1930</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">1931</i>&nbsp;    private void appendValidationModeRedshift() {</b>
<b class="nc"><i class="no-highlight">1932</i>&nbsp;        if (!VALIDATION_LIST_REDSHIFT.contains(validationMode)) {</b>
<i class="no-highlight">1933</i>&nbsp;            throw new ConfigurationException(ERR_INVALID_VALIDATION_MODE)
<b class="nc"><i class="no-highlight">1934</i>&nbsp;                    .withReason(REASON_INVALID_VALIDATION_MODE)</b>
<b class="nc"><i class="no-highlight">1935</i>&nbsp;                    .withResolution(RESOLUTION_INVALID_VALIDATION_MODE);</b>
<b class="nc"><i class="no-highlight">1936</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1937</i>&nbsp;</b>
<i class="no-highlight">1938</i>&nbsp;        // Refer to NOLOAD operation for Redshift, which is used for data integrity of files:
<i class="no-highlight">1939</i>&nbsp;        // https://docs.aws.amazon.com/redshift/latest/dg/t_Validating_input_files.html
<b class="nc"><i class="no-highlight">1940</i>&nbsp;</b>
<i class="no-highlight">1941</i>&nbsp;        if (validationInProgress) {
<b class="nc"><i class="no-highlight">1942</i>&nbsp;            if (!StringUtils.equals(validationMode, NOLOAD)) {</b>
<b class="nc"><i class="no-highlight">1943</i>&nbsp;                boolean isNoLoadFound = false;</b>
<b class="nc"><i class="no-highlight">1944</i>&nbsp;                for (String copyOption : copyOptions) {</b>
<i class="no-highlight">1945</i>&nbsp;                    if (StringUtils.startsWith(copyOption.trim(), NOLOAD)) {
<i class="no-highlight">1946</i>&nbsp;                        isNoLoadFound = true;
<i class="no-highlight">1947</i>&nbsp;                        break;
<i class="no-highlight">1948</i>&nbsp;                    }
<i class="no-highlight">1949</i>&nbsp;                }
<b class="nc"><i class="no-highlight">1950</i>&nbsp;                if (!isNoLoadFound) {</b>
<b class="nc"><i class="no-highlight">1951</i>&nbsp;                    for (String fileFormatOption : fileFormatOptions) {</b>
<b class="nc"><i class="no-highlight">1952</i>&nbsp;                        if (StringUtils.startsWith(fileFormatOption.trim(), NOLOAD)) {</b>
<b class="nc"><i class="no-highlight">1953</i>&nbsp;                            isNoLoadFound = true;</b>
<i class="no-highlight">1954</i>&nbsp;                            break;
<b class="nc"><i class="no-highlight">1955</i>&nbsp;                        }</b>
<b class="nc"><i class="no-highlight">1956</i>&nbsp;                    }</b>
<b class="nc"><i class="no-highlight">1957</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">1958</i>&nbsp;                if (!isNoLoadFound) {</b>
<b class="nc"><i class="no-highlight">1959</i>&nbsp;                    queryBuilder.append(SPACE).append(NOLOAD).append(SPACE);</b>
<b class="nc"><i class="no-highlight">1960</i>&nbsp;                }</b>
<i class="no-highlight">1961</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">1962</i>&nbsp;                queryBuilder.append(SPACE).append(NOLOAD).append(SPACE);</b>
<b class="nc"><i class="no-highlight">1963</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">1964</i>&nbsp;        } else {</b>
<b class="nc"><i class="no-highlight">1965</i>&nbsp;            if (StringUtils.equals(validationMode, NOLOAD)) {</b>
<b class="nc"><i class="no-highlight">1966</i>&nbsp;                queryBuilder.append(SPACE).append(NOLOAD).append(SPACE);</b>
<i class="no-highlight">1967</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1968</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1969</i>&nbsp;    }</b>
<i class="no-highlight">1970</i>&nbsp;
<i class="no-highlight">1971</i>&nbsp;    private void appendCopyOptions() {
<b class="nc"><i class="no-highlight">1972</i>&nbsp;        String dbType = getName();</b>
<b class="nc"><i class="no-highlight">1973</i>&nbsp;        if (!validationInProgress &amp;&amp; JdbcOperations.SNOWFLAKE.equals(dbType)) {</b>
<b class="nc"><i class="no-highlight">1974</i>&nbsp;            if (StringUtils.equals(loadAction, OVERWRITE_TABLE)) {</b>
<b class="nc"><i class="no-highlight">1975</i>&nbsp;                // For Snowflake, make sure to have &quot;FORCE = TRUE&quot; copy option</b>
<i class="no-highlight">1976</i>&nbsp;                // to use a file that is already loaded.
<i class="no-highlight">1977</i>&nbsp;                modifyCopyOption(COPY_OPTION_FORCE_TRUE, COPY_OPTION_FORCE, false);
<i class="no-highlight">1978</i>&nbsp;            }
<i class="no-highlight">1979</i>&nbsp;        }
<i class="no-highlight">1980</i>&nbsp;
<b class="nc"><i class="no-highlight">1981</i>&nbsp;        if (CollectionUtils.isNotEmpty(copyOptions)) {</b>
<b class="nc"><i class="no-highlight">1982</i>&nbsp;            String matchByColumnName =</b>
<b class="nc"><i class="no-highlight">1983</i>&nbsp;                    getLHSOfCopyOption(MATCH_BY_COLUMN_NAME.toString(), &quot;=&quot;).trim();</b>
<i class="no-highlight">1984</i>&nbsp;            String matchByOption = EMPTY_STRING;
<i class="no-highlight">1985</i>&nbsp;            for (String copyOpt : copyOptions) {
<i class="no-highlight">1986</i>&nbsp;              if (copyOpt.startsWith(matchByColumnName) &amp;&amp; !copyOpt.endsWith(NONE.toUpperCase())) {
<i class="no-highlight">1987</i>&nbsp;                matchByColumnNameOption = true;
<i class="no-highlight">1988</i>&nbsp;                matchByOption = copyOpt;
<i class="no-highlight">1989</i>&nbsp;                break;
<i class="no-highlight">1990</i>&nbsp;              }
<b class="nc"><i class="no-highlight">1991</i>&nbsp;            }</b>
<i class="no-highlight">1992</i>&nbsp;            if (matchByColumnNameOption &amp;&amp; (isSnowflakeTransformPreprocessingRequired ||
<i class="no-highlight">1993</i>&nbsp;                    hasTargetTableOneVariantColumnSnowflake())) {
<i class="no-highlight">1994</i>&nbsp;                copyOptions.remove(matchByOption);
<b class="nc"><i class="no-highlight">1995</i>&nbsp;                matchByColumnNameOption = false;</b>
<b class="nc"><i class="no-highlight">1996</i>&nbsp;                if (isSnowflakeTransformPreprocessingRequired) {</b>
<b class="nc"><i class="no-highlight">1997</i>&nbsp;                    SKIPPING_COPY_OPTION.report();</b>
<i class="no-highlight">1998</i>&nbsp;                } else {
<i class="no-highlight">1999</i>&nbsp;                    SKIPPING_COPY_OPTION2.report();
<i class="no-highlight">2000</i>&nbsp;                }
<i class="no-highlight">2001</i>&nbsp;            }
<i class="no-highlight">2002</i>&nbsp;            queryBuilder.append(StringUtils.join(copyOptions, SPACE));
<b class="nc"><i class="no-highlight">2003</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2004</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">2005</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2006</i>&nbsp;    private boolean hasTargetTableOneVariantColumnSnowflake() {</b>
<i class="no-highlight">2007</i>&nbsp;        if (!isSnowflakeDb()) {
<i class="no-highlight">2008</i>&nbsp;            return false;
<b class="nc"><i class="no-highlight">2009</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2010</i>&nbsp;        if (loadAction.equals(DROP_CREATE_TABLE)) {</b>
<i class="no-highlight">2011</i>&nbsp;            return targetColumns.size() == 1 &amp;&amp;
<i class="no-highlight">2012</i>&nbsp;                    targetDataTypes.size() == 1 &amp;&amp; StringUtils.equalsIgnoreCase(VARIANT_TYPE,
<i class="no-highlight">2013</i>&nbsp;                    targetDataTypes.get(0));
<i class="no-highlight">2014</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">2015</i>&nbsp;            Map&lt;String, String&gt; tableColumnNameDataTypeMap =</b>
<b class="nc"><i class="no-highlight">2016</i>&nbsp;                    getTableColumnNameDataTypeMap(targetTableName);</b>
<b class="nc"><i class="no-highlight">2017</i>&nbsp;            return tableColumnNameDataTypeMap.size() == 1 &amp;&amp;</b>
<i class="no-highlight">2018</i>&nbsp;                    tableColumnNameDataTypeMap.values().contains(VARIANT_TYPE);
<i class="no-highlight">2019</i>&nbsp;        }
<i class="no-highlight">2020</i>&nbsp;    }
<i class="no-highlight">2021</i>&nbsp;
<b class="nc"><i class="no-highlight">2022</i>&nbsp;    private void appendCopyOptionsDLP() {</b>
<b class="nc"><i class="no-highlight">2023</i>&nbsp;        if (CollectionUtils.isNotEmpty(copyOptions)) {</b>
<b class="nc"><i class="no-highlight">2024</i>&nbsp;            String copyOpts = StringUtils.join(copyOptions, COMMA_SPACE);</b>
<b class="nc"><i class="no-highlight">2025</i>&nbsp;            queryBuilder.append(String.format(COPY_OPTIONS_DLP, copyOpts));</b>
<i class="no-highlight">2026</i>&nbsp;        }
<b class="nc"><i class="no-highlight">2027</i>&nbsp;    }</b>
<i class="no-highlight">2028</i>&nbsp;
<i class="no-highlight">2029</i>&nbsp;    private void appendFileFormatOptionsSnowflake() {
<i class="no-highlight">2030</i>&nbsp;        if (!FILE_FORMAT_TYPE_SNOWFLAKE.contains(fileFormatType)) {
<i class="no-highlight">2031</i>&nbsp;            throw new ConfigurationException(ERR_INVALID_FILE_FORMAT_TYPE)
<b class="nc"><i class="no-highlight">2032</i>&nbsp;                    .withReason(REASON_INVALID_FILE_FORMAT_TYPE)</b>
<b class="nc"><i class="no-highlight">2033</i>&nbsp;                    .withResolution(RESOLUTION_INVALID_FILE_FORMAT_TYPE);</b>
<b class="nc"><i class="no-highlight">2034</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2035</i>&nbsp;        if (CollectionUtils.isNotEmpty(fileFormatOptions)) {</b>
<i class="no-highlight">2036</i>&nbsp;            String formatOpts = StringUtils.join(fileFormatOptions, SPACE);
<i class="no-highlight">2037</i>&nbsp;            if (StringUtils.equals(fileFormatType, NONE)) {
<b class="nc"><i class="no-highlight">2038</i>&nbsp;                queryBuilder.append(String.format(FILE_FORMAT_OPTION_WITH_NO_FORMAT_TYPE,</b>
<i class="no-highlight">2039</i>&nbsp;                        formatOpts));
<i class="no-highlight">2040</i>&nbsp;            } else {
<i class="no-highlight">2041</i>&nbsp;                queryBuilder.append(String.format(FILE_FORMAT_OPTION, fileFormatType, formatOpts));
<i class="no-highlight">2042</i>&nbsp;            }
<i class="no-highlight">2043</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">2044</i>&nbsp;            if (!StringUtils.equals(fileFormatType, NONE)) {</b>
<b class="nc"><i class="no-highlight">2045</i>&nbsp;                queryBuilder.append(String.format(FILE_FORMAT, fileFormatType));</b>
<b class="nc"><i class="no-highlight">2046</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2047</i>&nbsp;        }</b>
<i class="no-highlight">2048</i>&nbsp;    }
<b class="nc"><i class="no-highlight">2049</i>&nbsp;</b>
<i class="no-highlight">2050</i>&nbsp;    private void appendFileFormatOptionsRedshift() {
<i class="no-highlight">2051</i>&nbsp;        if (!FILE_FORMAT_TYPE_REDSHIFT.contains(fileFormatType)) {
<i class="no-highlight">2052</i>&nbsp;            throw new ConfigurationException(ERR_INVALID_FILE_FORMAT_TYPE)
<i class="no-highlight">2053</i>&nbsp;                    .withReason(REASON_INVALID_FILE_FORMAT_TYPE)
<b class="nc"><i class="no-highlight">2054</i>&nbsp;                    .withResolution(RESOLUTION_INVALID_FILE_FORMAT_TYPE);</b>
<b class="nc"><i class="no-highlight">2055</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2056</i>&nbsp;        if ((StringUtils.equals(fileFormatType, PARQUET) ||</b>
<i class="no-highlight">2057</i>&nbsp;                StringUtils.equals(fileFormatType, ORC)) &amp;&amp;
<i class="no-highlight">2058</i>&nbsp;                !StringUtils.equals(s3BucketRegion, S3Region.DEFAULT.toString())) {
<i class="no-highlight">2059</i>&nbsp;            throw new ConfigurationException(ERR_INVALID_REGION_PARQUET_ORC)
<b class="nc"><i class="no-highlight">2060</i>&nbsp;                    .withReason(REASON_INVALID_REGION_PARQUET_ORC)</b>
<i class="no-highlight">2061</i>&nbsp;                    .withResolution(RESOLUTION_INVALID_REGION_PARQUET_ORC);
<i class="no-highlight">2062</i>&nbsp;        }
<i class="no-highlight">2063</i>&nbsp;        if (CollectionUtils.isNotEmpty(fileFormatOptions)) {
<i class="no-highlight">2064</i>&nbsp;            String formatOpts = StringUtils.join(fileFormatOptions, SPACE);
<i class="no-highlight">2065</i>&nbsp;            if (StringUtils.equals(fileFormatType, NONE) ||
<i class="no-highlight">2066</i>&nbsp;                    isFileFormatTypeContainedAt(formatOpts)) {
<i class="no-highlight">2067</i>&nbsp;                queryBuilder.append(String.format(APPEND_SPACES_STRING, formatOpts));
<i class="no-highlight">2068</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">2069</i>&nbsp;                appendDefaultFormatOptsRedshift();</b>
<b class="nc"><i class="no-highlight">2070</i>&nbsp;                queryBuilder.append(String.format(APPEND_SPACES_TWO_STRING, fileFormatType,</b>
<b class="nc"><i class="no-highlight">2071</i>&nbsp;                        formatOpts));</b>
<b class="nc"><i class="no-highlight">2072</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2073</i>&nbsp;        } else {</b>
<b class="nc"><i class="no-highlight">2074</i>&nbsp;            if (!StringUtils.equals(fileFormatType, NONE)) {</b>
<b class="nc"><i class="no-highlight">2075</i>&nbsp;                appendDefaultFormatOptsRedshift();</b>
<i class="no-highlight">2076</i>&nbsp;                queryBuilder.append(String.format(APPEND_SPACES_STRING, fileFormatType));
<i class="no-highlight">2077</i>&nbsp;            }
<i class="no-highlight">2078</i>&nbsp;        }
<b class="nc"><i class="no-highlight">2079</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">2080</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2081</i>&nbsp;    private boolean isFileFormatTypeContainedAt(String target) {</b>
<b class="nc"><i class="no-highlight">2082</i>&nbsp;        Pattern pattern = Pattern.compile(getFindRegexStrForFileFormatType(fileFormatType));</b>
<b class="nc"><i class="no-highlight">2083</i>&nbsp;        Matcher matcher = pattern.matcher(target);</b>
<i class="no-highlight">2084</i>&nbsp;        return matcher.find();
<i class="no-highlight">2085</i>&nbsp;    }
<i class="no-highlight">2086</i>&nbsp;
<i class="no-highlight">2087</i>&nbsp;    // Returns &quot;(^JSON\\s)|(\\sJSON\\s)&quot; when the given &quot;fileFormatType&quot;
<b class="nc"><i class="no-highlight">2088</i>&nbsp;    // is &quot;JSON&quot;. This regex string will find &quot;JSON&quot; when JSON is at the beginning</b>
<i class="no-highlight">2089</i>&nbsp;    // or at the middle of the target string and, at the same time,
<i class="no-highlight">2090</i>&nbsp;    // prevent &quot;JSONOPTION
<i class="no-highlight">2091</i>&nbsp;    private String getFindRegexStrForFileFormatType(String fileFormatType) {
<i class="no-highlight">2092</i>&nbsp;        return &quot;(^&quot; + fileFormatType + &quot;\\s)&quot; + &quot;|(\\s&quot; + fileFormatType + &quot;\\s)&quot;;
<i class="no-highlight">2093</i>&nbsp;    }
<b class="nc"><i class="no-highlight">2094</i>&nbsp;</b>
<i class="no-highlight">2095</i>&nbsp;    private void appendDefaultFormatOptsRedshift() {
<b class="nc"><i class="no-highlight">2096</i>&nbsp;        if (StringUtils.equals(fileFormatType, JSON) ||</b>
<b class="nc"><i class="no-highlight">2097</i>&nbsp;                StringUtils.equals(fileFormatType, AVRO)) {</b>
<i class="no-highlight">2098</i>&nbsp;            fileFormatType = String.format(APPEND_SPACES_TWO_STRING, fileFormatType,
<b class="nc"><i class="no-highlight">2099</i>&nbsp;                    DEFAULT_OPTS_JSON_AVRO);</b>
<b class="nc"><i class="no-highlight">2100</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2101</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">2102</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2103</i>&nbsp;    private void appendFileFormatTypeDLP() {</b>
<b class="nc"><i class="no-highlight">2104</i>&nbsp;        if (!FILE_FORMAT_TYPE_DLP.contains(fileFormatType)) {</b>
<i class="no-highlight">2105</i>&nbsp;            throw new ConfigurationException(ERR_INVALID_FILE_FORMAT_TYPE)
<b class="nc"><i class="no-highlight">2106</i>&nbsp;                    .withReason(REASON_INVALID_FILE_FORMAT_TYPE)</b>
<i class="no-highlight">2107</i>&nbsp;                    .withResolution(RESOLUTION_INVALID_FILE_FORMAT_TYPE);
<b class="nc"><i class="no-highlight">2108</i>&nbsp;        }</b>
<i class="no-highlight">2109</i>&nbsp;
<b class="nc"><i class="no-highlight">2110</i>&nbsp;        if (!StringUtils.equals(fileFormatType, NONE)) {</b>
<i class="no-highlight">2111</i>&nbsp;            queryBuilder.append(String.format(FILE_FORMAT_DLP, fileFormatType));
<b class="nc"><i class="no-highlight">2112</i>&nbsp;        }</b>
<i class="no-highlight">2113</i>&nbsp;    }
<i class="no-highlight">2114</i>&nbsp;
<b class="nc"><i class="no-highlight">2115</i>&nbsp;    private void appendFileFormatOptionsDLP() {</b>
<b class="nc"><i class="no-highlight">2116</i>&nbsp;        if (CollectionUtils.isNotEmpty(fileFormatOptions)) {</b>
<i class="no-highlight">2117</i>&nbsp;            String formatOpts = StringUtils.join(fileFormatOptions, COMMA_SPACE);
<b class="nc"><i class="no-highlight">2118</i>&nbsp;            queryBuilder.append(String.format(FILE_FORMAT_OPTIONS_DLP, formatOpts));</b>
<i class="no-highlight">2119</i>&nbsp;        }
<b class="nc"><i class="no-highlight">2120</i>&nbsp;    }</b>
<i class="no-highlight">2121</i>&nbsp;
<i class="no-highlight">2122</i>&nbsp;    private void buildingCopyCommandForAws() {
<i class="no-highlight">2123</i>&nbsp;        if (StringUtils.isNotBlank(cloudStorageLocation)) {
<i class="no-highlight">2124</i>&nbsp;            filePathStage = cloudStorageLocation;
<i class="no-highlight">2125</i>&nbsp;        } else if (StringUtils.isBlank(s3Folder)) {
<i class="no-highlight">2126</i>&nbsp;            filePathStage = String.format(S3_FILE_KEY_FULL_PATH_NO_FOLDER, s3Bucket);
<i class="no-highlight">2127</i>&nbsp;        } else {
<i class="no-highlight">2128</i>&nbsp;            filePathStage = String.format(S3_FILE_KEY_FULL_PATH, s3Bucket, s3Folder);
<i class="no-highlight">2129</i>&nbsp;        }
<i class="no-highlight">2130</i>&nbsp;    }
<i class="no-highlight">2131</i>&nbsp;
<b class="nc"><i class="no-highlight">2132</i>&nbsp;    private void buildingCopyCommandForAzure() {</b>
<i class="no-highlight">2133</i>&nbsp;        if (StringUtils.isNotBlank(cloudStorageLocation)) {
<i class="no-highlight">2134</i>&nbsp;            filePathStage = cloudStorageLocation;
<i class="no-highlight">2135</i>&nbsp;        } else if (StringUtils.isBlank(azureFolder)) {
<i class="no-highlight">2136</i>&nbsp;            filePathStage = String.format(AZURE_CONTAINER_PATH_ONLY, azureAccountName,
<i class="no-highlight">2137</i>&nbsp;                    azureContainer);
<i class="no-highlight">2138</i>&nbsp;        } else {
<i class="no-highlight">2139</i>&nbsp;            filePathStage = String.format(AZURE_CONTAINER_WITH_FOLDER, azureAccountName,
<i class="no-highlight">2140</i>&nbsp;                    azureContainer, azureFolder);
<b class="nc"><i class="no-highlight">2141</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2142</i>&nbsp;    }</b>
<i class="no-highlight">2143</i>&nbsp;
<b class="nc"><i class="no-highlight">2144</i>&nbsp;    private void buildingCopyCommandForGCS(String protocol) {</b>
<i class="no-highlight">2145</i>&nbsp;        if (StringUtils.isNotBlank(cloudStorageLocation)) {
<b class="nc"><i class="no-highlight">2146</i>&nbsp;            filePathStage = cloudStorageLocation;</b>
<i class="no-highlight">2147</i>&nbsp;        } else if (StringUtils.isBlank(gcsFolder)) {
<i class="no-highlight">2148</i>&nbsp;            filePathStage = String.format(GCS_FILE_KEY_FULL_PATH_NO_FOLDER, protocol, gcsBucket);
<i class="no-highlight">2149</i>&nbsp;        } else {
<i class="no-highlight">2150</i>&nbsp;            filePathStage = String.format(GCS_FILE_KEY_FULL_PATH, protocol, gcsBucket, gcsFolder);
<b class="nc"><i class="no-highlight">2151</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2152</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">2153</i>&nbsp;</b>
<i class="no-highlight">2154</i>&nbsp;    private void buildingCopyCommandForDBFSFolderPath() {
<b class="nc"><i class="no-highlight">2155</i>&nbsp;        filePathStage = StringUtils.isNotBlank(cloudStorageLocation)</b>
<b class="nc"><i class="no-highlight">2156</i>&nbsp;                ? cloudStorageLocation</b>
<i class="no-highlight">2157</i>&nbsp;                : dbfsFolder;
<b class="nc"><i class="no-highlight">2158</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">2159</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2160</i>&nbsp;    private void appendStageFilePathWithProvidedColumnsSnowflake() {</b>
<b class="nc"><i class="no-highlight">2161</i>&nbsp;        createTableIfNotExistsWithSchemaInference();</b>
<b class="nc"><i class="no-highlight">2162</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2163</i>&nbsp;        validateColumnMappingMap();</b>
<b class="nc"><i class="no-highlight">2164</i>&nbsp;        if (needTransformationPreaction &amp;&amp; isSemiStructuredFileTypeSnowflake()) {</b>
<i class="no-highlight">2165</i>&nbsp;            // For this case, we perform two step transformations: first,
<b class="nc"><i class="no-highlight">2166</i>&nbsp;            // create and load a semi-structured data file into a new staged table</b>
<b class="nc"><i class="no-highlight">2167</i>&nbsp;            // with one VARIANT column, second insert select with transformations.</b>
<b class="nc"><i class="no-highlight">2168</i>&nbsp;            isSnowflakeTransformPreprocessingRequired = true;</b>
<b class="nc"><i class="no-highlight">2169</i>&nbsp;            // Create staged table for first step COPY INTo</b>
<i class="no-highlight">2170</i>&nbsp;            executeCreateStagedTableSnowflake();
<i class="no-highlight">2171</i>&nbsp;        }
<i class="no-highlight">2172</i>&nbsp;
<i class="no-highlight">2173</i>&nbsp;        /*
<b class="nc"><i class="no-highlight">2174</i>&nbsp;         * For Snowflake DB:</b>
<i class="no-highlight">2175</i>&nbsp;         * VALIDATION_MODE does not support COPY statements that transform data during a load.
<i class="no-highlight">2176</i>&nbsp;         * If the parameter is specified, the COPY statement returns an error, so we should not
<i class="no-highlight">2177</i>&nbsp;         * use the COPY statement which does the data transformation during pipeline validation,
<i class="no-highlight">2178</i>&nbsp;         * as we are appending VALIDATION_MODE during the same.
<i class="no-highlight">2179</i>&nbsp;         */
<b class="nc"><i class="no-highlight">2180</i>&nbsp;        if (!isSnowflakeTransformPreprocessingRequired &amp;&amp; isExecutionInProgress()) {</b>
<b class="nc"><i class="no-highlight">2181</i>&nbsp;            if ((StringUtils.equals(loadAction, APPEND_ROWS_TABLE) ||</b>
<b class="nc"><i class="no-highlight">2182</i>&nbsp;                    StringUtils.equals(loadAction, OVERWRITE_TABLE)) &amp;&amp;</b>
<b class="nc"><i class="no-highlight">2183</i>&nbsp;                    MapUtils.isNotEmpty(this.columnMappingMap)) {</b>
<i class="no-highlight">2184</i>&nbsp;                String headerColumns = StringUtils.join(
<b class="nc"><i class="no-highlight">2185</i>&nbsp;                        this.columnMappingMap.keySet(), COMMA);</b>
<i class="no-highlight">2186</i>&nbsp;                queryBuilder.append(String.format(
<b class="nc"><i class="no-highlight">2187</i>&nbsp;                        COPY_FROM_STAGED_FILE_COMMAND_WITH_DATA_TRANSFORMATION_SNOWFLAKE,</b>
<b class="nc"><i class="no-highlight">2188</i>&nbsp;                        targetTablePath, headerColumns, filePathStage));</b>
<i class="no-highlight">2189</i>&nbsp;                return;
<b class="nc"><i class="no-highlight">2190</i>&nbsp;            } else if (StringUtils.equals(loadAction, DROP_CREATE_TABLE) &amp;&amp;</b>
<b class="nc"><i class="no-highlight">2191</i>&nbsp;                    CollectionUtils.isNotEmpty(this.targetColumns) &amp;&amp;</b>
<i class="no-highlight">2192</i>&nbsp;                    MapUtils.isNotEmpty(this.columnMappingMap)) {
<b class="nc"><i class="no-highlight">2193</i>&nbsp;                appendStageFilePathWithNonEmptyColumnsWithMapSnowflake();</b>
<b class="nc"><i class="no-highlight">2194</i>&nbsp;                return;</b>
<i class="no-highlight">2195</i>&nbsp;            }
<i class="no-highlight">2196</i>&nbsp;        }
<b class="nc"><i class="no-highlight">2197</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2198</i>&nbsp;        queryBuilder.append(String.format(</b>
<b class="nc"><i class="no-highlight">2199</i>&nbsp;                COPY_FROM_STAGED_FILE_COMMAND_SNOWFLAKE,</b>
<i class="no-highlight">2200</i>&nbsp;                isCreatedStagedTable ? stagedTablePath : targetTablePath, filePathStage));
<i class="no-highlight">2201</i>&nbsp;    }
<b class="nc"><i class="no-highlight">2202</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2203</i>&nbsp;    private void appendStageFilePathWithNonEmptyColumnsWithMapSnowflake() {</b>
<i class="no-highlight">2204</i>&nbsp;        trimListEntries(targetColumns);
<b class="nc"><i class="no-highlight">2205</i>&nbsp;</b>
<i class="no-highlight">2206</i>&nbsp;        Set&lt;String&gt; targetTableColumns =
<i class="no-highlight">2207</i>&nbsp;                new HashSet&lt;&gt;(this.columnMappingMap.keySet());
<i class="no-highlight">2208</i>&nbsp;
<i class="no-highlight">2209</i>&nbsp;        StringBuilder targetColumnsBuilder = new StringBuilder();
<b class="nc"><i class="no-highlight">2210</i>&nbsp;        boolean firstEntry = true;</b>
<b class="nc"><i class="no-highlight">2211</i>&nbsp;        for (String targetColName : this.targetColumns) {</b>
<i class="no-highlight">2212</i>&nbsp;            if (targetTableColumns.contains(targetColName)) {
<i class="no-highlight">2213</i>&nbsp;                if (firstEntry) {
<i class="no-highlight">2214</i>&nbsp;                    firstEntry = false;
<i class="no-highlight">2215</i>&nbsp;                } else {
<i class="no-highlight">2216</i>&nbsp;                    targetColumnsBuilder.append(COMMA);
<i class="no-highlight">2217</i>&nbsp;                }
<b class="nc"><i class="no-highlight">2218</i>&nbsp;                targetColumnsBuilder.append(targetColName);</b>
<i class="no-highlight">2219</i>&nbsp;            }
<i class="no-highlight">2220</i>&nbsp;        }
<i class="no-highlight">2221</i>&nbsp;
<i class="no-highlight">2222</i>&nbsp;        if (needTransformationPreaction) {
<i class="no-highlight">2223</i>&nbsp;            // Create an external stage for the external storage bucket
<i class="no-highlight">2224</i>&nbsp;            // if &quot;needTransformationPreaction&quot; is true.
<i class="no-highlight">2225</i>&nbsp;            executeCreateExternalStageSnowflake(false);
<i class="no-highlight">2226</i>&nbsp;            appendStageNameWithMapSourceColumnListSnowflake(targetColumnsBuilder);
<i class="no-highlight">2227</i>&nbsp;        } else {
<i class="no-highlight">2228</i>&nbsp;            queryBuilder.append(String.format(
<i class="no-highlight">2229</i>&nbsp;                    COPY_FROM_STAGED_FILE_COMMAND_WITH_DATA_TRANSFORMATION_SNOWFLAKE,
<i class="no-highlight">2230</i>&nbsp;                    targetTablePath, targetColumnsBuilder.toString(), filePathStage));
<i class="no-highlight">2231</i>&nbsp;        }
<i class="no-highlight">2232</i>&nbsp;    }
<i class="no-highlight">2233</i>&nbsp;
<i class="no-highlight">2234</i>&nbsp;    /**
<i class="no-highlight">2235</i>&nbsp;     * Append COPY INTO SQL with source column list from the
<i class="no-highlight">2236</i>&nbsp;     * &quot;columnMappingmap&quot; to &quot;this.queryBuilder&quot;.
<i class="no-highlight">2237</i>&nbsp;     *
<i class="no-highlight">2238</i>&nbsp;     * @param targetColumnsBuilder
<i class="no-highlight">2239</i>&nbsp;     */
<i class="no-highlight">2240</i>&nbsp;    private void appendStageNameWithMapSourceColumnListSnowflake(
<i class="no-highlight">2241</i>&nbsp;            StringBuilder targetColumnsBuilder) {
<i class="no-highlight">2242</i>&nbsp;        appendStageNameWithMapSourceColumnListSnowflake(
<i class="no-highlight">2243</i>&nbsp;                this.queryBuilder,
<i class="no-highlight">2244</i>&nbsp;                targetColumnsBuilder);
<i class="no-highlight">2245</i>&nbsp;    }
<b class="nc"><i class="no-highlight">2246</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2247</i>&nbsp;    private void appendStageNameWithMapSourceColumnListSnowflake(</b>
<i class="no-highlight">2248</i>&nbsp;            StringBuilder queryBuilderForSingleFile,
<b class="nc"><i class="no-highlight">2249</i>&nbsp;            StringBuilder targetColumnsBuilder) {</b>
<b class="nc"><i class="no-highlight">2250</i>&nbsp;        // Build source column name list from the map in target table column order</b>
<b class="nc"><i class="no-highlight">2251</i>&nbsp;        String selectSQLStringForSourceStage =</b>
<b class="nc"><i class="no-highlight">2252</i>&nbsp;                buildSelectSQLStringForSourceStage(this.externalStageName);</b>
<i class="no-highlight">2253</i>&nbsp;
<b class="nc"><i class="no-highlight">2254</i>&nbsp;        queryBuilderForSingleFile.append(String.format(</b>
<i class="no-highlight">2255</i>&nbsp;                COPY_FROM_STAGED_FILE_WITH_TRANSFORMATION_SOURCE_LIST_SNOWFLAKE,
<b class="nc"><i class="no-highlight">2256</i>&nbsp;                targetTablePath, targetColumnsBuilder.toString(), selectSQLStringForSourceStage));</b>
<b class="nc"><i class="no-highlight">2257</i>&nbsp;    }</b>
<i class="no-highlight">2258</i>&nbsp;
<i class="no-highlight">2259</i>&nbsp;    private void executeCreateStagedTableSnowflake() {
<i class="no-highlight">2260</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">2261</i>&nbsp;            stagedTablePath = getStagedFQTablePath(targetTablePath);</b>
<i class="no-highlight">2262</i>&nbsp;            sqlCreateStagedTable = buildCreateTableSql(stagedTablePath,
<i class="no-highlight">2263</i>&nbsp;                    List.of(VARIANT_COL1), List.of(VARIANT_TYPE));
<i class="no-highlight">2264</i>&nbsp;            executedQueries.add(sqlCreateStagedTable);
<i class="no-highlight">2265</i>&nbsp;            statistic.addQueryStatistic(
<i class="no-highlight">2266</i>&nbsp;                    new QueryStatisticHolderBuilder(sqlCreateStagedTable).build());
<b class="nc"><i class="no-highlight">2267</i>&nbsp;            executeSqlStmt(sqlCreateStagedTable, bindValues, account);</b>
<i class="no-highlight">2268</i>&nbsp;            isCreatedStagedTable = true;
<i class="no-highlight">2269</i>&nbsp;        } catch (Exception e) {
<i class="no-highlight">2270</i>&nbsp;            handleFailures(ERR_BULK_LOAD);
<i class="no-highlight">2271</i>&nbsp;            if (e instanceof ConfigurationException) {
<i class="no-highlight">2272</i>&nbsp;                throw ((ConfigurationException) e);
<i class="no-highlight">2273</i>&nbsp;            }
<i class="no-highlight">2274</i>&nbsp;            throw new SnapDataException(e, ERR_LOAD_ACTION_BULK_LOAD)
<i class="no-highlight">2275</i>&nbsp;                    .withReason(e.getMessage())
<i class="no-highlight">2276</i>&nbsp;                    .withResolution(RESOLUTION_BULK_LOAD);
<i class="no-highlight">2277</i>&nbsp;        }
<i class="no-highlight">2278</i>&nbsp;    }
<i class="no-highlight">2279</i>&nbsp;
<b class="nc"><i class="no-highlight">2280</i>&nbsp;    private void executeCreateExternalStageSnowflake(boolean isThisForSchemaInference) {</b>
<b class="nc"><i class="no-highlight">2281</i>&nbsp;        try {</b>
<b class="nc"><i class="no-highlight">2282</i>&nbsp;            this.externalStageName =</b>
<b class="nc"><i class="no-highlight">2283</i>&nbsp;                    getFullyQualifiedStageName(</b>
<i class="no-highlight">2284</i>&nbsp;                            EltUtils.getExternalStageName(),
<i class="no-highlight">2285</i>&nbsp;                            this.databaseName);
<b class="nc"><i class="no-highlight">2286</i>&nbsp;            this.sqlCreateStage =</b>
<b class="nc"><i class="no-highlight">2287</i>&nbsp;                    buildCreateExternalStageSql(</b>
<i class="no-highlight">2288</i>&nbsp;                            this.externalStageName, isThisForSchemaInference);
<b class="nc"><i class="no-highlight">2289</i>&nbsp;            executedQueries.add(sqlCreateStage);</b>
<i class="no-highlight">2290</i>&nbsp;            executeSqlStmt(this.sqlCreateStage, bindValues, account);
<i class="no-highlight">2291</i>&nbsp;            isCreatedExternalStage = true;
<i class="no-highlight">2292</i>&nbsp;        } catch (Exception e) {
<b class="nc"><i class="no-highlight">2293</i>&nbsp;            handleFailures(ERR_BULK_LOAD);</b>
<b class="nc"><i class="no-highlight">2294</i>&nbsp;            if (e instanceof ConfigurationException) {</b>
<b class="nc"><i class="no-highlight">2295</i>&nbsp;                throw ((ConfigurationException) e);</b>
<b class="nc"><i class="no-highlight">2296</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2297</i>&nbsp;            throw new SnapDataException(e, ERR_LOAD_ACTION_BULK_LOAD)</b>
<b class="nc"><i class="no-highlight">2298</i>&nbsp;                    .withReason(e.getMessage())</b>
<b class="nc"><i class="no-highlight">2299</i>&nbsp;                    .withResolution(RESOLUTION_BULK_LOAD);</b>
<b class="nc"><i class="no-highlight">2300</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2301</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">2302</i>&nbsp;</b>
<i class="no-highlight">2303</i>&nbsp;    @VisibleForTesting
<i class="no-highlight">2304</i>&nbsp;    String getFullyQualifiedStageName(String stageName, String dbName) {
<b class="nc"><i class="no-highlight">2305</i>&nbsp;        return String.format(STAGE_WITH_DB_SCHEMA_NAME_SQL, dbName, this.schemaName,</b>
<b class="nc"><i class="no-highlight">2306</i>&nbsp;                stageName);</b>
<b class="nc"><i class="no-highlight">2307</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">2308</i>&nbsp;</b>
<i class="no-highlight">2309</i>&nbsp;    private String buildCreateExternalStageSql(
<b class="nc"><i class="no-highlight">2310</i>&nbsp;            String stageName, boolean isThisForSchemaInference) {</b>
<b class="nc"><i class="no-highlight">2311</i>&nbsp;        String sourceLocation = eltDatabaseAccount.getSourceLocation();</b>
<b class="nc"><i class="no-highlight">2312</i>&nbsp;        String credentialsString = EMPTY_STRING;</b>
<b class="nc"><i class="no-highlight">2313</i>&nbsp;        String sqlExternalCreateStage = EMPTY_STRING;</b>
<b class="nc"><i class="no-highlight">2314</i>&nbsp;        String fileStagePath = getFileStagePathSnowflake();</b>
<b class="nc"><i class="no-highlight">2315</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2316</i>&nbsp;        switch (sourceLocation) {</b>
<i class="no-highlight">2317</i>&nbsp;            case AMAZON_S3:
<i class="no-highlight">2318</i>&nbsp;                credentialsString = buildS3CredentialsForSnowFlake();
<i class="no-highlight">2319</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">2320</i>&nbsp;            case AZURE:</b>
<b class="nc"><i class="no-highlight">2321</i>&nbsp;                credentialsString = buildAzureCredentialsForSnowflake();</b>
<i class="no-highlight">2322</i>&nbsp;                break;
<i class="no-highlight">2323</i>&nbsp;            case GOOGLE_CLOUD_STORAGE:
<b class="nc"><i class="no-highlight">2324</i>&nbsp;                credentialsString = buildGcsCredentialsForSnowflake();</b>
<i class="no-highlight">2325</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">2326</i>&nbsp;            case NONE:</b>
<b class="nc"><i class="no-highlight">2327</i>&nbsp;            default:</b>
<b class="nc"><i class="no-highlight">2328</i>&nbsp;                throw new ConfigurationException(ERR_BLANK_SOURCE_LOCATION)</b>
<b class="nc"><i class="no-highlight">2329</i>&nbsp;                        .withReason(REASON_BLANK_SOURCE_LOCATION)</b>
<i class="no-highlight">2330</i>&nbsp;                        .withResolution(RESOLUTION_BLANK_SOURCE_LOCATION);
<b class="nc"><i class="no-highlight">2331</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2332</i>&nbsp;</b>
<i class="no-highlight">2333</i>&nbsp;        if (isThisForSchemaInference) {
<b class="nc"><i class="no-highlight">2334</i>&nbsp;            String fileFormat = String.format(FILE_FORMAT_SNOWFLAKE,</b>
<i class="no-highlight">2335</i>&nbsp;                    fileFormatNameForExternalStage);
<b class="nc"><i class="no-highlight">2336</i>&nbsp;            sqlExternalCreateStage = buildSqlExternalCreateStageForSchemaInference(</b>
<i class="no-highlight">2337</i>&nbsp;                    stageName,
<b class="nc"><i class="no-highlight">2338</i>&nbsp;                    fileStagePath,</b>
<b class="nc"><i class="no-highlight">2339</i>&nbsp;                    credentialsString,</b>
<b class="nc"><i class="no-highlight">2340</i>&nbsp;                    fileFormat);</b>
<b class="nc"><i class="no-highlight">2341</i>&nbsp;        } else {</b>
<b class="nc"><i class="no-highlight">2342</i>&nbsp;            sqlExternalCreateStage = String.format(</b>
<i class="no-highlight">2343</i>&nbsp;                    CREATE_EXTERNAL_STAGE_OBJECT_SNOWFLAKE,
<b class="nc"><i class="no-highlight">2344</i>&nbsp;                    stageName,</b>
<b class="nc"><i class="no-highlight">2345</i>&nbsp;                    fileStagePath,</b>
<i class="no-highlight">2346</i>&nbsp;                    credentialsString);
<i class="no-highlight">2347</i>&nbsp;        }
<b class="nc"><i class="no-highlight">2348</i>&nbsp;</b>
<i class="no-highlight">2349</i>&nbsp;        return sqlExternalCreateStage;
<i class="no-highlight">2350</i>&nbsp;    }
<b class="nc"><i class="no-highlight">2351</i>&nbsp;</b>
<i class="no-highlight">2352</i>&nbsp;    /**
<b class="nc"><i class="no-highlight">2353</i>&nbsp;     * This function builds CREATE STAGE SQL statements</b>
<b class="nc"><i class="no-highlight">2354</i>&nbsp;     * for Automatic Schema Inference when Storage Integration auth type</b>
<b class="nc"><i class="no-highlight">2355</i>&nbsp;     * if used for Snowflake CDW.</b>
<b class="nc"><i class="no-highlight">2356</i>&nbsp;     *</b>
<i class="no-highlight">2357</i>&nbsp;     * Note that for the case of CSV file type,
<b class="nc"><i class="no-highlight">2358</i>&nbsp;     * FIELD_DELIMITER format type option uses a different field delimiter</b>
<b class="nc"><i class="no-highlight">2359</i>&nbsp;     * from the field delimiter used inside the input file</b>
<b class="nc"><i class="no-highlight">2360</i>&nbsp;     * so that one column returns for each record in the input file.</b>
<i class="no-highlight">2361</i>&nbsp;     * For example,
<b class="nc"><i class="no-highlight">2362</i>&nbsp;     * when a CSV input file has &quot;c1|c2|c3|c4|c5|c6|c7&quot; as header with field_delimiter being &#39;|&#39;,</b>
<b class="nc"><i class="no-highlight">2363</i>&nbsp;     * this function creates a format type option with</b>
<i class="no-highlight">2364</i>&nbsp;     * &quot; FILE_FORMAT = (TYPE = CSV FIELD_DELIMITER = &#39;,&#39; )
<b class="nc"><i class="no-highlight">2365</i>&nbsp;     * so that SELECT SQL to the input file thinks each record as one column.</b>
<i class="no-highlight">2366</i>&nbsp;     *
<i class="no-highlight">2367</i>&nbsp;     * Thus the corresponding CREATE STAGE SQL will be
<b class="nc"><i class="no-highlight">2368</i>&nbsp;     * &quot;CREATE OR REPLACE STAGE BIGDATAQA.TEST_DATA.extstage_e8f32fc5_&quot; +</b>
<b class="nc"><i class="no-highlight">2369</i>&nbsp;     * &quot;0d05_4d0b_85c4_64d90c38480e &quot; +</b>
<b class="nc"><i class="no-highlight">2370</i>&nbsp;     * &quot;url=&#39;azure://adlsgen2v02.blob.core.windows.net/sl-bigdata-qa/test_data/&#39;</b>
<i class="no-highlight">2371</i>&nbsp;     * STORAGE_INTEGRATION = tony_elt_azure_wasb_adlsg2_storage_integration_1 &quot; +
<i class="no-highlight">2372</i>&nbsp;     * &quot;FILE_FORMAT = ( TYPE = CSV FIELD_DELIMITER = &#39;,&#39; )&quot;
<b class="nc"><i class="no-highlight">2373</i>&nbsp;     */</b>
<i class="no-highlight">2374</i>&nbsp;    private String buildSqlExternalCreateStageForSchemaInference(
<i class="no-highlight">2375</i>&nbsp;            String stageName, String fileStagePath,
<i class="no-highlight">2376</i>&nbsp;            String credentialsString, String fileFormat) {
<b class="nc"><i class="no-highlight">2377</i>&nbsp;        String sqlExternalCreateStage = EMPTY_STRING;</b>
<b class="nc"><i class="no-highlight">2378</i>&nbsp;        String formatTypeOptions = EMPTY_STRING;</b>
<b class="nc"><i class="no-highlight">2379</i>&nbsp;</b>
<i class="no-highlight">2380</i>&nbsp;        verifyFileStagePathFromStorageIntegration(fileStagePath);
<b class="nc"><i class="no-highlight">2381</i>&nbsp;        if (StringUtils.equalsIgnoreCase(fileFormatType, CSV)) {</b>
<b class="nc"><i class="no-highlight">2382</i>&nbsp;            char delimiterForFileFormat = fieldDelimiter == PIPE ? COMMA : PIPE;</b>
<b class="nc"><i class="no-highlight">2383</i>&nbsp;            formatTypeOptions = String.format(</b>
<b class="nc"><i class="no-highlight">2384</i>&nbsp;                    CSV_FORMAT_TYPE_OPTIONS_FOR_CREATE_EXTERNAL_STAGE,</b>
<b class="nc"><i class="no-highlight">2385</i>&nbsp;                    delimiterForFileFormat);</b>
<i class="no-highlight">2386</i>&nbsp;
<b class="nc"><i class="no-highlight">2387</i>&nbsp;        } else {</b>
<i class="no-highlight">2388</i>&nbsp;            formatTypeOptions = String.format(
<i class="no-highlight">2389</i>&nbsp;                    NONCSV_FORMAT_TYPE_OPTIONS_FOR_CREATE_EXTERNAL_STAGE,
<i class="no-highlight">2390</i>&nbsp;                    fileFormatType);
<b class="nc"><i class="no-highlight">2391</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2392</i>&nbsp;        sqlExternalCreateStage = String.format(</b>
<b class="nc"><i class="no-highlight">2393</i>&nbsp;                CREATE_EXTERNAL_STAGE_FOR_SCHEMA_INFERENCE_SNOWFLAKE,</b>
<i class="no-highlight">2394</i>&nbsp;                stageName,
<b class="nc"><i class="no-highlight">2395</i>&nbsp;                fileStagePath,</b>
<i class="no-highlight">2396</i>&nbsp;                credentialsString,
<i class="no-highlight">2397</i>&nbsp;                formatTypeOptions);
<b class="nc"><i class="no-highlight">2398</i>&nbsp;        return sqlExternalCreateStage;</b>
<b class="nc"><i class="no-highlight">2399</i>&nbsp;    }</b>
<i class="no-highlight">2400</i>&nbsp;
<i class="no-highlight">2401</i>&nbsp;    /**
<i class="no-highlight">2402</i>&nbsp;     * Verify that &quot;fileStagePath&quot; for the current ELT Load has a prefix
<b class="nc"><i class="no-highlight">2403</i>&nbsp;     * entry from the STORAGE_ALLOWED_LOCATIONS list of the current</b>
<b class="nc"><i class="no-highlight">2404</i>&nbsp;     * &quot;storageIntegration&quot;.</b>
<i class="no-highlight">2405</i>&nbsp;     * If yes, return true.
<b class="nc"><i class="no-highlight">2406</i>&nbsp;     *</b>
<i class="no-highlight">2407</i>&nbsp;     * @param fileStagePath ELT Load fileStagePath
<b class="nc"><i class="no-highlight">2408</i>&nbsp;     * @return  true if there is a prefix of &quot;fileStagePath&quot; in the list</b>
<b class="nc"><i class="no-highlight">2409</i>&nbsp;     */</b>
<i class="no-highlight">2410</i>&nbsp;    private boolean verifyFileStagePathFromStorageIntegration(String fileStagePath) {
<b class="nc"><i class="no-highlight">2411</i>&nbsp;        String[] locations = StringUtils.split(getStorageAllowedLocations(), &quot;&quot; + COMMA);</b>
<b class="nc"><i class="no-highlight">2412</i>&nbsp;        for (String location : locations) {</b>
<b class="nc"><i class="no-highlight">2413</i>&nbsp;            if (0 == StringUtils.indexOf(fileStagePath, location)) {</b>
<i class="no-highlight">2414</i>&nbsp;                return true;
<i class="no-highlight">2415</i>&nbsp;            }
<b class="nc"><i class="no-highlight">2416</i>&nbsp;        }</b>
<i class="no-highlight">2417</i>&nbsp;        throw new ConfigurationException(ERR_INVALID_STORAGE_INTEGRATION_LOCATIONS)
<i class="no-highlight">2418</i>&nbsp;                .withReason(String.format(REASON_INVALID_STORAGE_INTEGRATION_LOCATIONS,
<b class="nc"><i class="no-highlight">2419</i>&nbsp;                        storageIntegration, fileStagePath))</b>
<b class="nc"><i class="no-highlight">2420</i>&nbsp;                .withResolution(RESOLUTION_INVALID_STORAGE_INTEGRATION_LOCATIONS);</b>
<i class="no-highlight">2421</i>&nbsp;    }
<b class="nc"><i class="no-highlight">2422</i>&nbsp;</b>
<i class="no-highlight">2423</i>&nbsp;    private String getStorageAllowedLocations() {
<i class="no-highlight">2424</i>&nbsp;        dbConnection = jdbcOperations.acquireConnection(account);
<i class="no-highlight">2425</i>&nbsp;        String checkIntegrationProperties =
<b class="nc"><i class="no-highlight">2426</i>&nbsp;                String.format(DESCRIBE_STORAGE_INTEGRATION, storageIntegration);</b>
<b class="nc"><i class="no-highlight">2427</i>&nbsp;        String allowedLocationsStr = EMPTY_STRING;</b>
<i class="no-highlight">2428</i>&nbsp;        try (PreparedStatement stmt = dbConnection.prepareStatement(checkIntegrationProperties)) {
<i class="no-highlight">2429</i>&nbsp;            try (ResultSet resultSet = stmt.executeQuery()) {
<i class="no-highlight">2430</i>&nbsp;                while (resultSet.next()) {
<i class="no-highlight">2431</i>&nbsp;                    if (StringUtils.equalsIgnoreCase(
<i class="no-highlight">2432</i>&nbsp;                            &quot;STORAGE_ALLOWED_LOCATIONS&quot;, resultSet.getString(&quot;property&quot;))) {
<i class="no-highlight">2433</i>&nbsp;                        allowedLocationsStr = resultSet.getString(&quot;property_value&quot;);
<i class="no-highlight">2434</i>&nbsp;                    }
<i class="no-highlight">2435</i>&nbsp;                }
<i class="no-highlight">2436</i>&nbsp;                if (StringUtils.isBlank(allowedLocationsStr)) {
<i class="no-highlight">2437</i>&nbsp;                    throw new SnapDataException(String
<b class="nc"><i class="no-highlight">2438</i>&nbsp;                            .format(ERR_DESCRIBE_TABLE_EXTENDED, tableName))</b>
<i class="no-highlight">2439</i>&nbsp;                            .withResolution(RESOLUTION_BULK_LOAD);
<b class="nc"><i class="no-highlight">2440</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">2441</i>&nbsp;            }</b>
<i class="no-highlight">2442</i>&nbsp;        } catch (SQLException e) {
<i class="no-highlight">2443</i>&nbsp;            throw new SnapDataException(e, String.format(ERR_DESCRIBE_TABLE_EXTENDED, tableName))
<i class="no-highlight">2444</i>&nbsp;                    .withReason(e.getMessage())
<b class="nc"><i class="no-highlight">2445</i>&nbsp;                    .withResolution(RESOLUTION_BULK_LOAD);</b>
<b class="nc"><i class="no-highlight">2446</i>&nbsp;        }</b>
<i class="no-highlight">2447</i>&nbsp;        return allowedLocationsStr;
<b class="nc"><i class="no-highlight">2448</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">2449</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2450</i>&nbsp;    private String getFileStagePathSnowflake() {</b>
<b class="nc"><i class="no-highlight">2451</i>&nbsp;        String sourceLocation = eltDatabaseAccount.getSourceLocation();</b>
<b class="nc"><i class="no-highlight">2452</i>&nbsp;        String fileStagePath = EMPTY_STRING;</b>
<i class="no-highlight">2453</i>&nbsp;
<i class="no-highlight">2454</i>&nbsp;
<b class="nc"><i class="no-highlight">2455</i>&nbsp;        switch (sourceLocation) {</b>
<b class="nc"><i class="no-highlight">2456</i>&nbsp;            case AMAZON_S3:</b>
<i class="no-highlight">2457</i>&nbsp;                if (StringUtils.isBlank(s3Bucket)) {
<i class="no-highlight">2458</i>&nbsp;                    throw new ConfigurationException(ERR_BLANK_S3BUCKET)
<i class="no-highlight">2459</i>&nbsp;                            .withReason(REASON_BLANK_S3BUCKET)
<b class="nc"><i class="no-highlight">2460</i>&nbsp;                            .withResolution(RESOLUTION_BLANK_S3BUCKET);</b>
<b class="nc"><i class="no-highlight">2461</i>&nbsp;                }</b>
<i class="no-highlight">2462</i>&nbsp;                if (StringUtils.isBlank(s3Folder)) {
<i class="no-highlight">2463</i>&nbsp;                    fileStagePath = String.format(S3_FILE_KEY_FULL_PATH_NO_FOLDER, s3Bucket);
<b class="nc"><i class="no-highlight">2464</i>&nbsp;                } else {</b>
<i class="no-highlight">2465</i>&nbsp;                    fileStagePath = String.format(S3_FILE_KEY_FULL_PATH, s3Bucket, s3Folder);
<b class="nc"><i class="no-highlight">2466</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">2467</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">2468</i>&nbsp;            case AZURE:</b>
<b class="nc"><i class="no-highlight">2469</i>&nbsp;                if (StringUtils.isBlank(azureAccountName) ||</b>
<b class="nc"><i class="no-highlight">2470</i>&nbsp;                        StringUtils.isBlank(azureContainer)) {</b>
<b class="nc"><i class="no-highlight">2471</i>&nbsp;                    throw new ConfigurationException(ERR_BLANK_ACCOUNT_NAME_OR_CONTAINER)</b>
<b class="nc"><i class="no-highlight">2472</i>&nbsp;                            .withReason(REASON_BLANK_ACCOUNT_NAME_OR_CONTAINER)</b>
<b class="nc"><i class="no-highlight">2473</i>&nbsp;                            .withResolution(RESOLUTION_BLANK_ACCOUNT_NAME_OR_CONTAINER);</b>
<b class="nc"><i class="no-highlight">2474</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">2475</i>&nbsp;                if (StringUtils.isBlank(azureFolder)) {</b>
<b class="nc"><i class="no-highlight">2476</i>&nbsp;                    fileStagePath = String.format(AZURE_CONTAINER_PATH_ONLY, azureAccountName,</b>
<b class="nc"><i class="no-highlight">2477</i>&nbsp;                            azureContainer);</b>
<b class="nc"><i class="no-highlight">2478</i>&nbsp;                } else {</b>
<i class="no-highlight">2479</i>&nbsp;                    fileStagePath = String.format(AZURE_CONTAINER_WITH_FOLDER, azureAccountName,
<i class="no-highlight">2480</i>&nbsp;                            azureContainer, azureFolder);
<i class="no-highlight">2481</i>&nbsp;                }
<i class="no-highlight">2482</i>&nbsp;                break;
<i class="no-highlight">2483</i>&nbsp;            case GOOGLE_CLOUD_STORAGE:
<i class="no-highlight">2484</i>&nbsp;                if (StringUtils.isBlank(gcsBucket)) {
<i class="no-highlight">2485</i>&nbsp;                    throw new ConfigurationException(ERR_BLANK_GCSBUCKET)
<i class="no-highlight">2486</i>&nbsp;                            .withReason(REASON_BLANK_GCSBUCKET)
<i class="no-highlight">2487</i>&nbsp;                            .withResolution(RESOLUTION_BLANK_GCSBUCKET);
<i class="no-highlight">2488</i>&nbsp;                }
<i class="no-highlight">2489</i>&nbsp;                if (StringUtils.isBlank(gcsFolder)) {
<i class="no-highlight">2490</i>&nbsp;                    fileStagePath =
<i class="no-highlight">2491</i>&nbsp;                            String.format(GCS_FILE_KEY_FULL_PATH_NO_FOLDER, GCS, gcsBucket);
<i class="no-highlight">2492</i>&nbsp;                } else {
<b class="nc"><i class="no-highlight">2493</i>&nbsp;                    fileStagePath =</b>
<i class="no-highlight">2494</i>&nbsp;                            String.format(GCS_FILE_KEY_FULL_PATH, GCS, gcsBucket, gcsFolder);
<i class="no-highlight">2495</i>&nbsp;                }
<i class="no-highlight">2496</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">2497</i>&nbsp;            case NONE:</b>
<b class="nc"><i class="no-highlight">2498</i>&nbsp;            default:</b>
<b class="nc"><i class="no-highlight">2499</i>&nbsp;                throw new ConfigurationException(ERR_BLANK_SOURCE_LOCATION)</b>
<i class="no-highlight">2500</i>&nbsp;                        .withReason(REASON_BLANK_SOURCE_LOCATION)
<b class="nc"><i class="no-highlight">2501</i>&nbsp;                        .withResolution(RESOLUTION_BLANK_SOURCE_LOCATION);</b>
<i class="no-highlight">2502</i>&nbsp;        }
<i class="no-highlight">2503</i>&nbsp;
<i class="no-highlight">2504</i>&nbsp;        return fileStagePath;
<b class="nc"><i class="no-highlight">2505</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">2506</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2507</i>&nbsp;    private String buildSelectSQLStringForSourceStage(String filePathWithStageName) {</b>
<b class="nc"><i class="no-highlight">2508</i>&nbsp;        StringBuilder sourceColumnListBuilder = new StringBuilder();</b>
<b class="nc"><i class="no-highlight">2509</i>&nbsp;        Set&lt;String&gt; targetTableColumns =</b>
<b class="nc"><i class="no-highlight">2510</i>&nbsp;                new HashSet&lt;&gt;(this.columnMappingMap.keySet());</b>
<i class="no-highlight">2511</i>&nbsp;
<i class="no-highlight">2512</i>&nbsp;        boolean firstEntry = true;
<i class="no-highlight">2513</i>&nbsp;        for (String targetColName : this.targetColumns) {
<i class="no-highlight">2514</i>&nbsp;            if (targetTableColumns.contains(targetColName)) {
<i class="no-highlight">2515</i>&nbsp;                if (firstEntry) {
<b class="nc"><i class="no-highlight">2516</i>&nbsp;                    firstEntry = false;</b>
<i class="no-highlight">2517</i>&nbsp;                } else {
<i class="no-highlight">2518</i>&nbsp;                    sourceColumnListBuilder.append(COMMA_SPACE);
<i class="no-highlight">2519</i>&nbsp;                }
<i class="no-highlight">2520</i>&nbsp;                // Note that sourcePosition value is already verified at
<i class="no-highlight">2521</i>&nbsp;                // verifySourceColumnPositionValues().
<i class="no-highlight">2522</i>&nbsp;                String sourcePosition = this.columnMappingMap.get(targetColName);
<i class="no-highlight">2523</i>&nbsp;                sourceColumnListBuilder.append(
<i class="no-highlight">2524</i>&nbsp;                        String.format(SOURCE_FILE_COLUMN_FMT, sourcePosition));
<i class="no-highlight">2525</i>&nbsp;            }
<i class="no-highlight">2526</i>&nbsp;        }
<i class="no-highlight">2527</i>&nbsp;
<i class="no-highlight">2528</i>&nbsp;        // Append source column names from the map in target table column order
<i class="no-highlight">2529</i>&nbsp;        return String.format(SELECT_SOURCE_COLUMNS_FROM_EXTERNAL_FILE_SNOWFLAKE,
<i class="no-highlight">2530</i>&nbsp;                sourceColumnListBuilder.toString(), filePathWithStageName);
<i class="no-highlight">2531</i>&nbsp;    }
<b class="nc"><i class="no-highlight">2532</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2533</i>&nbsp;    private void appendStageFilePathWithProvidedColumnsRedshift() {</b>
<b class="nc"><i class="no-highlight">2534</i>&nbsp;        boolean columnMappingMapNotEmpty = MapUtils.isNotEmpty(this.columnMappingMap);</b>
<b class="nc"><i class="no-highlight">2535</i>&nbsp;        boolean targetColumnsNotEmpty = CollectionUtils.isNotEmpty(targetColumns);</b>
<b class="nc"><i class="no-highlight">2536</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2537</i>&nbsp;        createTableIfNotExistsWithSchemaInference();</b>
<b class="nc"><i class="no-highlight">2538</i>&nbsp;</b>
<i class="no-highlight">2539</i>&nbsp;        if ((StringUtils.equals(loadAction, APPEND_ROWS_TABLE) ||
<b class="nc"><i class="no-highlight">2540</i>&nbsp;                StringUtils.equals(loadAction, OVERWRITE_TABLE)) &amp;&amp;</b>
<i class="no-highlight">2541</i>&nbsp;                columnMappingMapNotEmpty &amp;&amp; !isCreateTargetTable) {
<i class="no-highlight">2542</i>&nbsp;            String headerColumns = StringUtils.join(
<i class="no-highlight">2543</i>&nbsp;                    this.columnMappingMap.keySet(), COMMA);
<i class="no-highlight">2544</i>&nbsp;            queryBuilder.append(String.format(
<i class="no-highlight">2545</i>&nbsp;                    COPY_FROM_STAGED_FILE_COMMAND_WITH_DATA_TRANSFORMATION_REDSHIFT,
<b class="nc"><i class="no-highlight">2546</i>&nbsp;                    targetTablePath, headerColumns, filePathStage));</b>
<b class="nc"><i class="no-highlight">2547</i>&nbsp;        } else if (StringUtils.equals(loadAction, DROP_CREATE_TABLE) &amp;&amp;</b>
<i class="no-highlight">2548</i>&nbsp;                columnMappingMapNotEmpty &amp;&amp;
<i class="no-highlight">2549</i>&nbsp;                targetColumnsNotEmpty) {
<b class="nc"><i class="no-highlight">2550</i>&nbsp;            validateColumnMappingMap();</b>
<b class="nc"><i class="no-highlight">2551</i>&nbsp;            appendStageFilePathWithNonEmptyColumnsWithMapRedshift();</b>
<i class="no-highlight">2552</i>&nbsp;        } else {
<i class="no-highlight">2553</i>&nbsp;            queryBuilder.append(String.format(COPY_FROM_STAGED_FILE_COMMAND_REDSHIFT,
<i class="no-highlight">2554</i>&nbsp;                    targetTablePath, filePathStage));
<i class="no-highlight">2555</i>&nbsp;        }
<i class="no-highlight">2556</i>&nbsp;        // If &#39;S3 Bucket Region&#39; is different from where Redshift Cluster is:
<i class="no-highlight">2557</i>&nbsp;        if (!StringUtils.equals(s3BucketRegion, S3Region.DEFAULT.toString())) {
<i class="no-highlight">2558</i>&nbsp;            queryBuilder.append(String.format(S3_BUCKET_REGION_REDSHIFT, s3BucketRegion));
<i class="no-highlight">2559</i>&nbsp;        }
<i class="no-highlight">2560</i>&nbsp;    }
<i class="no-highlight">2561</i>&nbsp;
<i class="no-highlight">2562</i>&nbsp;    /**
<b class="nc"><i class="no-highlight">2563</i>&nbsp;     * If INFERSCHEMA = TRUE is given and the loadAction is</b>
<b class="nc"><i class="no-highlight">2564</i>&nbsp;     * APPEND_ROWS_TABLE or OVERWRITE_TABLE but</b>
<i class="no-highlight">2565</i>&nbsp;     * the target table does not exist, CREATE the target table with
<i class="no-highlight">2566</i>&nbsp;     * schema auto inference.
<b class="nc"><i class="no-highlight">2567</i>&nbsp;     */</b>
<i class="no-highlight">2568</i>&nbsp;    private void createTableIfNotExistsWithSchemaInference() {
<i class="no-highlight">2569</i>&nbsp;        if (!(inferSchemaEnabled &amp;&amp;
<i class="no-highlight">2570</i>&nbsp;                !doesTableExist &amp;&amp;
<i class="no-highlight">2571</i>&nbsp;                (StringUtils.equals(loadAction, APPEND_ROWS_TABLE) ||
<i class="no-highlight">2572</i>&nbsp;                        StringUtils.equals(loadAction, OVERWRITE_TABLE)))) {
<i class="no-highlight">2573</i>&nbsp;            return;
<i class="no-highlight">2574</i>&nbsp;        }
<i class="no-highlight">2575</i>&nbsp;
<i class="no-highlight">2576</i>&nbsp;        LinkedHashMap&lt;String, String&gt; sourceFileColumnMap = null;
<i class="no-highlight">2577</i>&nbsp;        sourceFileColumnMap = autoDetectSourceFileSchema();
<i class="no-highlight">2578</i>&nbsp;
<i class="no-highlight">2579</i>&nbsp;        if (MapUtils.isEmpty(sourceFileColumnMap)) {
<i class="no-highlight">2580</i>&nbsp;            throw new ConfigurationException(ERR_TARGET_TABLE_SCHEMA_INFERENCE_FAILED)
<b class="nc"><i class="no-highlight">2581</i>&nbsp;                    .withReason(String.format(REASON_TARGET_TABLE_SCHEMA_INFERENCE_FAILED,</b>
<i class="no-highlight">2582</i>&nbsp;                            String.join(COMMA_SPACE, files)))
<b class="nc"><i class="no-highlight">2583</i>&nbsp;                    .withResolution(RES_TARGET_TABLE_SCHEMA_INFERENCE_FAILED);</b>
<b class="nc"><i class="no-highlight">2584</i>&nbsp;        }</b>
<i class="no-highlight">2585</i>&nbsp;
<b class="nc"><i class="no-highlight">2586</i>&nbsp;        if (!isAzureSynapseDb()) {</b>
<b class="nc"><i class="no-highlight">2587</i>&nbsp;            setAutoCommitLevel(false);</b>
<b class="nc"><i class="no-highlight">2588</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2589</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2590</i>&nbsp;        try {</b>
<b class="nc"><i class="no-highlight">2591</i>&nbsp;            sourceFileColumnNames = sourceFileColumnMap.keySet();</b>
<b class="nc"><i class="no-highlight">2592</i>&nbsp;            sourceFileColumnTypes = new ArrayList(sourceFileColumnMap.values());</b>
<b class="nc"><i class="no-highlight">2593</i>&nbsp;</b>
<i class="no-highlight">2594</i>&nbsp;            // Build CREATE TABLE SQL and execute it.
<i class="no-highlight">2595</i>&nbsp;            sqlCreateTable = buildCreateTableSql(targetTablePath,
<i class="no-highlight">2596</i>&nbsp;                    new ArrayList&lt;&gt;(sourceFileColumnNames), sourceFileColumnTypes);
<b class="nc"><i class="no-highlight">2597</i>&nbsp;            executedQueries.add(sqlCreateTable);</b>
<b class="nc"><i class="no-highlight">2598</i>&nbsp;            statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">2599</i>&nbsp;                    new QueryStatisticHolderBuilder(sqlCreateTable).build());</b>
<b class="nc"><i class="no-highlight">2600</i>&nbsp;            executeSqlStmt(sqlCreateTable, bindValues, account);</b>
<b class="nc"><i class="no-highlight">2601</i>&nbsp;            isCreateTargetTable = true;</b>
<b class="nc"><i class="no-highlight">2602</i>&nbsp;            doesTableExist = true;</b>
<i class="no-highlight">2603</i>&nbsp;        } catch (Exception e) {
<i class="no-highlight">2604</i>&nbsp;            handleFailures(ERR_BULK_LOAD);
<b class="nc"><i class="no-highlight">2605</i>&nbsp;            throw new SnapException(ERR_BULK_LOAD)</b>
<b class="nc"><i class="no-highlight">2606</i>&nbsp;                    .withReason(e.getCause() != null ? e.getCause().getMessage() :</b>
<b class="nc"><i class="no-highlight">2607</i>&nbsp;                            e.getMessage())</b>
<i class="no-highlight">2608</i>&nbsp;                    .withResolution(RESOLUTION_BULK_LOAD);
<b class="nc"><i class="no-highlight">2609</i>&nbsp;        }</b>
<i class="no-highlight">2610</i>&nbsp;    }
<b class="nc"><i class="no-highlight">2611</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2612</i>&nbsp;    /**</b>
<b class="nc"><i class="no-highlight">2613</i>&nbsp;     * Given non-empty targetColumns and columnMappingMap from the SNAP UI,</b>
<b class="nc"><i class="no-highlight">2614</i>&nbsp;     * appends target column list and file path for DROP_CREATE load action</b>
<b class="nc"><i class="no-highlight">2615</i>&nbsp;     * (can potentially support the other load actions).</b>
<i class="no-highlight">2616</i>&nbsp;     *
<i class="no-highlight">2617</i>&nbsp;     * This function tries to auto-detect source file schema and,
<i class="no-highlight">2618</i>&nbsp;     * if successful and a transformation type 5 is required,
<i class="no-highlight">2619</i>&nbsp;     * appends clauses for an intermediate target table.
<b class="nc"><i class="no-highlight">2620</i>&nbsp;     * If not (if auto-detect fails or we don&#39;t need a complex transformation</b>
<b class="nc"><i class="no-highlight">2621</i>&nbsp;     * type 5), appends clauses for the target table.</b>
<b class="nc"><i class="no-highlight">2622</i>&nbsp;     */</b>
<i class="no-highlight">2623</i>&nbsp;    private void appendStageFilePathWithNonEmptyColumnsWithMapRedshift() {
<b class="nc"><i class="no-highlight">2624</i>&nbsp;        trimListEntries(targetColumns);</b>
<b class="nc"><i class="no-highlight">2625</i>&nbsp;</b>
<i class="no-highlight">2626</i>&nbsp;        // The next line is to disable Automatic Schema Inference (ASI) for
<b class="nc"><i class="no-highlight">2627</i>&nbsp;        // &quot;Drop and Create table&quot; load action for the time being.</b>
<i class="no-highlight">2628</i>&nbsp;        inferSchemaEnabled = false;
<b class="nc"><i class="no-highlight">2629</i>&nbsp;        if (inferSchemaEnabled) {</b>
<b class="nc"><i class="no-highlight">2630</i>&nbsp;            LinkedHashMap&lt;String, String&gt; sourceFileColumnMap = null;</b>
<b class="nc"><i class="no-highlight">2631</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2632</i>&nbsp;            sourceFileColumnMap = autoDetectSourceFileSchema();</b>
<b class="nc"><i class="no-highlight">2633</i>&nbsp;</b>
<i class="no-highlight">2634</i>&nbsp;            // Please see the comments of isIntermediateTableRequired() for
<i class="no-highlight">2635</i>&nbsp;            // an explanation.
<i class="no-highlight">2636</i>&nbsp;            if (MapUtils.isNotEmpty(sourceFileColumnMap) &amp;&amp;
<i class="no-highlight">2637</i>&nbsp;                    isIntermediateTableRequired(sourceFileColumnMap.keySet())) {
<b class="nc"><i class="no-highlight">2638</i>&nbsp;                isIntermediateTargetTableRequired = true;</b>
<b class="nc"><i class="no-highlight">2639</i>&nbsp;                sourceFileColumnNames = sourceFileColumnMap.keySet();</b>
<b class="nc"><i class="no-highlight">2640</i>&nbsp;                sourceFileColumnTypes = new ArrayList(sourceFileColumnMap.values());</b>
<i class="no-highlight">2641</i>&nbsp;                appendFilePathWithColumnsAndMapWithSourceSchemaRedshift();
<b class="nc"><i class="no-highlight">2642</i>&nbsp;                return;</b>
<b class="nc"><i class="no-highlight">2643</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2644</i>&nbsp;        }</b>
<i class="no-highlight">2645</i>&nbsp;
<i class="no-highlight">2646</i>&nbsp;        // Appends target table clauses.
<i class="no-highlight">2647</i>&nbsp;        appendFilePathWithColumnsAndMapWithoutSourceSchemaRedshift();
<b class="nc"><i class="no-highlight">2648</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">2649</i>&nbsp;</b>
<i class="no-highlight">2650</i>&nbsp;    /**
<i class="no-highlight">2651</i>&nbsp;     * Return true if the SNAP UI columnMappingMap.values()
<b class="nc"><i class="no-highlight">2652</i>&nbsp;     * is a subset of the given &quot;sourceFileColumnNameSet&quot;</b>
<b class="nc"><i class="no-highlight">2653</i>&nbsp;     * (i.e., there is a &quot;sourceFileColumnNameSet&quot; element that is not an</b>
<i class="no-highlight">2654</i>&nbsp;     * element of &#39;columnMappingMap&#39;) or columnMappingMap.values() element
<i class="no-highlight">2655</i>&nbsp;     * order is not the same as &quot;sourceFileColumnNameSet&quot;.
<b class="nc"><i class="no-highlight">2656</i>&nbsp;     *</b>
<b class="nc"><i class="no-highlight">2657</i>&nbsp;     * Either true case indicates that we need a transformation type 5.</b>
<i class="no-highlight">2658</i>&nbsp;     * Hence an intermediate target table is required.
<i class="no-highlight">2659</i>&nbsp;     * @param sourceFileColumnNameSet   source file column name set from auto-schema-detection
<b class="nc"><i class="no-highlight">2660</i>&nbsp;     * @return  true/false</b>
<b class="nc"><i class="no-highlight">2661</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">2662</i>&nbsp;    private boolean isIntermediateTableRequired(Set&lt;String&gt; sourceFileColumnNameSet) {</b>
<b class="nc"><i class="no-highlight">2663</i>&nbsp;        boolean isFileFormatJSON = isFileFormatJSON();</b>
<b class="nc"><i class="no-highlight">2664</i>&nbsp;        Iterator&lt;String&gt; columnMapValueIterator = columnMappingMap.values().iterator();</b>
<i class="no-highlight">2665</i>&nbsp;        Iterator&lt;String&gt; columnMapKeyIterator = columnMappingMap.keySet().iterator();
<b class="nc"><i class="no-highlight">2666</i>&nbsp;        for (String columnName : sourceFileColumnNameSet) {</b>
<b class="nc"><i class="no-highlight">2667</i>&nbsp;            if (!columnMapValueIterator.hasNext() ||</b>
<i class="no-highlight">2668</i>&nbsp;                    !columnName.equalsIgnoreCase(columnMapValueIterator.next())) {
<i class="no-highlight">2669</i>&nbsp;                return true;
<i class="no-highlight">2670</i>&nbsp;            }
<i class="no-highlight">2671</i>&nbsp;            if (isRedshiftDb() &amp;&amp; isFileFormatJSON){
<i class="no-highlight">2672</i>&nbsp;                // If it is Redshift CDW and the file format is JSON,
<i class="no-highlight">2673</i>&nbsp;                // we have an additional constraint that
<i class="no-highlight">2674</i>&nbsp;                // the target column names should match source file field names to avoid
<i class="no-highlight">2675</i>&nbsp;                // transformation type 5 processing (creating an intermediate temporary table,
<i class="no-highlight">2676</i>&nbsp;                // COPYing into the temporary table, and INSERt SELECT into the target table)
<i class="no-highlight">2677</i>&nbsp;                if (!columnName.equalsIgnoreCase(columnMapKeyIterator.next())) {
<i class="no-highlight">2678</i>&nbsp;                    return true;
<i class="no-highlight">2679</i>&nbsp;                }
<i class="no-highlight">2680</i>&nbsp;            }
<b class="nc"><i class="no-highlight">2681</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2682</i>&nbsp;        return false;</b>
<i class="no-highlight">2683</i>&nbsp;    }
<i class="no-highlight">2684</i>&nbsp;
<i class="no-highlight">2685</i>&nbsp;    /**
<b class="nc"><i class="no-highlight">2686</i>&nbsp;     * Append target column list with file path using the schema from</b>
<b class="nc"><i class="no-highlight">2687</i>&nbsp;     * schema auto-detection for a to-be-created intermediate target table.</b>
<b class="nc"><i class="no-highlight">2688</i>&nbsp;     *</b>
<b class="nc"><i class="no-highlight">2689</i>&nbsp;     * The precondition of this function include,</b>
<b class="nc"><i class="no-highlight">2690</i>&nbsp;     * first, the targetColumns and the target-to-source-map are not empty,</b>
<b class="nc"><i class="no-highlight">2691</i>&nbsp;     * second. source file schema (colunm names and data types) are available.</b>
<i class="no-highlight">2692</i>&nbsp;     */
<b class="nc"><i class="no-highlight">2693</i>&nbsp;    private void appendFilePathWithColumnsAndMapWithSourceSchemaRedshift() {</b>
<i class="no-highlight">2694</i>&nbsp;        fqIntermediateTargetTableName = getTempTableName();
<b class="nc"><i class="no-highlight">2695</i>&nbsp;        queryBuilder.append(String.format(</b>
<i class="no-highlight">2696</i>&nbsp;                COPY_FROM_STAGED_FILE_COMMAND_WITH_DATA_TRANSFORMATION_REDSHIFT,
<b class="nc"><i class="no-highlight">2697</i>&nbsp;                fqIntermediateTargetTableName,</b>
<b class="nc"><i class="no-highlight">2698</i>&nbsp;                String.join(COMMA_SPACE, sourceFileColumnNames), filePathStage));</b>
<i class="no-highlight">2699</i>&nbsp;    }
<b class="nc"><i class="no-highlight">2700</i>&nbsp;</b>
<i class="no-highlight">2701</i>&nbsp;    /**
<i class="no-highlight">2702</i>&nbsp;     * Build and execute INSERT SELEcT SQL statement
<i class="no-highlight">2703</i>&nbsp;     * from the intermediate table to the target table
<b class="nc"><i class="no-highlight">2704</i>&nbsp;     * for DROP and CREATE, OVERWRITE TABLE, and APPEND TABLE load actions.</b>
<b class="nc"><i class="no-highlight">2705</i>&nbsp;     * Note that &quot;INSERT INTO $targetTableName (targetColumn1, ...) SELECT&quot; +</b>
<b class="nc"><i class="no-highlight">2706</i>&nbsp;     * &quot; intermediatColumn1, ... FROM $intermediateTableName&quot; type SQL is</b>
<b class="nc"><i class="no-highlight">2707</i>&nbsp;     * need to support transformation type 5.</b>
<b class="nc"><i class="no-highlight">2708</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">2709</i>&nbsp;    private void copyIntoTargetTableRedshift(</b>
<i class="no-highlight">2710</i>&nbsp;            String intermediateTableFullyQualifiedName,
<b class="nc"><i class="no-highlight">2711</i>&nbsp;            String finalTargetTableFullyQualifieName) throws SQLException {</b>
<i class="no-highlight">2712</i>&nbsp;        trimListEntries(targetColumns);
<i class="no-highlight">2713</i>&nbsp;
<b class="nc"><i class="no-highlight">2714</i>&nbsp;        StringBuilder targetColumnsBuilder = new StringBuilder();</b>
<b class="nc"><i class="no-highlight">2715</i>&nbsp;        StringBuilder sourceColumnsBuilder = new StringBuilder();</b>
<i class="no-highlight">2716</i>&nbsp;
<i class="no-highlight">2717</i>&nbsp;        boolean firstEntry = true;
<b class="nc"><i class="no-highlight">2718</i>&nbsp;        boolean valueAppended = false;</b>
<i class="no-highlight">2719</i>&nbsp;        boolean valueAppendedPrevToProcess = false;
<i class="no-highlight">2720</i>&nbsp;        List&lt;String&gt; targetColumnNameListToScan = targetColumns;
<i class="no-highlight">2721</i>&nbsp;        if (StringUtils.equals(loadAction, OVERWRITE_TABLE) ||
<i class="no-highlight">2722</i>&nbsp;                StringUtils.equals(loadAction, APPEND_ROWS_TABLE)) {
<i class="no-highlight">2723</i>&nbsp;            targetColumnNameListToScan =
<i class="no-highlight">2724</i>&nbsp;                    new ArrayList&lt;&gt;(findTableColumns(targetTableName));
<b class="nc"><i class="no-highlight">2725</i>&nbsp;        }</b>
<i class="no-highlight">2726</i>&nbsp;
<b class="nc"><i class="no-highlight">2727</i>&nbsp;        // Loop on the target table column names.</b>
<i class="no-highlight">2728</i>&nbsp;        for (String targetColumnName : targetColumnNameListToScan) {
<b class="nc"><i class="no-highlight">2729</i>&nbsp;            if (firstEntry) {</b>
<b class="nc"><i class="no-highlight">2730</i>&nbsp;                firstEntry = false;</b>
<i class="no-highlight">2731</i>&nbsp;            } else if (valueAppended) {
<i class="no-highlight">2732</i>&nbsp;                targetColumnsBuilder.append(COMMA);
<b class="nc"><i class="no-highlight">2733</i>&nbsp;                sourceColumnsBuilder.append(COMMA);</b>
<b class="nc"><i class="no-highlight">2734</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2735</i>&nbsp;</b>
<i class="no-highlight">2736</i>&nbsp;            if (valueAppended) {
<b class="nc"><i class="no-highlight">2737</i>&nbsp;                valueAppendedPrevToProcess = true;</b>
<b class="nc"><i class="no-highlight">2738</i>&nbsp;                valueAppended = false;</b>
<i class="no-highlight">2739</i>&nbsp;            }
<i class="no-highlight">2740</i>&nbsp;            if (sourceFileColumnNames.contains(targetColumnName)) {
<i class="no-highlight">2741</i>&nbsp;                // if targetColumnName is in sourceFileColumnNames, just add.
<i class="no-highlight">2742</i>&nbsp;                targetColumnsBuilder.append(targetColumnName);
<i class="no-highlight">2743</i>&nbsp;                sourceColumnsBuilder.append(targetColumnName);
<i class="no-highlight">2744</i>&nbsp;                valueAppendedPrevToProcess = false;
<i class="no-highlight">2745</i>&nbsp;                valueAppended = true;
<i class="no-highlight">2746</i>&nbsp;            } else if (this.columnMappingMap.containsKey(targetColumnName)){
<i class="no-highlight">2747</i>&nbsp;                // if targetColumnName is not in sourceFileColumnNames but in
<i class="no-highlight">2748</i>&nbsp;                // the map key set, then grep its map value. Then verify that
<i class="no-highlight">2749</i>&nbsp;                // it is in the sourceFileColumnNames, and append
<i class="no-highlight">2750</i>&nbsp;                // &quot;sourceColumnName AS targetColumnName&quot;
<i class="no-highlight">2751</i>&nbsp;                String sourceColumnName = columnMappingMap.get(targetColumnName);
<b class="nc"><i class="no-highlight">2752</i>&nbsp;                if (sourceFileColumnNames</b>
<i class="no-highlight">2753</i>&nbsp;                        .stream().noneMatch(col -&gt; StringUtils.containsIgnoreCase(col,
<i class="no-highlight">2754</i>&nbsp;                        sourceColumnName))) {
<i class="no-highlight">2755</i>&nbsp;                    throw new ConfigurationException(ERR_INVALID_SOURCE_COLUMN_NAMES_FOUND)
<i class="no-highlight">2756</i>&nbsp;                            .withReason(String.format(
<i class="no-highlight">2757</i>&nbsp;                                    REASON_SOURCE_COLUMN_NAMES_NOT_FOUND, sourceColumnName))
<i class="no-highlight">2758</i>&nbsp;                            .withResolution(RESOLUTION_SOURCE_COLUMN_NAMES_NOT_FOUND);
<i class="no-highlight">2759</i>&nbsp;                }
<i class="no-highlight">2760</i>&nbsp;                targetColumnsBuilder.append(targetColumnName);
<i class="no-highlight">2761</i>&nbsp;                sourceColumnsBuilder.append(sourceColumnName);
<i class="no-highlight">2762</i>&nbsp;                valueAppendedPrevToProcess = false;
<i class="no-highlight">2763</i>&nbsp;                valueAppended = true;
<i class="no-highlight">2764</i>&nbsp;            } else {
<i class="no-highlight">2765</i>&nbsp;                // if not in sourceFileColumnNames, nor in the map, then
<i class="no-highlight">2766</i>&nbsp;                // skip the current targetColunmName per Redshift SQL syntax rules.
<i class="no-highlight">2767</i>&nbsp;
<i class="no-highlight">2768</i>&nbsp;                // delete the last COMMA.
<b class="nc"><i class="no-highlight">2769</i>&nbsp;                if (targetColumnsBuilder.length() &gt; 0 &amp;&amp;</b>
<i class="no-highlight">2770</i>&nbsp;                        targetColumnsBuilder.charAt(targetColumnsBuilder.length() - 1) == COMMA) {
<i class="no-highlight">2771</i>&nbsp;                    targetColumnsBuilder.setLength(targetColumnsBuilder.length() - 1);
<i class="no-highlight">2772</i>&nbsp;                }
<i class="no-highlight">2773</i>&nbsp;                if (sourceColumnsBuilder.length() &gt; 0 &amp;&amp;
<b class="nc"><i class="no-highlight">2774</i>&nbsp;                        sourceColumnsBuilder.charAt(sourceColumnsBuilder.length() - 1) == COMMA) {</b>
<b class="nc"><i class="no-highlight">2775</i>&nbsp;                    sourceColumnsBuilder.setLength(sourceColumnsBuilder.length() - 1);</b>
<b class="nc"><i class="no-highlight">2776</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">2777</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2778</i>&nbsp;                // set true to valueAppended if valueAppendedPrevToProcess is true</b>
<i class="no-highlight">2779</i>&nbsp;                if (valueAppendedPrevToProcess) {
<i class="no-highlight">2780</i>&nbsp;                    valueAppended = true;
<b class="nc"><i class="no-highlight">2781</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">2782</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2783</i>&nbsp;        }</b>
<i class="no-highlight">2784</i>&nbsp;        insertSelectSql = String.format(
<b class="nc"><i class="no-highlight">2785</i>&nbsp;                INSERT_INTO_TARGET_SELECT_FROM_INTERMEDIATE_BIGQUERY_REDSHIFT,</b>
<b class="nc"><i class="no-highlight">2786</i>&nbsp;                finalTargetTableFullyQualifieName,</b>
<b class="nc"><i class="no-highlight">2787</i>&nbsp;                String.join(COMMA_SPACE, targetColumnsBuilder.toString()),</b>
<b class="nc"><i class="no-highlight">2788</i>&nbsp;                String.join(COMMA_SPACE, sourceColumnsBuilder.toString()),</b>
<i class="no-highlight">2789</i>&nbsp;                intermediateTableFullyQualifiedName);
<i class="no-highlight">2790</i>&nbsp;
<b class="nc"><i class="no-highlight">2791</i>&nbsp;        executedQueries.add(insertSelectSql);</b>
<i class="no-highlight">2792</i>&nbsp;        int numberOfInserts =
<i class="no-highlight">2793</i>&nbsp;                executeStatement(insertSelectSql, bindValues, account);
<b class="nc"><i class="no-highlight">2794</i>&nbsp;        statistic.addNumberOfInserts(numberOfInserts);</b>
<b class="nc"><i class="no-highlight">2795</i>&nbsp;        statistic.addQueryStatistic(</b>
<i class="no-highlight">2796</i>&nbsp;                new QueryStatisticHolderBuilder(insertSelectSql)
<b class="nc"><i class="no-highlight">2797</i>&nbsp;                        .setNumberOfInserts(numberOfInserts)</b>
<b class="nc"><i class="no-highlight">2798</i>&nbsp;                        .build());</b>
<b class="nc"><i class="no-highlight">2799</i>&nbsp;    }</b>
<i class="no-highlight">2800</i>&nbsp;
<i class="no-highlight">2801</i>&nbsp;    /**
<i class="no-highlight">2802</i>&nbsp;     * Append target column list with file path
<b class="nc"><i class="no-highlight">2803</i>&nbsp;     * when the source file schema is not available</b>
<i class="no-highlight">2804</i>&nbsp;     * (source file schema auto-detectation does not work).
<b class="nc"><i class="no-highlight">2805</i>&nbsp;     * The precondition of this function include the case where</b>
<b class="nc"><i class="no-highlight">2806</i>&nbsp;     * the targetColumns and the target-to-source-map are not empty.</b>
<b class="nc"><i class="no-highlight">2807</i>&nbsp;     *</b>
<b class="nc"><i class="no-highlight">2808</i>&nbsp;     * Note that this only works for DROP and CREATE table action and</b>
<b class="nc"><i class="no-highlight">2809</i>&nbsp;     * transformation type 1.</b>
<b class="nc"><i class="no-highlight">2810</i>&nbsp;     */</b>
<i class="no-highlight">2811</i>&nbsp;    private void appendFilePathWithColumnsAndMapWithoutSourceSchemaRedshift() {
<b class="nc"><i class="no-highlight">2812</i>&nbsp;        Set&lt;String&gt; targetTableColumns =</b>
<i class="no-highlight">2813</i>&nbsp;                new HashSet&lt;&gt;(this.columnMappingMap.keySet());
<b class="nc"><i class="no-highlight">2814</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2815</i>&nbsp;        // Append source column names from the map in target table column order</b>
<i class="no-highlight">2816</i>&nbsp;        // (i.e., &quot;targetColumns&quot; order).
<b class="nc"><i class="no-highlight">2817</i>&nbsp;        StringBuilder headerColumnsBuilder = new StringBuilder();</b>
<b class="nc"><i class="no-highlight">2818</i>&nbsp;        boolean firstEntry = true;</b>
<i class="no-highlight">2819</i>&nbsp;        for (String targetColName : this.targetColumns) {
<b class="nc"><i class="no-highlight">2820</i>&nbsp;            if (targetTableColumns.contains(targetColName)) {</b>
<b class="nc"><i class="no-highlight">2821</i>&nbsp;                if (firstEntry) {</b>
<i class="no-highlight">2822</i>&nbsp;                    firstEntry = false;
<b class="nc"><i class="no-highlight">2823</i>&nbsp;                } else {</b>
<i class="no-highlight">2824</i>&nbsp;                    headerColumnsBuilder.append(COMMA);
<b class="nc"><i class="no-highlight">2825</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">2826</i>&nbsp;                headerColumnsBuilder.append(targetColName);</b>
<b class="nc"><i class="no-highlight">2827</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2828</i>&nbsp;        }</b>
<i class="no-highlight">2829</i>&nbsp;        queryBuilder.append(String.format(
<i class="no-highlight">2830</i>&nbsp;                COPY_FROM_STAGED_FILE_COMMAND_WITH_DATA_TRANSFORMATION_REDSHIFT,
<i class="no-highlight">2831</i>&nbsp;                targetTablePath, headerColumnsBuilder.toString(), filePathStage));
<i class="no-highlight">2832</i>&nbsp;    }
<i class="no-highlight">2833</i>&nbsp;
<i class="no-highlight">2834</i>&nbsp;    private void appendStageFilePathWithProvidedColumnsDLP() {
<b class="nc"><i class="no-highlight">2835</i>&nbsp;        if (isTargetColumnsNotEmpty(targetColumns)) {</b>
<i class="no-highlight">2836</i>&nbsp;            sourceFileFieldNames = retrieveSourceFileFieldNamesDLP();
<b class="nc"><i class="no-highlight">2837</i>&nbsp;            if (MapUtils.isEmpty(this.columnMappingMap)) {</b>
<b class="nc"><i class="no-highlight">2838</i>&nbsp;                if (StringUtils.equalsIgnoreCase(loadAction, ALTER_TABLE)) {</b>
<b class="nc"><i class="no-highlight">2839</i>&nbsp;                    isAlterTableAndNonEmptyTargetColumns = true;</b>
<b class="nc"><i class="no-highlight">2840</i>&nbsp;                    appendStageFileWithNonEmptyColumnsForAlterTableDLP();</b>
<i class="no-highlight">2841</i>&nbsp;                } else {
<i class="no-highlight">2842</i>&nbsp;                    appendStageFilePathWithNonEmptyColumnsDLP();
<b class="nc"><i class="no-highlight">2843</i>&nbsp;                }</b>
<i class="no-highlight">2844</i>&nbsp;            } else {
<i class="no-highlight">2845</i>&nbsp;                validateColumnMappingMap();
<i class="no-highlight">2846</i>&nbsp;                appendStageFilePathWithNonEmptyColumnsWithMapDLP();
<i class="no-highlight">2847</i>&nbsp;            }
<i class="no-highlight">2848</i>&nbsp;        } else {
<i class="no-highlight">2849</i>&nbsp;            queryBuilder.append(String.format(COPY_FROM_STAGED_FILE_COMMAND_DLP,
<i class="no-highlight">2850</i>&nbsp;                    targetTablePath, filePathStage));
<b class="nc"><i class="no-highlight">2851</i>&nbsp;        }</b>
<i class="no-highlight">2852</i>&nbsp;    }
<b class="nc"><i class="no-highlight">2853</i>&nbsp;</b>
<i class="no-highlight">2854</i>&nbsp;    // Retrieve and return source file field name list for DLP
<b class="nc"><i class="no-highlight">2855</i>&nbsp;    private Set&lt;String&gt; retrieveSourceFileFieldNamesDLP() {</b>
<i class="no-highlight">2856</i>&nbsp;        trimListEntries(filePaths);
<i class="no-highlight">2857</i>&nbsp;
<i class="no-highlight">2858</i>&nbsp;        if (fileFormatType.equals(CSV)) {
<i class="no-highlight">2859</i>&nbsp;            // Randomly choose a file from the filePaths
<i class="no-highlight">2860</i>&nbsp;            Random rand = new Random();
<i class="no-highlight">2861</i>&nbsp;            String filePath = filePaths.get(rand.nextInt(filePaths.size()));
<i class="no-highlight">2862</i>&nbsp;            try {
<i class="no-highlight">2863</i>&nbsp;                // Note that we returns the column names without changing to uppercase.
<i class="no-highlight">2864</i>&nbsp;                return getColumnNamesFromCsvFile(filePath);
<i class="no-highlight">2865</i>&nbsp;            } catch (SQLException sqlException) {
<i class="no-highlight">2866</i>&nbsp;                throw new ConfigurationException(&quot;Exception while executing SQL&quot; +
<i class="no-highlight">2867</i>&nbsp;                        &quot; to retrieve source file file name list for DLP&quot;)
<b class="nc"><i class="no-highlight">2868</i>&nbsp;                        .withReason(sqlException.getMessage())</b>
<i class="no-highlight">2869</i>&nbsp;                        .withResolution(RESOLUTION_ADDRESS_ISSUE);
<b class="nc"><i class="no-highlight">2870</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2871</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2872</i>&nbsp;</b>
<i class="no-highlight">2873</i>&nbsp;        // Note that we have &quot;File List&quot; and &quot;File Name Pattern&quot; options from the UI.
<i class="no-highlight">2874</i>&nbsp;        // The cases for &quot;File List&quot; are trivial. Also verified that
<i class="no-highlight">2875</i>&nbsp;        // the cases for &quot;File Name Pattern&quot; works fine with the below call.
<b class="nc"><i class="no-highlight">2876</i>&nbsp;        // For example,</b>
<b class="nc"><i class="no-highlight">2877</i>&nbsp;        // all the cases below return column list successfully.</b>
<i class="no-highlight">2878</i>&nbsp;        // SELECT * FROM JSON.`/qa/json/org100.*.gz` WHERE 1=0;
<i class="no-highlight">2879</i>&nbsp;        // SELECT * FROM CSV.`/qa/csv/org100*.csv` WHERE 1=0;
<b class="nc"><i class="no-highlight">2880</i>&nbsp;        // SELECT * FROM PARQUET.`/qa/parquet/org100*.*.parquet` WHERE 1=0;</b>
<i class="no-highlight">2881</i>&nbsp;        // SELECT * FROM AVRO.`/qa/parquet/org100.*` WHERE 1=0;
<i class="no-highlight">2882</i>&nbsp;        // SELECT * FROM ORC.`/qa/orc/org100.*` WHERE 1=0;
<i class="no-highlight">2883</i>&nbsp;        return findTableColumns(buildFullyQualifiedSourceFilePathTableNameDLP(
<i class="no-highlight">2884</i>&nbsp;                fileFormatType, dbfsFolder, filePaths, filePattern
<b class="nc"><i class="no-highlight">2885</i>&nbsp;        ));</b>
<i class="no-highlight">2886</i>&nbsp;    }
<i class="no-highlight">2887</i>&nbsp;
<i class="no-highlight">2888</i>&nbsp;    /**
<i class="no-highlight">2889</i>&nbsp;     * Append file path when &quot;this.targetColumns&quot; is not empty.
<i class="no-highlight">2890</i>&nbsp;     * This indicates the user selected a subset of the target table targetColumns.
<i class="no-highlight">2891</i>&nbsp;     *
<i class="no-highlight">2892</i>&nbsp;     * Note that this function is called only when the load action is
<i class="no-highlight">2893</i>&nbsp;     * DROP_CREATE_TABLE.
<i class="no-highlight">2894</i>&nbsp;     */
<i class="no-highlight">2895</i>&nbsp;    private void appendStageFilePathWithNonEmptyColumnsDLP() {
<i class="no-highlight">2896</i>&nbsp;        // Check the size of source column set in &quot;sourceTableColumns&quot; and
<i class="no-highlight">2897</i>&nbsp;        // target column set in &quot;targetColumns&quot; and process accordingly.
<i class="no-highlight">2898</i>&nbsp;        // If source column set size is less, append NULL to the SELECT
<i class="no-highlight">2899</i>&nbsp;        // clause field list string.
<b class="nc"><i class="no-highlight">2900</i>&nbsp;        if (sourceFileFieldNames.size() == targetColumns.size()) {</b>
<i class="no-highlight">2901</i>&nbsp;            // Throw an exception if the column names do not match.
<b class="nc"><i class="no-highlight">2902</i>&nbsp;            // Note that file path in CSV file format does not show correct column names, thus</b>
<b class="nc"><i class="no-highlight">2903</i>&nbsp;            // we ignore CSV case here.</b>
<b class="nc"><i class="no-highlight">2904</i>&nbsp;            // All the other formats like JSON, AVRO, ORC, and PARQUET cases work fine.</b>
<b class="nc"><i class="no-highlight">2905</i>&nbsp;            if (!StringUtils.equalsIgnoreCase(fileFormatType, CSV) &amp;&amp;</b>
<b class="nc"><i class="no-highlight">2906</i>&nbsp;                    !doesSourceTableColumnNamesMatchWithColumns(sourceFileFieldNames)) {</b>
<b class="nc"><i class="no-highlight">2907</i>&nbsp;                throw new ConfigurationException(ERR_INVALID_COLUMN_NAMES_FOUND)</b>
<b class="nc"><i class="no-highlight">2908</i>&nbsp;                        .withReason(REASON_INVALID_COLUMN_NAMES_FOUND)</b>
<i class="no-highlight">2909</i>&nbsp;                        .withResolution(RESOLUTION_INVALID_COLUMN_NAMES_FOUND);
<i class="no-highlight">2910</i>&nbsp;            }
<b class="nc"><i class="no-highlight">2911</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2912</i>&nbsp;            verifyHeaderTrueForCSVFileFormatType();</b>
<i class="no-highlight">2913</i>&nbsp;            String headerColumns =
<i class="no-highlight">2914</i>&nbsp;                    StringUtils.join(targetColumnsWithBacktick, COMMA);
<i class="no-highlight">2915</i>&nbsp;
<i class="no-highlight">2916</i>&nbsp;            if (!inferSchemaEnabled &amp;&amp;
<i class="no-highlight">2917</i>&nbsp;                    StringUtils.equalsIgnoreCase(fileFormatType, CSV)) {
<b class="nc"><i class="no-highlight">2918</i>&nbsp;                headerColumns =</b>
<b class="nc"><i class="no-highlight">2919</i>&nbsp;                        castFieldsToDefinedTypes(targetColumnsWithBacktick, targetDataTypes);</b>
<b class="nc"><i class="no-highlight">2920</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2921</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2922</i>&nbsp;            queryBuilder.append(String.format(</b>
<b class="nc"><i class="no-highlight">2923</i>&nbsp;                    COPY_FROM_STAGED_FILE_COMMAND_WITH_DATA_TRANSFORMATION_DLP,</b>
<i class="no-highlight">2924</i>&nbsp;                    targetTablePath, headerColumns, filePathStage));
<b class="nc"><i class="no-highlight">2925</i>&nbsp;        } else if (sourceFileFieldNames.size() &lt; targetColumns.size()) {</b>
<i class="no-highlight">2926</i>&nbsp;            isSourceFileColumnListSizeDifferentFromTarget = true;
<b class="nc"><i class="no-highlight">2927</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2928</i>&nbsp;            if (StringUtils.equalsIgnoreCase(fileFormatType, CSV)) {</b>
<i class="no-highlight">2929</i>&nbsp;                appendCsvFilePathWithNonEmptyLargerNumberOfColumnsDLP(
<i class="no-highlight">2930</i>&nbsp;                        sourceFileFieldNames.size()
<i class="no-highlight">2931</i>&nbsp;                );
<b class="nc"><i class="no-highlight">2932</i>&nbsp;                return;</b>
<b class="nc"><i class="no-highlight">2933</i>&nbsp;            }</b>
<i class="no-highlight">2934</i>&nbsp;            checkSourceTableColumnNamesHasMatchWithColumns(sourceFileFieldNames);
<b class="nc"><i class="no-highlight">2935</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">2936</i>&nbsp;            StringBuilder headerColumnsBuilder = new StringBuilder();</b>
<b class="nc"><i class="no-highlight">2937</i>&nbsp;            boolean firstEntry = true;</b>
<b class="nc"><i class="no-highlight">2938</i>&nbsp;            for (String columnName : targetColumns) {</b>
<b class="nc"><i class="no-highlight">2939</i>&nbsp;                String columnNameToAppend = getColumnNameForSQLDLP(columnName);</b>
<i class="no-highlight">2940</i>&nbsp;                if (firstEntry) {
<i class="no-highlight">2941</i>&nbsp;                    firstEntry = false;
<b class="nc"><i class="no-highlight">2942</i>&nbsp;                } else {</b>
<i class="no-highlight">2943</i>&nbsp;                    headerColumnsBuilder.append(COMMA);
<b class="nc"><i class="no-highlight">2944</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">2945</i>&nbsp;                if (sourceFileFieldNames.contains(columnName)) {</b>
<i class="no-highlight">2946</i>&nbsp;                    headerColumnsBuilder.append(columnNameToAppend);
<i class="no-highlight">2947</i>&nbsp;                } else {
<b class="nc"><i class="no-highlight">2948</i>&nbsp;                    headerColumnsBuilder</b>
<b class="nc"><i class="no-highlight">2949</i>&nbsp;                            .append(String.format(NULL_AS_COLUMN, columnNameToAppend));</b>
<i class="no-highlight">2950</i>&nbsp;                }
<b class="nc"><i class="no-highlight">2951</i>&nbsp;            }</b>
<i class="no-highlight">2952</i>&nbsp;            queryBuilder.append(String.format(
<i class="no-highlight">2953</i>&nbsp;                    COPY_FROM_STAGED_FILE_COMMAND_WITH_DATA_TRANSFORMATION_DLP,
<i class="no-highlight">2954</i>&nbsp;                    targetTablePath, headerColumnsBuilder.toString(), filePathStage));
<b class="nc"><i class="no-highlight">2955</i>&nbsp;</b>
<i class="no-highlight">2956</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">2957</i>&nbsp;            throw new ConfigurationException(ERR_INVALID_SOURCE_FILE_FORMAT)</b>
<b class="nc"><i class="no-highlight">2958</i>&nbsp;                    .withReason(REASON_INVALID_SOURCE_FILE_FORMAT)</b>
<b class="nc"><i class="no-highlight">2959</i>&nbsp;                    .withResolution(RESOLUTION_INVALID_SOURCE_FILE_FORMAT);</b>
<i class="no-highlight">2960</i>&nbsp;        }
<i class="no-highlight">2961</i>&nbsp;
<i class="no-highlight">2962</i>&nbsp;    }
<i class="no-highlight">2963</i>&nbsp;
<i class="no-highlight">2964</i>&nbsp;    private String castFieldsToDefinedTypes(List&lt;String&gt; targetColumnNames,
<i class="no-highlight">2965</i>&nbsp;                                            List&lt;String&gt; targetDataTypeNames) {
<i class="no-highlight">2966</i>&nbsp;        List&lt;String&gt; casted = new ArrayList&lt;&gt;();
<i class="no-highlight">2967</i>&nbsp;
<i class="no-highlight">2968</i>&nbsp;        if (targetColumnNames.size() == targetDataTypeNames.size()) {
<i class="no-highlight">2969</i>&nbsp;            for (int i = 0; i &lt; targetColumnNames.size(); i++) {
<i class="no-highlight">2970</i>&nbsp;                casted.add(String.format(&quot;cast(%s as %s) as %s&quot;, targetColumnNames.get(i),
<i class="no-highlight">2971</i>&nbsp;                        targetDataTypeNames.get(i), targetColumnNames.get(i)));
<i class="no-highlight">2972</i>&nbsp;            }
<i class="no-highlight">2973</i>&nbsp;        }
<i class="no-highlight">2974</i>&nbsp;        return collectionToString(casted);
<i class="no-highlight">2975</i>&nbsp;    }
<i class="no-highlight">2976</i>&nbsp;
<b class="nc"><i class="no-highlight">2977</i>&nbsp;    /**</b>
<b class="nc"><i class="no-highlight">2978</i>&nbsp;     * Append file path to queryBuilder for ALTER TABLE load action</b>
<b class="nc"><i class="no-highlight">2979</i>&nbsp;     * when &quot;targetColumns&quot; is not empty but &quot;columnMappingMap&quot; is empty.</b>
<b class="nc"><i class="no-highlight">2980</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">2981</i>&nbsp;    private void appendStageFileWithNonEmptyColumnsForAlterTableDLP() {</b>
<b class="nc"><i class="no-highlight">2982</i>&nbsp;        String headerColumns = EMPTY_STRING;</b>
<i class="no-highlight">2983</i>&nbsp;        // Retrieve target table columns.
<b class="nc"><i class="no-highlight">2984</i>&nbsp;        List&lt;String&gt; targetTableColumns = getTargetColumnsAfterLoadAction();</b>
<b class="nc"><i class="no-highlight">2985</i>&nbsp;</b>
<i class="no-highlight">2986</i>&nbsp;        if (StringUtils.equalsIgnoreCase(fileFormatType, CSV)) {
<b class="nc"><i class="no-highlight">2987</i>&nbsp;            // If it is CSV file format, we assume the target table column names</b>
<i class="no-highlight">2988</i>&nbsp;            // are the same as the source file column names when the load action is
<b class="nc"><i class="no-highlight">2989</i>&nbsp;            // ALTER TABLE. This limitation will be lifted up with a next PR</b>
<b class="nc"><i class="no-highlight">2990</i>&nbsp;            // that greps the first header row with a direct read.</b>
<b class="nc"><i class="no-highlight">2991</i>&nbsp;            //</b>
<i class="no-highlight">2992</i>&nbsp;            // Note that if sourceFIleFieldNames.size() &lt; targetTableColumns, then
<b class="nc"><i class="no-highlight">2993</i>&nbsp;            // &quot;NULL AS column-name&quot; will be added to the COPY INTO SQL for extra</b>
<b class="nc"><i class="no-highlight">2994</i>&nbsp;            // target table columns and that</b>
<i class="no-highlight">2995</i>&nbsp;            // if sourceFIleFieldNames.size() &gt;= targetTableColumns, then
<i class="no-highlight">2996</i>&nbsp;            // COPY INTO SELECT clause will have target table column names (with
<b class="nc"><i class="no-highlight">2997</i>&nbsp;            // target and source column name equivalence assumption) so as</b>
<b class="nc"><i class="no-highlight">2998</i>&nbsp;            // to load into the target table correctly.</b>
<i class="no-highlight">2999</i>&nbsp;            headerColumns = getColumnsDefinitionsWithCastForType(
<i class="no-highlight">3000</i>&nbsp;                    targetTablePath,
<b class="nc"><i class="no-highlight">3001</i>&nbsp;                    targetTableColumns.size() &gt; sourceFileFieldNames.size() ?</b>
<i class="no-highlight">3002</i>&nbsp;                            targetTableColumns.subList(0, sourceFileFieldNames.size()) :
<b class="nc"><i class="no-highlight">3003</i>&nbsp;                            targetTableColumns);</b>
<i class="no-highlight">3004</i>&nbsp;        } else {
<i class="no-highlight">3005</i>&nbsp;            // If column list sizes of target table and source file are the same,
<i class="no-highlight">3006</i>&nbsp;            // then assume that there is a mapping between source and target.
<i class="no-highlight">3007</i>&nbsp;            if (sourceFileFieldNames.size() == targetTableColumns.size()) {
<b class="nc"><i class="no-highlight">3008</i>&nbsp;                headerColumns = getColumnsDefinitionsWithCastForType(</b>
<b class="nc"><i class="no-highlight">3009</i>&nbsp;                        targetTablePath, new ArrayList&lt;&gt;(sourceFileFieldNames));</b>
<b class="nc"><i class="no-highlight">3010</i>&nbsp;            } else {</b>
<i class="no-highlight">3011</i>&nbsp;                headerColumns = getColumnsDefinitionsWithCastForType(
<b class="nc"><i class="no-highlight">3012</i>&nbsp;                        targetTablePath, new ArrayList&lt;&gt;(sourceFileFieldNames));</b>
<b class="nc"><i class="no-highlight">3013</i>&nbsp;            }</b>
<i class="no-highlight">3014</i>&nbsp;        }
<i class="no-highlight">3015</i>&nbsp;
<i class="no-highlight">3016</i>&nbsp;        queryBuilder.append(String.format(
<i class="no-highlight">3017</i>&nbsp;                COPY_FROM_STAGED_FILE_COMMAND_WITH_DATA_TRANSFORMATION_DLP,
<b class="nc"><i class="no-highlight">3018</i>&nbsp;                targetTablePath, headerColumns, filePathStage));</b>
<b class="nc"><i class="no-highlight">3019</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">3020</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3021</i>&nbsp;    /**</b>
<b class="nc"><i class="no-highlight">3022</i>&nbsp;     * Append file path when, first both &quot;this.targetColumns&quot; and</b>
<i class="no-highlight">3023</i>&nbsp;     * &quot;this.columnMappingMap&quot; are not empty for DROP_CREATE action,
<b class="nc"><i class="no-highlight">3024</i>&nbsp;     * second &quot;this.columnMappingMap&quot; are not empty for OVERWRITE or APPEND action.</b>
<b class="nc"><i class="no-highlight">3025</i>&nbsp;     *</b>
<b class="nc"><i class="no-highlight">3026</i>&nbsp;     * ALTER case is N/A for this function since &quot;columnMappingMap&quot; is not used.</b>
<b class="nc"><i class="no-highlight">3027</i>&nbsp;     *</b>
<b class="nc"><i class="no-highlight">3028</i>&nbsp;     * We use source table column list support of COPY INTO in DLP.</b>
<b class="nc"><i class="no-highlight">3029</i>&nbsp;     */</b>
<i class="no-highlight">3030</i>&nbsp;    private void appendStageFilePathWithNonEmptyColumnsWithMapDLP() {
<b class="nc"><i class="no-highlight">3031</i>&nbsp;        verifyHeaderTrueForCSVFileFormatType();</b>
<b class="nc"><i class="no-highlight">3032</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3033</i>&nbsp;        Set&lt;String&gt; sourceTableColumns =</b>
<b class="nc"><i class="no-highlight">3034</i>&nbsp;                new HashSet&lt;&gt;(this.columnMappingMap.values());</b>
<i class="no-highlight">3035</i>&nbsp;        List&lt;String&gt; targetColumnNameListToScan = this.targetColumns;
<i class="no-highlight">3036</i>&nbsp;        if (StringUtils.equals(loadAction, OVERWRITE_TABLE) ||
<i class="no-highlight">3037</i>&nbsp;                StringUtils.equals(loadAction, APPEND_ROWS_TABLE)) {
<i class="no-highlight">3038</i>&nbsp;            targetColumnNameListToScan =
<i class="no-highlight">3039</i>&nbsp;                    new ArrayList&lt;String&gt;(findTableColumns(this.targetTableName));
<i class="no-highlight">3040</i>&nbsp;        }
<b class="nc"><i class="no-highlight">3041</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3042</i>&nbsp;        if (this.columnMappingMap.size() != targetColumnNameListToScan.size()) {</b>
<b class="nc"><i class="no-highlight">3043</i>&nbsp;            isSourceFileColumnListSizeDifferentFromTarget = true;</b>
<b class="nc"><i class="no-highlight">3044</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">3045</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3046</i>&nbsp;        // Append source column names from the map in target table column order</b>
<b class="nc"><i class="no-highlight">3047</i>&nbsp;        // if OVERWRITE or APPEND action, in &quot;targetColumns&quot; order if</b>
<i class="no-highlight">3048</i>&nbsp;        // DROP_CREATE action.
<i class="no-highlight">3049</i>&nbsp;        StringBuilder headerColumnsBuilder = new StringBuilder();
<b class="nc"><i class="no-highlight">3050</i>&nbsp;        boolean firstEntry = true;</b>
<i class="no-highlight">3051</i>&nbsp;        for (String targetColName : targetColumnNameListToScan) {
<b class="nc"><i class="no-highlight">3052</i>&nbsp;            String targetColNameToAppend = getColumnNameForSQLDLP(targetColName);</b>
<b class="nc"><i class="no-highlight">3053</i>&nbsp;            if (firstEntry) {</b>
<b class="nc"><i class="no-highlight">3054</i>&nbsp;                firstEntry = false;</b>
<b class="nc"><i class="no-highlight">3055</i>&nbsp;            } else {</b>
<b class="nc"><i class="no-highlight">3056</i>&nbsp;                headerColumnsBuilder.append(COMMA);</b>
<b class="nc"><i class="no-highlight">3057</i>&nbsp;            }</b>
<i class="no-highlight">3058</i>&nbsp;            if (sourceTableColumns.contains(targetColName)) {
<i class="no-highlight">3059</i>&nbsp;                headerColumnsBuilder.append(targetColNameToAppend);
<i class="no-highlight">3060</i>&nbsp;            } else {
<i class="no-highlight">3061</i>&nbsp;                // if the map keySet has the &quot;targetColName&quot;, then source file
<i class="no-highlight">3062</i>&nbsp;                // has a corresponding column for the &quot;targetColName&quot;.
<i class="no-highlight">3063</i>&nbsp;                if (this.columnMappingMap.containsKey(targetColName)) {
<i class="no-highlight">3064</i>&nbsp;                    String sourceColName = columnMappingMap.get(targetColName);
<i class="no-highlight">3065</i>&nbsp;                    String sourceColNameToAppend =
<i class="no-highlight">3066</i>&nbsp;                            isWrappedByChar(targetColNameToAppend, BACK_TICK_CHAR) ?
<i class="no-highlight">3067</i>&nbsp;                                    wrapWithCharIfNotYet(sourceColName, BACK_TICK_CHAR) :
<i class="no-highlight">3068</i>&nbsp;                                    sourceColName;
<i class="no-highlight">3069</i>&nbsp;                    headerColumnsBuilder
<i class="no-highlight">3070</i>&nbsp;                            .append(String.format(SOURCE_COLUMNL_AS_TARGET_COLUMN,
<i class="no-highlight">3071</i>&nbsp;                                    sourceColNameToAppend,
<i class="no-highlight">3072</i>&nbsp;                                    targetColNameToAppend));
<b class="nc"><i class="no-highlight">3073</i>&nbsp;                } else {</b>
<b class="nc"><i class="no-highlight">3074</i>&nbsp;                    // Otherwise, append &quot;targetColName AS NULL&quot;</b>
<i class="no-highlight">3075</i>&nbsp;                    headerColumnsBuilder
<b class="nc"><i class="no-highlight">3076</i>&nbsp;                            .append(String.format(NULL_AS_COLUMN, targetColNameToAppend));</b>
<b class="nc"><i class="no-highlight">3077</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">3078</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">3079</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">3080</i>&nbsp;        queryBuilder.append(String.format(</b>
<i class="no-highlight">3081</i>&nbsp;                COPY_FROM_STAGED_FILE_COMMAND_WITH_DATA_TRANSFORMATION_DLP,
<i class="no-highlight">3082</i>&nbsp;                targetTablePath, headerColumnsBuilder.toString(), filePathStage));
<i class="no-highlight">3083</i>&nbsp;    }
<i class="no-highlight">3084</i>&nbsp;    
<i class="no-highlight">3085</i>&nbsp;    private void verifyHeaderTrueForCSVFileFormatType() {
<i class="no-highlight">3086</i>&nbsp;        if (StringUtils.equalsIgnoreCase(fileFormatType, CSV) &amp;&amp;
<i class="no-highlight">3087</i>&nbsp;                !isFileFormatOptionHeaderTrue) {
<i class="no-highlight">3088</i>&nbsp;            throw new ConfigurationException(ERR_INVALID_HEADER_OPTION_FOR_CSV)
<i class="no-highlight">3089</i>&nbsp;                    .withReason(REASON_INVALID_HEADER_OPTION_FOR_CSV)
<i class="no-highlight">3090</i>&nbsp;                    .withResolution(RESOLUTION_INVALID_HEADER_OPTION_FOR_CSV);
<i class="no-highlight">3091</i>&nbsp;        }
<i class="no-highlight">3092</i>&nbsp;    }
<b class="nc"><i class="no-highlight">3093</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3094</i>&nbsp;    /**</b>
<b class="nc"><i class="no-highlight">3095</i>&nbsp;     * Appends COPY command when the CSV source file has</b>
<i class="no-highlight">3096</i>&nbsp;     * less number of fields than the target table columns.
<i class="no-highlight">3097</i>&nbsp;     * This function appends &quot;null as $colummnname&quot; for the extra target columns.
<b class="nc"><i class="no-highlight">3098</i>&nbsp;     * Note that this function assumes the order of source file fields matches</b>
<i class="no-highlight">3099</i>&nbsp;     * that of the target table columns. For example,
<b class="nc"><i class="no-highlight">3100</i>&nbsp;     * when you have col1, col2, col3 defined for the target columns,</b>
<i class="no-highlight">3101</i>&nbsp;     * the source file has col1 and col2. The missing field is col3 when
<i class="no-highlight">3102</i>&nbsp;     * you have less number of fields in the source.
<i class="no-highlight">3103</i>&nbsp;     *
<i class="no-highlight">3104</i>&nbsp;     * @param sourceTableSize soure table size
<i class="no-highlight">3105</i>&nbsp;     */
<i class="no-highlight">3106</i>&nbsp;    private void appendCsvFilePathWithNonEmptyLargerNumberOfColumnsDLP(
<i class="no-highlight">3107</i>&nbsp;            int sourceTableSize) {
<i class="no-highlight">3108</i>&nbsp;        StringBuilder headerColumnsBuilder = new StringBuilder();
<i class="no-highlight">3109</i>&nbsp;        boolean firstEntry = true;
<b class="nc"><i class="no-highlight">3110</i>&nbsp;        for (int i = 0; i &lt; targetColumns.size(); i++) {</b>
<b class="nc"><i class="no-highlight">3111</i>&nbsp;            String columnName = targetColumns.get(i);</b>
<b class="nc"><i class="no-highlight">3112</i>&nbsp;            if (isThereBacktickWrappedElementAtTargetColumns) {</b>
<b class="nc"><i class="no-highlight">3113</i>&nbsp;                columnName = getColumnNameForSQLDLP(columnName);</b>
<b class="nc"><i class="no-highlight">3114</i>&nbsp;            }</b>
<i class="no-highlight">3115</i>&nbsp;            if (firstEntry) {
<i class="no-highlight">3116</i>&nbsp;                firstEntry = false;
<b class="nc"><i class="no-highlight">3117</i>&nbsp;            } else {</b>
<i class="no-highlight">3118</i>&nbsp;                headerColumnsBuilder.append(COMMA);
<i class="no-highlight">3119</i>&nbsp;            }
<i class="no-highlight">3120</i>&nbsp;            if (i &lt; sourceTableSize) {
<b class="nc"><i class="no-highlight">3121</i>&nbsp;                if (inferSchemaEnabled) {</b>
<i class="no-highlight">3122</i>&nbsp;                    headerColumnsBuilder.append(columnName);
<b class="nc"><i class="no-highlight">3123</i>&nbsp;                } else {</b>
<b class="nc"><i class="no-highlight">3124</i>&nbsp;                    headerColumnsBuilder.append(String.format(&quot;cast(%s as %s) as %s&quot;, columnName,</b>
<b class="nc"><i class="no-highlight">3125</i>&nbsp;                            targetDataTypes.get(i), columnName));</b>
<i class="no-highlight">3126</i>&nbsp;                }
<b class="nc"><i class="no-highlight">3127</i>&nbsp;            } else {</b>
<i class="no-highlight">3128</i>&nbsp;                headerColumnsBuilder
<i class="no-highlight">3129</i>&nbsp;                        .append(String.format(NULL_AS_COLUMN, columnName));
<i class="no-highlight">3130</i>&nbsp;            }
<i class="no-highlight">3131</i>&nbsp;        }
<i class="no-highlight">3132</i>&nbsp;        queryBuilder.append(String.format(
<i class="no-highlight">3133</i>&nbsp;                COPY_FROM_STAGED_FILE_COMMAND_WITH_DATA_TRANSFORMATION_DLP,
<i class="no-highlight">3134</i>&nbsp;                targetTablePath, headerColumnsBuilder.toString(), filePathStage));
<i class="no-highlight">3135</i>&nbsp;    }
<i class="no-highlight">3136</i>&nbsp;
<i class="no-highlight">3137</i>&nbsp;    private boolean doesSourceTableColumnNamesMatchWithColumns(
<i class="no-highlight">3138</i>&nbsp;            Set&lt;String&gt; sourceTableColumns) {
<i class="no-highlight">3139</i>&nbsp;        for (String currentName : targetColumns) {
<i class="no-highlight">3140</i>&nbsp;            if (!sourceTableColumns.contains(currentName)) {
<i class="no-highlight">3141</i>&nbsp;                return false;
<i class="no-highlight">3142</i>&nbsp;            }
<i class="no-highlight">3143</i>&nbsp;        }
<i class="no-highlight">3144</i>&nbsp;        return true;
<i class="no-highlight">3145</i>&nbsp;    }
<i class="no-highlight">3146</i>&nbsp;
<i class="no-highlight">3147</i>&nbsp;    private void checkSourceTableColumnNamesHasMatchWithColumns(
<i class="no-highlight">3148</i>&nbsp;            Set&lt;String&gt; sourceTableColumns) {
<b class="nc"><i class="no-highlight">3149</i>&nbsp;        List&lt;String&gt; sourceColumnsWithoutMatch = new ArrayList&lt;&gt;();</b>
<b class="nc"><i class="no-highlight">3150</i>&nbsp;        Set&lt;String&gt; targetColumnSet = new HashSet&lt;&gt;(targetColumns);</b>
<b class="nc"><i class="no-highlight">3151</i>&nbsp;        for (String currentName : sourceTableColumns) {</b>
<i class="no-highlight">3152</i>&nbsp;            if (!targetColumnSet.contains(currentName)) {
<b class="nc"><i class="no-highlight">3153</i>&nbsp;                sourceColumnsWithoutMatch.add(currentName);</b>
<b class="nc"><i class="no-highlight">3154</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">3155</i>&nbsp;        }</b>
<i class="no-highlight">3156</i>&nbsp;        if (CollectionUtils.isNotEmpty(sourceColumnsWithoutMatch)) {
<i class="no-highlight">3157</i>&nbsp;            if (StringUtils.equalsIgnoreCase(fileFormatType, CSV)) {
<i class="no-highlight">3158</i>&nbsp;                throw new ConfigurationException(ERR_INVALID_CSV_SOURCE_COLUMN_NAMES_FOUND)
<b class="nc"><i class="no-highlight">3159</i>&nbsp;                        .withReason(REASON_INVALID_CSV_SOURCE_COLUMN_NAMES_FOUND)</b>
<b class="nc"><i class="no-highlight">3160</i>&nbsp;                        .withResolution(RESOLUTION_INVALID_CSV_SOURCE_COLUMN_NAMES_FOUND);</b>
<b class="nc"><i class="no-highlight">3161</i>&nbsp;            }</b>
<i class="no-highlight">3162</i>&nbsp;            throw new ConfigurationException(ERR_INVALID_SOURCE_COLUMN_NAMES_FOUND)
<i class="no-highlight">3163</i>&nbsp;                    .withReason(String.format(REASON_INVALID_SOURCE_COLUMN_NAMES_FOUND,
<i class="no-highlight">3164</i>&nbsp;                            String.join(COMMA_SPACE, sourceColumnsWithoutMatch)))
<b class="nc"><i class="no-highlight">3165</i>&nbsp;                    .withResolution(RESOLUTION_INVALID_SOURCE_COLUMN_NAMES_FOUND);</b>
<b class="nc"><i class="no-highlight">3166</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">3167</i>&nbsp;    }</b>
<i class="no-highlight">3168</i>&nbsp;
<b class="nc"><i class="no-highlight">3169</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">3170</i>&nbsp;    String getColumnsDefinitionsWithCastForType(String targetTablePath,</b>
<i class="no-highlight">3171</i>&nbsp;                                                final List&lt;String&gt; sourceTableColumns) {
<i class="no-highlight">3172</i>&nbsp;        StringBuilder sb = new StringBuilder();
<b class="nc"><i class="no-highlight">3173</i>&nbsp;        dbConnection = jdbcOperations.acquireConnection(account);</b>
<b class="nc"><i class="no-highlight">3174</i>&nbsp;        try (PreparedStatement stmt =</b>
<b class="nc"><i class="no-highlight">3175</i>&nbsp;                     dbConnection.prepareStatement(&quot;DESCRIBE TABLE &quot; + targetTablePath)) {</b>
<i class="no-highlight">3176</i>&nbsp;            try (ResultSet rs = stmt.executeQuery()) {
<i class="no-highlight">3177</i>&nbsp;                if (isAlterTableAndNonEmptyTargetColumns) {
<b class="nc"><i class="no-highlight">3178</i>&nbsp;                    buildCopyIntoColumnsForNonEmptyColumnsAndAlterTable(</b>
<i class="no-highlight">3179</i>&nbsp;                            rs, sourceTableColumns, sb);
<i class="no-highlight">3180</i>&nbsp;                } else {
<b class="nc"><i class="no-highlight">3181</i>&nbsp;                    buildColumnListWithCastForEmptyColumnsOrNonAlterTableActions(rs, sb);</b>
<i class="no-highlight">3182</i>&nbsp;                }
<i class="no-highlight">3183</i>&nbsp;            }
<i class="no-highlight">3184</i>&nbsp;            return sb.toString();
<i class="no-highlight">3185</i>&nbsp;        } catch (SQLException e) {
<i class="no-highlight">3186</i>&nbsp;            throw new SnapDataException(e, ERR_BULK_LOAD)
<i class="no-highlight">3187</i>&nbsp;                    .withReason(ERROR_PERFORMING_METADATA_RETRIEVAL)
<i class="no-highlight">3188</i>&nbsp;                    .withResolution(RESOLUTION_ADDRESS_ISSUE);
<b class="nc"><i class="no-highlight">3189</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">3190</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">3191</i>&nbsp;</b>
<i class="no-highlight">3192</i>&nbsp;    /**
<b class="nc"><i class="no-highlight">3193</i>&nbsp;     * Build and return column list with CastForType for</b>
<b class="nc"><i class="no-highlight">3194</i>&nbsp;     * empty targetColumns or for non ALTER TABLE load action.</b>
<i class="no-highlight">3195</i>&nbsp;     * I.e., DROP and CREATE TABLE, OVERWRITE and APPEND load action.
<i class="no-highlight">3196</i>&nbsp;     *
<i class="no-highlight">3197</i>&nbsp;     * @param rs    IN: ResultSet after DESCRIBE TABLE execution
<i class="no-highlight">3198</i>&nbsp;     * @param sb    OUT: StringBuilder to create column list
<i class="no-highlight">3199</i>&nbsp;     * @throws SQLException
<i class="no-highlight">3200</i>&nbsp;     */
<b class="nc"><i class="no-highlight">3201</i>&nbsp;    private void buildColumnListWithCastForEmptyColumnsOrNonAlterTableActions(</b>
<b class="nc"><i class="no-highlight">3202</i>&nbsp;            ResultSet rs, StringBuilder sb) throws SQLException {</b>
<i class="no-highlight">3203</i>&nbsp;
<b class="nc"><i class="no-highlight">3204</i>&nbsp;        while (rs.next() &amp;&amp; StringUtils.isNotBlank(rs.getString(DLP_COL_NAME_HEADER)) &amp;&amp;</b>
<b class="nc"><i class="no-highlight">3205</i>&nbsp;                (targetColumns.isEmpty()</b>
<i class="no-highlight">3206</i>&nbsp;                        || targetColumns
<i class="no-highlight">3207</i>&nbsp;                        .contains(rs.getString(DLP_COL_NAME_HEADER)))) {
<b class="nc"><i class="no-highlight">3208</i>&nbsp;            String targetColName = rs.getString(DLP_COL_NAME_HEADER);</b>
<i class="no-highlight">3209</i>&nbsp;            String targetColNameToAppend = getColumnNameForSQLDLP(targetColName);
<i class="no-highlight">3210</i>&nbsp;            if (sb.length() != 0) {
<i class="no-highlight">3211</i>&nbsp;                sb.append(COMMA);
<i class="no-highlight">3212</i>&nbsp;            }
<i class="no-highlight">3213</i>&nbsp;            // If the current targetColName is wrapped with backtick from the UI, like,
<i class="no-highlight">3214</i>&nbsp;            // &quot;CREATE OR REPLACE TABLE default.BINARY_TEST510
<i class="no-highlight">3215</i>&nbsp;            //	(type STRING,v STRING,`r.b` BINARY,date TIMESTAMP,t
<i class="no-highlight">3216</i>&nbsp;            //   TIMESTAMP,date2 DATE) USING DELTA;&quot;,
<i class="no-highlight">3217</i>&nbsp;            // then use the backtick wrapped column name to make it work.
<i class="no-highlight">3218</i>&nbsp;            // I.e., build the part for `r.b` like the below:
<i class="no-highlight">3219</i>&nbsp;            // &quot;SELECT type, v, CAST(`r.b` AS binary) AS `r.b`, date, t, null as date2 &quot;.
<b class="nc"><i class="no-highlight">3220</i>&nbsp;            // Note that `r.b` is used both locations at &quot;CAST(`r.b` AS binary) AS `r.b`&quot;.</b>
<b class="nc"><i class="no-highlight">3221</i>&nbsp;            // Also note the source file header for CSV file format should have this line</b>
<b class="nc"><i class="no-highlight">3222</i>&nbsp;            // type,v,r.b,date,t</b>
<b class="nc"><i class="no-highlight">3223</i>&nbsp;            // as its header.</b>
<b class="nc"><i class="no-highlight">3224</i>&nbsp;            String dataTypeForColumn = rs.getString(DLP_DATA_TYPE_HEADER).toLowerCase();</b>
<b class="nc"><i class="no-highlight">3225</i>&nbsp;            if (DATA_TYPES_TO_CAST_DLP.contains(dataTypeForColumn)) {</b>
<b class="nc"><i class="no-highlight">3226</i>&nbsp;                sb.append(String.format(CAST_DLP, targetColNameToAppend,</b>
<b class="nc"><i class="no-highlight">3227</i>&nbsp;                        dataTypeForColumn, targetColNameToAppend));</b>
<b class="nc"><i class="no-highlight">3228</i>&nbsp;            } else {</b>
<b class="nc"><i class="no-highlight">3229</i>&nbsp;                sb.append(targetColNameToAppend);</b>
<b class="nc"><i class="no-highlight">3230</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">3231</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">3232</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">3233</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3234</i>&nbsp;    /**</b>
<b class="nc"><i class="no-highlight">3235</i>&nbsp;     * Returns backtick wrapped column name if</b>
<b class="nc"><i class="no-highlight">3236</i>&nbsp;     * the column name is originally configured in the UI as such.</b>
<b class="nc"><i class="no-highlight">3237</i>&nbsp;     *</b>
<i class="no-highlight">3238</i>&nbsp;     * @return column name originally configured.
<i class="no-highlight">3239</i>&nbsp;     */
<b class="nc"><i class="no-highlight">3240</i>&nbsp;    private String getColumnNameForSQLDLP(String colName) {</b>
<i class="no-highlight">3241</i>&nbsp;        String colNameToReturn = colName;
<b class="nc"><i class="no-highlight">3242</i>&nbsp;        if (isThereBacktickWrappedElementAtTargetColumns) {</b>
<b class="nc"><i class="no-highlight">3243</i>&nbsp;            int idx = targetColumns.indexOf(colName);</b>
<i class="no-highlight">3244</i>&nbsp;            if (isWrappedByChar(targetColumnsWithBacktick.get(idx), BACK_TICK_CHAR)) {
<i class="no-highlight">3245</i>&nbsp;                colNameToReturn = targetColumnsWithBacktick.get(idx);
<b class="nc"><i class="no-highlight">3246</i>&nbsp;            }</b>
<i class="no-highlight">3247</i>&nbsp;        }
<b class="nc"><i class="no-highlight">3248</i>&nbsp;        return colNameToReturn;</b>
<i class="no-highlight">3249</i>&nbsp;    }
<i class="no-highlight">3250</i>&nbsp;
<i class="no-highlight">3251</i>&nbsp;    private Map&lt;String, String&gt; getResultSetColumnNameTypeMap(ResultSet rs) throws SQLException {
<i class="no-highlight">3252</i>&nbsp;        Map&lt;String, String&gt; columnNameTypeMap = new LinkedHashMap&lt;&gt;();
<i class="no-highlight">3253</i>&nbsp;
<b class="nc"><i class="no-highlight">3254</i>&nbsp;        while (rs.next() &amp;&amp; StringUtils.isNotBlank(rs.getString(DLP_COL_NAME_HEADER))) {</b>
<b class="nc"><i class="no-highlight">3255</i>&nbsp;            columnNameTypeMap.put(rs.getString(DLP_COL_NAME_HEADER),</b>
<b class="nc"><i class="no-highlight">3256</i>&nbsp;                    rs.getString(DLP_DATA_TYPE_HEADER).toLowerCase());</b>
<b class="nc"><i class="no-highlight">3257</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">3258</i>&nbsp;        return columnNameTypeMap;</b>
<b class="nc"><i class="no-highlight">3259</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">3260</i>&nbsp;</b>
<i class="no-highlight">3261</i>&nbsp;    /**
<i class="no-highlight">3262</i>&nbsp;     * Build and return COPY INTO statement column list with CastForType for
<i class="no-highlight">3263</i>&nbsp;     * non empty targetColumns and ALTER TABLE load action.
<i class="no-highlight">3264</i>&nbsp;     *
<i class="no-highlight">3265</i>&nbsp;     * Note that there is a behavioral difference of this function for CSV type source file and
<i class="no-highlight">3266</i>&nbsp;     * non-CSV type. Column name comparing and matching between the source file and
<b class="nc"><i class="no-highlight">3267</i>&nbsp;     * the target table only happens for non-CSV source file type.</b>
<b class="nc"><i class="no-highlight">3268</i>&nbsp;     * If the source file is of CSV type, we just pair them without checking names.</b>
<i class="no-highlight">3269</i>&nbsp;     * If the target has more columns then append &quot;NULL AS column-name&quot;
<b class="nc"><i class="no-highlight">3270</i>&nbsp;     * for the extra columns.</b>
<i class="no-highlight">3271</i>&nbsp;     *
<b class="nc"><i class="no-highlight">3272</i>&nbsp;     * @param rs    IN: ResultSet after DESCRIBE TABLE execution</b>
<b class="nc"><i class="no-highlight">3273</i>&nbsp;     * @param sourceTableColumns    IN: source file column names</b>
<i class="no-highlight">3274</i>&nbsp;     * @param sb    OUT: StringBuilder to create column list
<b class="nc"><i class="no-highlight">3275</i>&nbsp;     * @throws SQLException</b>
<i class="no-highlight">3276</i>&nbsp;     */
<i class="no-highlight">3277</i>&nbsp;    private void buildCopyIntoColumnsForNonEmptyColumnsAndAlterTable(
<i class="no-highlight">3278</i>&nbsp;            ResultSet rs, List&lt;String&gt; sourceTableColumns,
<b class="nc"><i class="no-highlight">3279</i>&nbsp;            StringBuilder sb) throws SQLException {</b>
<i class="no-highlight">3280</i>&nbsp;        Map&lt;String, String&gt; targetColumnNameTypeMap = getResultSetColumnNameTypeMap(rs);
<b class="nc"><i class="no-highlight">3281</i>&nbsp;        List&lt;String&gt; targetColumnNames = new ArrayList&lt;&gt;(targetColumnNameTypeMap.keySet());</b>
<i class="no-highlight">3282</i>&nbsp;        List&lt;String&gt; targetColumnTypes = new ArrayList&lt;&gt;(targetColumnNameTypeMap.values());
<b class="nc"><i class="no-highlight">3283</i>&nbsp;</b>
<i class="no-highlight">3284</i>&nbsp;        if (StringUtils.equalsIgnoreCase(fileFormatType, CSV)) {
<b class="nc"><i class="no-highlight">3285</i>&nbsp;            buildCopyIntoColumnsForNonEmptyColumnsForAlterTableCSV(</b>
<i class="no-highlight">3286</i>&nbsp;                    sb, targetColumnNames, targetColumnTypes, sourceTableColumns.size());
<i class="no-highlight">3287</i>&nbsp;            return;
<b class="nc"><i class="no-highlight">3288</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">3289</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3290</i>&nbsp;        int i = 0;</b>
<i class="no-highlight">3291</i>&nbsp;        String currentTgtColName = EMPTY_STRING;
<i class="no-highlight">3292</i>&nbsp;        Set&lt;String&gt; sourceColumnNameSet = new HashSet&lt;String&gt;(sourceTableColumns);
<i class="no-highlight">3293</i>&nbsp;
<i class="no-highlight">3294</i>&nbsp;        // Source file field list size &lt;= target table column list size and
<b class="nc"><i class="no-highlight">3295</i>&nbsp;        // a source field name has its entry in the target column list.</b>
<i class="no-highlight">3296</i>&nbsp;        for (; i &lt; targetColumnNames.size(); i++) {
<b class="nc"><i class="no-highlight">3297</i>&nbsp;            currentTgtColName = targetColumnNames.get(i);</b>
<b class="nc"><i class="no-highlight">3298</i>&nbsp;            String dataTypeForColumn = targetColumnTypes.get(i);</b>
<b class="nc"><i class="no-highlight">3299</i>&nbsp;</b>
<i class="no-highlight">3300</i>&nbsp;            if (sb.length() != 0) {
<i class="no-highlight">3301</i>&nbsp;                sb.append(COMMA);
<b class="nc"><i class="no-highlight">3302</i>&nbsp;            }</b>
<i class="no-highlight">3303</i>&nbsp;
<i class="no-highlight">3304</i>&nbsp;            if (sourceColumnNameSet.contains(currentTgtColName)) {
<i class="no-highlight">3305</i>&nbsp;                if (DATA_TYPES_TO_CAST_DLP.contains(dataTypeForColumn)) {
<i class="no-highlight">3306</i>&nbsp;                    sb.append(String.format(
<i class="no-highlight">3307</i>&nbsp;                            CAST_DLP, currentTgtColName, dataTypeForColumn, currentTgtColName));
<b class="nc"><i class="no-highlight">3308</i>&nbsp;                } else {</b>
<i class="no-highlight">3309</i>&nbsp;                    sb.append(currentTgtColName);
<i class="no-highlight">3310</i>&nbsp;                }
<b class="nc"><i class="no-highlight">3311</i>&nbsp;            } else {</b>
<i class="no-highlight">3312</i>&nbsp;                sb.append(String.format(NULL_AS_COLUMN, currentTgtColName));
<i class="no-highlight">3313</i>&nbsp;            }
<i class="no-highlight">3314</i>&nbsp;        }
<b class="nc"><i class="no-highlight">3315</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">3316</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3317</i>&nbsp;    private void buildCopyIntoColumnsForNonEmptyColumnsForAlterTableCSV(</b>
<b class="nc"><i class="no-highlight">3318</i>&nbsp;            StringBuilder sb, List&lt;String&gt; targetColumnNames, List&lt;String&gt; targetColumnTypes,</b>
<i class="no-highlight">3319</i>&nbsp;            int sourceFileFieldListSize) {
<i class="no-highlight">3320</i>&nbsp;        for (int i = 0; i &lt; targetColumnNames.size(); i++) {
<i class="no-highlight">3321</i>&nbsp;            String currentColName = targetColumnNames.get(i);
<i class="no-highlight">3322</i>&nbsp;            String dataTypeForColumn = targetColumnTypes.get(i);
<i class="no-highlight">3323</i>&nbsp;
<i class="no-highlight">3324</i>&nbsp;            if (sb.length() != 0) {
<i class="no-highlight">3325</i>&nbsp;                sb.append(COMMA);
<i class="no-highlight">3326</i>&nbsp;            }
<b class="nc"><i class="no-highlight">3327</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3328</i>&nbsp;            // Add &quot;NULL AS $currentColName&quot; if the target has more columns</b>
<i class="no-highlight">3329</i>&nbsp;            // than the source file.
<b class="nc"><i class="no-highlight">3330</i>&nbsp;            // If CAST type, append CAST clause.</b>
<b class="nc"><i class="no-highlight">3331</i>&nbsp;            // add column name otherwise.</b>
<i class="no-highlight">3332</i>&nbsp;            if (i &gt;= sourceFileFieldListSize) {
<b class="nc"><i class="no-highlight">3333</i>&nbsp;                sb.append(String.format(NULL_AS_COLUMN, currentColName));</b>
<i class="no-highlight">3334</i>&nbsp;            } else {
<i class="no-highlight">3335</i>&nbsp;                if (DATA_TYPES_TO_CAST_DLP.contains(dataTypeForColumn)) {
<i class="no-highlight">3336</i>&nbsp;                    sb.append(String.format(
<b class="nc"><i class="no-highlight">3337</i>&nbsp;                            CAST_DLP, currentColName, dataTypeForColumn, currentColName));</b>
<i class="no-highlight">3338</i>&nbsp;                } else {
<b class="nc"><i class="no-highlight">3339</i>&nbsp;                    sb.append(currentColName);</b>
<i class="no-highlight">3340</i>&nbsp;                }
<i class="no-highlight">3341</i>&nbsp;            }
<i class="no-highlight">3342</i>&nbsp;        }
<i class="no-highlight">3343</i>&nbsp;    }
<b class="nc"><i class="no-highlight">3344</i>&nbsp;</b>
<i class="no-highlight">3345</i>&nbsp;    /**
<i class="no-highlight">3346</i>&nbsp;     * Return a Map for DATA_TYPES_TO_CAST_DLP type targetColumns to be replaced.
<i class="no-highlight">3347</i>&nbsp;     */
<i class="no-highlight">3348</i>&nbsp;    @VisibleForTesting
<i class="no-highlight">3349</i>&nbsp;    Map&lt;String, String&gt; getColumnMapWithCastForType(String targetTablePath,
<i class="no-highlight">3350</i>&nbsp;                                                    Set&lt;String&gt; targetColumns) {
<b class="nc"><i class="no-highlight">3351</i>&nbsp;        Map&lt;String, String&gt; toChangeColumnMap = new LinkedHashMap&lt;&gt;();</b>
<i class="no-highlight">3352</i>&nbsp;        dbConnection = jdbcOperations.acquireConnection(account);
<b class="nc"><i class="no-highlight">3353</i>&nbsp;        try (PreparedStatement stmt =</b>
<i class="no-highlight">3354</i>&nbsp;                     dbConnection.prepareStatement(&quot;DESCRIBE TABLE &quot; + targetTablePath)) {
<i class="no-highlight">3355</i>&nbsp;            try (ResultSet rs = stmt.executeQuery()) {
<i class="no-highlight">3356</i>&nbsp;                while (rs.next() &amp;&amp; StringUtils.isNotBlank(rs.getString(DLP_COL_NAME_HEADER))) {
<i class="no-highlight">3357</i>&nbsp;                    String targetColName = rs.getString(DLP_COL_NAME_HEADER);
<i class="no-highlight">3358</i>&nbsp;                    String targetColNameToAppend = getColumnNameForSQLDLP(targetColName);
<i class="no-highlight">3359</i>&nbsp;                    if (targetColumns.isEmpty()
<i class="no-highlight">3360</i>&nbsp;                                || targetColumns.contains(targetColName)) {
<b class="nc"><i class="no-highlight">3361</i>&nbsp;                        String dataTypeForColumn = rs.getString(DLP_DATA_TYPE_HEADER).toLowerCase();</b>
<i class="no-highlight">3362</i>&nbsp;                        if (DATA_TYPES_TO_CAST_DLP.contains(dataTypeForColumn)) {
<i class="no-highlight">3363</i>&nbsp;                            String sourceColName = targetColName;
<b class="nc"><i class="no-highlight">3364</i>&nbsp;                            String sourceColNameToAppend = targetColNameToAppend;</b>
<b class="nc"><i class="no-highlight">3365</i>&nbsp;                            if (MapUtils.isNotEmpty(this.columnMappingMap)) {</b>
<i class="no-highlight">3366</i>&nbsp;                                sourceColName = this.columnMappingMap.get(targetColName);
<b class="nc"><i class="no-highlight">3367</i>&nbsp;                                if (StringUtils.isBlank(sourceColName)) {</b>
<b class="nc"><i class="no-highlight">3368</i>&nbsp;                                    continue;</b>
<i class="no-highlight">3369</i>&nbsp;                                }
<b class="nc"><i class="no-highlight">3370</i>&nbsp;                                sourceColNameToAppend =</b>
<b class="nc"><i class="no-highlight">3371</i>&nbsp;                                    isWrappedByChar(</b>
<i class="no-highlight">3372</i>&nbsp;                                        targetColNameToAppend, BACK_TICK_CHAR) ?
<i class="no-highlight">3373</i>&nbsp;                                            wrapWithCharIfNotYet(sourceColName, BACK_TICK_CHAR) :
<i class="no-highlight">3374</i>&nbsp;                                            sourceColName;
<b class="nc"><i class="no-highlight">3375</i>&nbsp;                            }</b>
<b class="nc"><i class="no-highlight">3376</i>&nbsp;</b>
<i class="no-highlight">3377</i>&nbsp;                            toChangeColumnMap.put(
<i class="no-highlight">3378</i>&nbsp;                                    targetColNameToAppend,
<i class="no-highlight">3379</i>&nbsp;                                    String.format(
<i class="no-highlight">3380</i>&nbsp;                                            CAST_DLP,
<i class="no-highlight">3381</i>&nbsp;                                            sourceColNameToAppend,
<b class="nc"><i class="no-highlight">3382</i>&nbsp;                                            dataTypeForColumn, targetColNameToAppend));</b>
<b class="nc"><i class="no-highlight">3383</i>&nbsp;                        }</b>
<i class="no-highlight">3384</i>&nbsp;                    }
<b class="nc"><i class="no-highlight">3385</i>&nbsp;                }</b>
<i class="no-highlight">3386</i>&nbsp;            }
<i class="no-highlight">3387</i>&nbsp;            return toChangeColumnMap;
<i class="no-highlight">3388</i>&nbsp;        } catch (SQLException e) {
<i class="no-highlight">3389</i>&nbsp;            throw new SnapDataException(e, ERR_BULK_LOAD)
<i class="no-highlight">3390</i>&nbsp;                    .withReason(ERROR_PERFORMING_METADATA_RETRIEVAL)
<i class="no-highlight">3391</i>&nbsp;                    .withResolution(RESOLUTION_ADDRESS_ISSUE);
<i class="no-highlight">3392</i>&nbsp;        }
<i class="no-highlight">3393</i>&nbsp;    }
<b class="nc"><i class="no-highlight">3394</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3395</i>&nbsp;    private void appendFilesOrPatternTypeSnowflake() {</b>
<i class="no-highlight">3396</i>&nbsp;        // Return with no op when transformation is done with
<i class="no-highlight">3397</i>&nbsp;        // external stage object and source column list from the map.
<i class="no-highlight">3398</i>&nbsp;        if (needTransformationPreaction &amp;&amp; !isSnowflakeTransformPreprocessingRequired) {
<b class="nc"><i class="no-highlight">3399</i>&nbsp;            prependFileFolderToFilePaths();</b>
<b class="nc"><i class="no-highlight">3400</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">3401</i>&nbsp;        if (CollectionUtils.isNotEmpty(filePaths)) {</b>
<i class="no-highlight">3402</i>&nbsp;            // Format: FILES = ( &#39;file1&#39;,&#39;file2&#39;,&#39;file3&#39;... )
<i class="no-highlight">3403</i>&nbsp;            queryBuilder.append(String.format(
<i class="no-highlight">3404</i>&nbsp;                    FILES_FMT, StringUtils.join(filePaths, COMMA_WITH_QUOTES)));
<b class="nc"><i class="no-highlight">3405</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">3406</i>&nbsp;        prependFileFolderToFilePattern();</b>
<b class="nc"><i class="no-highlight">3407</i>&nbsp;    }</b>
<i class="no-highlight">3408</i>&nbsp;
<b class="nc"><i class="no-highlight">3409</i>&nbsp;    private String getFileFolder() {</b>
<b class="nc"><i class="no-highlight">3410</i>&nbsp;        switch (eltDatabaseAccount.getSourceLocation()) {</b>
<b class="nc"><i class="no-highlight">3411</i>&nbsp;            case AMAZON_S3:</b>
<i class="no-highlight">3412</i>&nbsp;                return eltDatabaseAccount.getFolderPath();
<b class="nc"><i class="no-highlight">3413</i>&nbsp;            case AZURE:</b>
<b class="nc"><i class="no-highlight">3414</i>&nbsp;                return eltDatabaseAccount.getAzureFolder();</b>
<b class="nc"><i class="no-highlight">3415</i>&nbsp;            case GOOGLE_CLOUD_STORAGE:</b>
<i class="no-highlight">3416</i>&nbsp;                return eltDatabaseAccount.getGCSFolderPath();
<i class="no-highlight">3417</i>&nbsp;            case NONE:
<i class="no-highlight">3418</i>&nbsp;            default:
<b class="nc"><i class="no-highlight">3419</i>&nbsp;                throw new ConfigurationException(ERR_BLANK_SOURCE_LOCATION)</b>
<i class="no-highlight">3420</i>&nbsp;                        .withReason(REASON_BLANK_SOURCE_LOCATION)
<b class="nc"><i class="no-highlight">3421</i>&nbsp;                        .withResolution(RESOLUTION_BLANK_SOURCE_LOCATION);</b>
<i class="no-highlight">3422</i>&nbsp;        }
<b class="nc"><i class="no-highlight">3423</i>&nbsp;    }</b>
<i class="no-highlight">3424</i>&nbsp;
<i class="no-highlight">3425</i>&nbsp;    private void prependFileFolderToFilePattern() {
<i class="no-highlight">3426</i>&nbsp;        String fileFolder = getFileFolder();
<b class="nc"><i class="no-highlight">3427</i>&nbsp;</b>
<i class="no-highlight">3428</i>&nbsp;        if (StringUtils.isNotBlank(filePattern)) {
<b class="nc"><i class="no-highlight">3429</i>&nbsp;            if (StringUtils.isNotBlank(fileFolder)) {</b>
<i class="no-highlight">3430</i>&nbsp;                queryBuilder.append(String.format(FILE_FOLDER_FORMAT_PATTERN,
<b class="nc"><i class="no-highlight">3431</i>&nbsp;                        fileFolder, filePattern));</b>
<b class="nc"><i class="no-highlight">3432</i>&nbsp;            } else {</b>
<b class="nc"><i class="no-highlight">3433</i>&nbsp;                queryBuilder.append(String.format(FILE_FORMAT_PATTERN, filePattern));</b>
<b class="nc"><i class="no-highlight">3434</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">3435</i>&nbsp;        }</b>
<i class="no-highlight">3436</i>&nbsp;    }
<b class="nc"><i class="no-highlight">3437</i>&nbsp;</b>
<i class="no-highlight">3438</i>&nbsp;    private void prependFileFolderToFilePaths() {
<i class="no-highlight">3439</i>&nbsp;        String folderPath = getFileFolder();
<b class="nc"><i class="no-highlight">3440</i>&nbsp;</b>
<i class="no-highlight">3441</i>&nbsp;        // If foldPath is blank, theire is nothing to do. Thus just return.
<b class="nc"><i class="no-highlight">3442</i>&nbsp;        if (StringUtils.isBlank(folderPath)) {</b>
<i class="no-highlight">3443</i>&nbsp;            return;
<b class="nc"><i class="no-highlight">3444</i>&nbsp;        }</b>
<i class="no-highlight">3445</i>&nbsp;
<i class="no-highlight">3446</i>&nbsp;        for (int i = 0; i &lt; filePaths.size(); i++) {
<i class="no-highlight">3447</i>&nbsp;            String filePath = filePaths.get(i);
<b class="nc"><i class="no-highlight">3448</i>&nbsp;            filePath = String.format(PREPEND_FOLDER_FMT, folderPath, filePath);</b>
<b class="nc"><i class="no-highlight">3449</i>&nbsp;            filePaths.set(i, filePath);</b>
<b class="nc"><i class="no-highlight">3450</i>&nbsp;        }</b>
<i class="no-highlight">3451</i>&nbsp;    }
<i class="no-highlight">3452</i>&nbsp;
<i class="no-highlight">3453</i>&nbsp;    /**
<b class="nc"><i class="no-highlight">3454</i>&nbsp;     * Sets up this.files if needed for further steps in EltLoad</b>
<i class="no-highlight">3455</i>&nbsp;     * with this.filePaths or this.filePattern.
<i class="no-highlight">3456</i>&nbsp;     */
<i class="no-highlight">3457</i>&nbsp;    private void getInputFileListIfNeeded() {
<b class="nc"><i class="no-highlight">3458</i>&nbsp;        String dbType = getName();</b>
<b class="nc"><i class="no-highlight">3459</i>&nbsp;        switch (dbType) {</b>
<b class="nc"><i class="no-highlight">3460</i>&nbsp;            case JdbcOperations.SNOWFLAKE:</b>
<i class="no-highlight">3461</i>&nbsp;                getFilesForSnowflakeSchemaInference();
<i class="no-highlight">3462</i>&nbsp;                break;
<i class="no-highlight">3463</i>&nbsp;            case JdbcOperations.REDSHIFT:
<b class="nc"><i class="no-highlight">3464</i>&nbsp;                if (CollectionUtils.isNotEmpty(filePaths)) {</b>
<i class="no-highlight">3465</i>&nbsp;                    // Redshift allows loading from one file at a time
<b class="nc"><i class="no-highlight">3466</i>&nbsp;                    // so we need to get all files first</b>
<i class="no-highlight">3467</i>&nbsp;                    // and then invoke multiple copy commands if needed
<b class="nc"><i class="no-highlight">3468</i>&nbsp;                    files.addAll(filePaths);</b>
<b class="nc"><i class="no-highlight">3469</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">3470</i>&nbsp;                if (StringUtils.isNotBlank(filePattern)) {</b>
<b class="nc"><i class="no-highlight">3471</i>&nbsp;                    /* Redshift COPY command does not allow to load files based on pattern matching</b>
<b class="nc"><i class="no-highlight">3472</i>&nbsp;                     * So, we will find all the pattern of files in S3 folder and load them for</b>
<i class="no-highlight">3473</i>&nbsp;                     * Redshift;
<b class="nc"><i class="no-highlight">3474</i>&nbsp;                     */</b>
<i class="no-highlight">3475</i>&nbsp;                    getFilesForFilePatternRedshift();
<i class="no-highlight">3476</i>&nbsp;                }
<b class="nc"><i class="no-highlight">3477</i>&nbsp;                break;</b>
<i class="no-highlight">3478</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:
<b class="nc"><i class="no-highlight">3479</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:</b>
<i class="no-highlight">3480</i>&nbsp;            case JdbcOperations.BIGQUERY:
<b class="nc"><i class="no-highlight">3481</i>&nbsp;                // We are just bypassing current function for these db types.</b>
<i class="no-highlight">3482</i>&nbsp;                break;
<i class="no-highlight">3483</i>&nbsp;            default:
<i class="no-highlight">3484</i>&nbsp;                throwInvalidDbTypeException();
<i class="no-highlight">3485</i>&nbsp;        }
<i class="no-highlight">3486</i>&nbsp;    }
<i class="no-highlight">3487</i>&nbsp;
<i class="no-highlight">3488</i>&nbsp;    /**
<b class="nc"><i class="no-highlight">3489</i>&nbsp;     * Set up this.files if inferSchemaEnabled is true.</b>
<i class="no-highlight">3490</i>&nbsp;     */
<i class="no-highlight">3491</i>&nbsp;    private void getFilesForSnowflakeSchemaInference() {
<i class="no-highlight">3492</i>&nbsp;        if (!inferSchemaEnabled) {
<b class="nc"><i class="no-highlight">3493</i>&nbsp;            return;</b>
<i class="no-highlight">3494</i>&nbsp;        }
<i class="no-highlight">3495</i>&nbsp;        String sourceLocation = eltDatabaseAccount.getSourceLocation();
<b class="nc"><i class="no-highlight">3496</i>&nbsp;        switch (sourceLocation) {</b>
<b class="nc"><i class="no-highlight">3497</i>&nbsp;            case AMAZON_S3:</b>
<i class="no-highlight">3498</i>&nbsp;                if (CollectionUtils.isNotEmpty(filePaths)) {
<i class="no-highlight">3499</i>&nbsp;                    files.addAll(filePaths);
<i class="no-highlight">3500</i>&nbsp;                }
<i class="no-highlight">3501</i>&nbsp;                if (StringUtils.isNotBlank(filePattern)) {
<b class="nc"><i class="no-highlight">3502</i>&nbsp;                    getFilesForFilePatternSnowflake();</b>
<b class="nc"><i class="no-highlight">3503</i>&nbsp;                }</b>
<i class="no-highlight">3504</i>&nbsp;                break;
<i class="no-highlight">3505</i>&nbsp;            case GOOGLE_CLOUD_STORAGE:
<b class="nc"><i class="no-highlight">3506</i>&nbsp;                if (CollectionUtils.isNotEmpty(filePaths)) {</b>
<b class="nc"><i class="no-highlight">3507</i>&nbsp;                    files.addAll(filePaths);</b>
<b class="nc"><i class="no-highlight">3508</i>&nbsp;                }</b>
<i class="no-highlight">3509</i>&nbsp;                // @TODO filPattern is not yet supported
<i class="no-highlight">3510</i>&nbsp;                // if not supported, throw an exception here
<i class="no-highlight">3511</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">3512</i>&nbsp;            case AZURE:</b>
<b class="nc"><i class="no-highlight">3513</i>&nbsp;                getAzureStorageFilesForSchemaInferenceSnowflake();</b>
<i class="no-highlight">3514</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">3515</i>&nbsp;            default:</b>
<i class="no-highlight">3516</i>&nbsp;                throwExceptionIfInvalidSourceLocationForDetector(sourceLocation, getName());
<i class="no-highlight">3517</i>&nbsp;        }
<b class="nc"><i class="no-highlight">3518</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">3519</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3520</i>&nbsp;    /**</b>
<b class="nc"><i class="no-highlight">3521</i>&nbsp;     * Populate filesForSchemaInference for Schema Inference</b>
<i class="no-highlight">3522</i>&nbsp;     * for both File List and File Name Pattern cases.
<b class="nc"><i class="no-highlight">3523</i>&nbsp;     */</b>
<i class="no-highlight">3524</i>&nbsp;    private void getAzureStorageFilesForSchemaInferenceSnowflake() {
<b class="nc"><i class="no-highlight">3525</i>&nbsp;        files.addAll(filePaths);</b>
<b class="nc"><i class="no-highlight">3526</i>&nbsp;        getAzureStorageFilesForFilePatternSnowflake();</b>
<i class="no-highlight">3527</i>&nbsp;    }
<i class="no-highlight">3528</i>&nbsp;
<i class="no-highlight">3529</i>&nbsp;    private void getFilesForFilePatternRedshift() {
<i class="no-highlight">3530</i>&nbsp;        files.clear();
<b class="nc"><i class="no-highlight">3531</i>&nbsp;        String redshiftAuthType = eltDatabaseAccount.getRedshiftAuthType();</b>
<b class="nc"><i class="no-highlight">3532</i>&nbsp;        listFilesRedshift(getAWSCredentialsProviderRedshift(redshiftAuthType));</b>
<i class="no-highlight">3533</i>&nbsp;    }
<b class="nc"><i class="no-highlight">3534</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3535</i>&nbsp;    private AWSCredentialsProvider getAWSCredentialsProvider() {</b>
<i class="no-highlight">3536</i>&nbsp;        AWSCredentialsProvider provider = null;
<b class="nc"><i class="no-highlight">3537</i>&nbsp;        String dbType = getName();</b>
<b class="nc"><i class="no-highlight">3538</i>&nbsp;        switch (dbType) {</b>
<b class="nc"><i class="no-highlight">3539</i>&nbsp;            case JdbcOperations.SNOWFLAKE:</b>
<i class="no-highlight">3540</i>&nbsp;                provider = getAWSCredentialsProviderSnowflake(
<b class="nc"><i class="no-highlight">3541</i>&nbsp;                        eltDatabaseAccount.getSnowflakeCredentialsType());</b>
<i class="no-highlight">3542</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">3543</i>&nbsp;            case JdbcOperations.REDSHIFT:</b>
<i class="no-highlight">3544</i>&nbsp;                provider = getAWSCredentialsProviderRedshift(
<b class="nc"><i class="no-highlight">3545</i>&nbsp;                        eltDatabaseAccount.getRedshiftAuthType());</b>
<i class="no-highlight">3546</i>&nbsp;                break;
<i class="no-highlight">3547</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:
<i class="no-highlight">3548</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:
<b class="nc"><i class="no-highlight">3549</i>&nbsp;            case JdbcOperations.BIGQUERY:</b>
<b class="nc"><i class="no-highlight">3550</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">3551</i>&nbsp;            default:</b>
<i class="no-highlight">3552</i>&nbsp;                throwInvalidDbTypeException();
<i class="no-highlight">3553</i>&nbsp;        }
<i class="no-highlight">3554</i>&nbsp;        return provider;
<i class="no-highlight">3555</i>&nbsp;    }
<i class="no-highlight">3556</i>&nbsp;
<i class="no-highlight">3557</i>&nbsp;    private AWSCredentialsProvider getAWSCredentialsProviderRedshift(String redshiftAuthType) {
<b class="nc"><i class="no-highlight">3558</i>&nbsp;        AWSCredentialsProvider awsCredentialsProvider = null;</b>
<b class="nc"><i class="no-highlight">3559</i>&nbsp;</b>
<i class="no-highlight">3560</i>&nbsp;        switch (redshiftAuthType) {
<b class="nc"><i class="no-highlight">3561</i>&nbsp;            case SOURCE_LOCATION_SESSION_CREDENTIALS: {</b>
<i class="no-highlight">3562</i>&nbsp;                BasicSessionCredentials credentials = new BasicSessionCredentials(
<b class="nc"><i class="no-highlight">3563</i>&nbsp;                        eltDatabaseAccount.getS3SessionAccessKey(),</b>
<b class="nc"><i class="no-highlight">3564</i>&nbsp;                        eltDatabaseAccount.getS3SessionSecretKey(),</b>
<i class="no-highlight">3565</i>&nbsp;                        eltDatabaseAccount.getAWSToken());
<b class="nc"><i class="no-highlight">3566</i>&nbsp;                awsCredentialsProvider =</b>
<i class="no-highlight">3567</i>&nbsp;                        new AWSStaticCredentialsProvider(credentials);
<b class="nc"><i class="no-highlight">3568</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">3569</i>&nbsp;            }</b>
<i class="no-highlight">3570</i>&nbsp;            case SOURCE_LOCATION_CREDENTIALS: {
<b class="nc"><i class="no-highlight">3571</i>&nbsp;                BasicAWSCredentials credentials = new BasicAWSCredentials(awsAccessKey,</b>
<b class="nc"><i class="no-highlight">3572</i>&nbsp;                        awsSecretKey);</b>
<b class="nc"><i class="no-highlight">3573</i>&nbsp;                awsCredentialsProvider =</b>
<i class="no-highlight">3574</i>&nbsp;                        new AWSStaticCredentialsProvider(credentials);
<i class="no-highlight">3575</i>&nbsp;                break;
<i class="no-highlight">3576</i>&nbsp;            }
<i class="no-highlight">3577</i>&nbsp;            case IAM_ROLE_CREDENTIALS: {
<b class="nc"><i class="no-highlight">3578</i>&nbsp;                // TODO: For Getting the Files over IAM role authentication, refer to DATA-2685</b>
<b class="nc"><i class="no-highlight">3579</i>&nbsp;                throw new ConfigurationException(ERR_FILE_PATTERN_REDSHIFT)</b>
<i class="no-highlight">3580</i>&nbsp;                        .withReason(REASON_FILE_PATTERN_REDSHIFT)
<b class="nc"><i class="no-highlight">3581</i>&nbsp;                        .withResolution(RESOLUTION_FILE_PATTERN_REDSHIFT);</b>
<i class="no-highlight">3582</i>&nbsp;            }
<b class="nc"><i class="no-highlight">3583</i>&nbsp;        }</b>
<i class="no-highlight">3584</i>&nbsp;
<b class="nc"><i class="no-highlight">3585</i>&nbsp;        return awsCredentialsProvider;</b>
<b class="nc"><i class="no-highlight">3586</i>&nbsp;    }</b>
<i class="no-highlight">3587</i>&nbsp;
<b class="nc"><i class="no-highlight">3588</i>&nbsp;    private void getFilesForFilePatternSnowflake() {</b>
<i class="no-highlight">3589</i>&nbsp;        files.clear();
<b class="nc"><i class="no-highlight">3590</i>&nbsp;        String snowflakeAuthType = eltDatabaseAccount.getSnowflakeCredentialsType();</b>
<b class="nc"><i class="no-highlight">3591</i>&nbsp;        listFilesRedshift(getAWSCredentialsProviderSnowflake(snowflakeAuthType));</b>
<b class="nc"><i class="no-highlight">3592</i>&nbsp;    }</b>
<i class="no-highlight">3593</i>&nbsp;
<i class="no-highlight">3594</i>&nbsp;    private AWSCredentialsProvider getAWSCredentialsProviderSnowflake(String snowflakeAuthType) {
<i class="no-highlight">3595</i>&nbsp;        AWSCredentialsProvider awsCredentialsProvider = null;
<b class="nc"><i class="no-highlight">3596</i>&nbsp;</b>
<i class="no-highlight">3597</i>&nbsp;        switch (snowflakeAuthType) {
<b class="nc"><i class="no-highlight">3598</i>&nbsp;            case SOURCE_LOCATION_SESSION_CREDENTIALS: {</b>
<b class="nc"><i class="no-highlight">3599</i>&nbsp;                BasicSessionCredentials credentials = new BasicSessionCredentials(</b>
<b class="nc"><i class="no-highlight">3600</i>&nbsp;                        eltDatabaseAccount.getS3SessionAccessKey(),</b>
<i class="no-highlight">3601</i>&nbsp;                        eltDatabaseAccount.getS3SessionSecretKey(),
<i class="no-highlight">3602</i>&nbsp;                        eltDatabaseAccount.getAWSToken());
<i class="no-highlight">3603</i>&nbsp;                awsCredentialsProvider =
<b class="nc"><i class="no-highlight">3604</i>&nbsp;                        new AWSStaticCredentialsProvider(credentials);</b>
<i class="no-highlight">3605</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">3606</i>&nbsp;            }</b>
<i class="no-highlight">3607</i>&nbsp;            case SOURCE_LOCATION_CREDENTIALS: {
<b class="nc"><i class="no-highlight">3608</i>&nbsp;                BasicAWSCredentials credentials = new BasicAWSCredentials(awsAccessKey,</b>
<i class="no-highlight">3609</i>&nbsp;                        awsSecretKey);
<b class="nc"><i class="no-highlight">3610</i>&nbsp;                awsCredentialsProvider =</b>
<i class="no-highlight">3611</i>&nbsp;                        new AWSStaticCredentialsProvider(credentials);
<b class="nc"><i class="no-highlight">3612</i>&nbsp;                break;</b>
<i class="no-highlight">3613</i>&nbsp;            }
<b class="nc"><i class="no-highlight">3614</i>&nbsp;            case STORAGE_INTEGRATION: {</b>
<i class="no-highlight">3615</i>&nbsp;                // @TODO if supported
<i class="no-highlight">3616</i>&nbsp;                break;
<i class="no-highlight">3617</i>&nbsp;            }
<i class="no-highlight">3618</i>&nbsp;        }
<b class="nc"><i class="no-highlight">3619</i>&nbsp;</b>
<i class="no-highlight">3620</i>&nbsp;        return awsCredentialsProvider;
<i class="no-highlight">3621</i>&nbsp;    }
<i class="no-highlight">3622</i>&nbsp;
<b class="nc"><i class="no-highlight">3623</i>&nbsp;    private void listFilesRedshift(AWSCredentialsProvider awsCredentialsProvider) {</b>
<b class="nc"><i class="no-highlight">3624</i>&nbsp;        s3Client = getS3Client(getS3ClientBuilder(awsCredentialsProvider));</b>
<b class="nc"><i class="no-highlight">3625</i>&nbsp;</b>
<i class="no-highlight">3626</i>&nbsp;        // Populate this.files with the list of location info.
<b class="nc"><i class="no-highlight">3627</i>&nbsp;        listFilesBasedOnPatternMatchingRedshift();</b>
<i class="no-highlight">3628</i>&nbsp;        throwExceptionIfFileListEmpty();
<b class="nc"><i class="no-highlight">3629</i>&nbsp;    }</b>
<i class="no-highlight">3630</i>&nbsp;
<b class="nc"><i class="no-highlight">3631</i>&nbsp;    @VisibleForTesting</b>
<i class="no-highlight">3632</i>&nbsp;    protected void listFilesBasedOnPatternMatchingRedshift() {
<b class="nc"><i class="no-highlight">3633</i>&nbsp;        Pattern p = Pattern.compile(filePattern);</b>
<b class="nc"><i class="no-highlight">3634</i>&nbsp;        ListObjectsV2Request listObjectsV2Request = getListObjectsV2Request();</b>
<b class="nc"><i class="no-highlight">3635</i>&nbsp;        ListObjectsV2Result result;</b>
<b class="nc"><i class="no-highlight">3636</i>&nbsp;        do {</b>
<i class="no-highlight">3637</i>&nbsp;            result = getListObjectsV2Result(s3Client, listObjectsV2Request);
<b class="nc"><i class="no-highlight">3638</i>&nbsp;            for (final S3ObjectSummary s3ObjectSummary : result.getObjectSummaries()) {</b>
<i class="no-highlight">3639</i>&nbsp;                String relativePath = s3ObjectSummary.getKey();
<i class="no-highlight">3640</i>&nbsp;                // Pattern needs to match with full path of file name to keep
<b class="nc"><i class="no-highlight">3641</i>&nbsp;                // the behavior consistent with Snowflake</b>
<i class="no-highlight">3642</i>&nbsp;                String absolutePath;
<b class="nc"><i class="no-highlight">3643</i>&nbsp;                if (StringUtils.isNotBlank(s3Folder)) {</b>
<i class="no-highlight">3644</i>&nbsp;                    absolutePath = String.format(S3_FILE_FULL_PATH, s3Bucket, relativePath);
<b class="nc"><i class="no-highlight">3645</i>&nbsp;                } else {</b>
<i class="no-highlight">3646</i>&nbsp;                    absolutePath = String.format(FULL_PATH_FILE_FORMAT_REDSHIFT, filePathStage,
<b class="nc"><i class="no-highlight">3647</i>&nbsp;                            relativePath);</b>
<b class="nc"><i class="no-highlight">3648</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">3649</i>&nbsp;                Matcher matcher = p.matcher(absolutePath);</b>
<b class="nc"><i class="no-highlight">3650</i>&nbsp;                if (matcher.find()) {</b>
<b class="nc"><i class="no-highlight">3651</i>&nbsp;                    String subPath = absolutePath.substring(filePathStage.length());</b>
<b class="nc"><i class="no-highlight">3652</i>&nbsp;                    files.add(subPath);</b>
<b class="nc"><i class="no-highlight">3653</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">3654</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">3655</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3656</i>&nbsp;            listObjectsV2Request.setContinuationToken(result.getNextContinuationToken());</b>
<i class="no-highlight">3657</i>&nbsp;        } while (result.isTruncated());
<b class="nc"><i class="no-highlight">3658</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">3659</i>&nbsp;</b>
<i class="no-highlight">3660</i>&nbsp;    private AmazonS3ClientBuilder getS3ClientBuilder(
<b class="nc"><i class="no-highlight">3661</i>&nbsp;            AWSCredentialsProvider awsCredentialsProvider) {</b>
<b class="nc"><i class="no-highlight">3662</i>&nbsp;        AmazonS3ClientBuilder s3 = AmazonS3Client.builder()</b>
<b class="nc"><i class="no-highlight">3663</i>&nbsp;                .withCredentials(awsCredentialsProvider);</b>
<b class="nc"><i class="no-highlight">3664</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3665</i>&nbsp;        if (StringUtils.isBlank(s3BucketRegion)) {</b>
<b class="nc"><i class="no-highlight">3666</i>&nbsp;            s3.setRegion(findS3BucketRegion(s3));</b>
<i class="no-highlight">3667</i>&nbsp;
<b class="nc"><i class="no-highlight">3668</i>&nbsp;        } else if (StringUtils.equalsIgnoreCase(</b>
<b class="nc"><i class="no-highlight">3669</i>&nbsp;                s3BucketRegion, S3Region.DEFAULT.toString())) {</b>
<i class="no-highlight">3670</i>&nbsp;            s3.setRegion(Regions.DEFAULT_REGION.getName());
<b class="nc"><i class="no-highlight">3671</i>&nbsp;        } else {</b>
<b class="nc"><i class="no-highlight">3672</i>&nbsp;            s3.setRegion(s3BucketRegion);</b>
<b class="nc"><i class="no-highlight">3673</i>&nbsp;        }</b>
<i class="no-highlight">3674</i>&nbsp;        s3.setForceGlobalBucketAccessEnabled(true);
<b class="nc"><i class="no-highlight">3675</i>&nbsp;</b>
<i class="no-highlight">3676</i>&nbsp;        return s3;
<b class="nc"><i class="no-highlight">3677</i>&nbsp;    }</b>
<i class="no-highlight">3678</i>&nbsp;
<b class="nc"><i class="no-highlight">3679</i>&nbsp;    private String findS3BucketRegion(AmazonS3ClientBuilder s3) {</b>
<b class="nc"><i class="no-highlight">3680</i>&nbsp;        s3.setRegion(Regions.DEFAULT_REGION.getName());</b>
<b class="nc"><i class="no-highlight">3681</i>&nbsp;        AmazonS3 s3Client = s3.build();</b>
<b class="nc"><i class="no-highlight">3682</i>&nbsp;        return s3Client.getBucketLocation(s3Bucket);</b>
<b class="nc"><i class="no-highlight">3683</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">3684</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3685</i>&nbsp;    /**</b>
<b class="nc"><i class="no-highlight">3686</i>&nbsp;     * Preprocess for Schema detector building.</b>
<b class="nc"><i class="no-highlight">3687</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">3688</i>&nbsp;    private void preprocessForDetectorBuild() {</b>
<b class="nc"><i class="no-highlight">3689</i>&nbsp;        String dbType = getName();</b>
<b class="nc"><i class="no-highlight">3690</i>&nbsp;        String sourceLocation = eltDatabaseAccount.getSourceLocation();</b>
<b class="nc"><i class="no-highlight">3691</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3692</i>&nbsp;        switch (dbType) {</b>
<b class="nc"><i class="no-highlight">3693</i>&nbsp;            case JdbcOperations.SNOWFLAKE:</b>
<b class="nc"><i class="no-highlight">3694</i>&nbsp;                boolean isExternalStageCreationRequired = false;</b>
<i class="no-highlight">3695</i>&nbsp;                switch (sourceLocation) {
<b class="nc"><i class="no-highlight">3696</i>&nbsp;                    case AMAZON_S3:</b>
<b class="nc"><i class="no-highlight">3697</i>&nbsp;                        if (StringUtils.equalsIgnoreCase(</b>
<b class="nc"><i class="no-highlight">3698</i>&nbsp;                                STORAGE_INTEGRATION,</b>
<b class="nc"><i class="no-highlight">3699</i>&nbsp;                                eltDatabaseAccount.getSnowflakeCredentialsType())) {</b>
<b class="nc"><i class="no-highlight">3700</i>&nbsp;                            isExternalStageCreationRequired = true;</b>
<b class="nc"><i class="no-highlight">3701</i>&nbsp;                        } else {</b>
<b class="nc"><i class="no-highlight">3702</i>&nbsp;                            if (s3Client == null) {</b>
<i class="no-highlight">3703</i>&nbsp;                                s3Client = getS3Client(getS3ClientBuilder(
<b class="nc"><i class="no-highlight">3704</i>&nbsp;                                        getAWSCredentialsProvider()));</b>
<b class="nc"><i class="no-highlight">3705</i>&nbsp;                            }</b>
<b class="nc"><i class="no-highlight">3706</i>&nbsp;                        }</b>
<b class="nc"><i class="no-highlight">3707</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">3708</i>&nbsp;                    case AZURE:</b>
<b class="nc"><i class="no-highlight">3709</i>&nbsp;                        if (StringUtils.isNotEmpty(storageIntegration)) {</b>
<b class="nc"><i class="no-highlight">3710</i>&nbsp;                            isExternalStageCreationRequired = true;</b>
<i class="no-highlight">3711</i>&nbsp;                        } else {
<b class="nc"><i class="no-highlight">3712</i>&nbsp;                            prepareAzureStorageForSchemaInferenceSnowflake();</b>
<b class="nc"><i class="no-highlight">3713</i>&nbsp;                        }</b>
<b class="nc"><i class="no-highlight">3714</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">3715</i>&nbsp;                    case GOOGLE_CLOUD_STORAGE:</b>
<b class="nc"><i class="no-highlight">3716</i>&nbsp;                        isExternalStageCreationRequired = true;</b>
<b class="nc"><i class="no-highlight">3717</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">3718</i>&nbsp;                    default:</b>
<i class="no-highlight">3719</i>&nbsp;                        throwExceptionIfInvalidSourceLocationForDetector(sourceLocation, dbType);
<b class="nc"><i class="no-highlight">3720</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">3721</i>&nbsp;                if (isExternalStageCreationRequired) {</b>
<b class="nc"><i class="no-highlight">3722</i>&nbsp;                    executeCreateExternalStageSnowflake(true);</b>
<b class="nc"><i class="no-highlight">3723</i>&nbsp;                    isCreatedExternalStageForSchemaInference = true;</b>
<b class="nc"><i class="no-highlight">3724</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">3725</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">3726</i>&nbsp;            case JdbcOperations.REDSHIFT:</b>
<i class="no-highlight">3727</i>&nbsp;                switch (sourceLocation) {
<b class="nc"><i class="no-highlight">3728</i>&nbsp;                    case AMAZON_S3:</b>
<i class="no-highlight">3729</i>&nbsp;                        if (s3Client == null) {
<b class="nc"><i class="no-highlight">3730</i>&nbsp;                            s3Client = getS3Client(getS3ClientBuilder(</b>
<i class="no-highlight">3731</i>&nbsp;                                    getAWSCredentialsProvider()));
<b class="nc"><i class="no-highlight">3732</i>&nbsp;                        }</b>
<i class="no-highlight">3733</i>&nbsp;                        break;
<b class="nc"><i class="no-highlight">3734</i>&nbsp;                    default:</b>
<b class="nc"><i class="no-highlight">3735</i>&nbsp;                        throwExceptionIfInvalidSourceLocationForDetector(sourceLocation, dbType);</b>
<i class="no-highlight">3736</i>&nbsp;                }
<b class="nc"><i class="no-highlight">3737</i>&nbsp;                break;</b>
<i class="no-highlight">3738</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:
<i class="no-highlight">3739</i>&nbsp;                break;
<i class="no-highlight">3740</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:
<b class="nc"><i class="no-highlight">3741</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">3742</i>&nbsp;            case JdbcOperations.BIGQUERY:</b>
<i class="no-highlight">3743</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">3744</i>&nbsp;            default:</b>
<b class="nc"><i class="no-highlight">3745</i>&nbsp;                throwInvalidDbTypeException();</b>
<b class="nc"><i class="no-highlight">3746</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">3747</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">3748</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3749</i>&nbsp;    private boolean isFileFormatTypeApacheFileFormat() {</b>
<b class="nc"><i class="no-highlight">3750</i>&nbsp;        return APACHE_FILE_FORMATS.contains(fileFormatType);</b>
<b class="nc"><i class="no-highlight">3751</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">3752</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3753</i>&nbsp;    private FileSchemaDetector buildDetector(String file)  {</b>
<b class="nc"><i class="no-highlight">3754</i>&nbsp;        String dbType = getName();</b>
<b class="nc"><i class="no-highlight">3755</i>&nbsp;        FileSchemaDetector schemaDetector = null;</b>
<b class="nc"><i class="no-highlight">3756</i>&nbsp;        String sourceLocation = eltDatabaseAccount.getSourceLocation();</b>
<b class="nc"><i class="no-highlight">3757</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3758</i>&nbsp;        switch (dbType) {</b>
<b class="nc"><i class="no-highlight">3759</i>&nbsp;            case JdbcOperations.SNOWFLAKE:</b>
<b class="nc"><i class="no-highlight">3760</i>&nbsp;                DefaultSnowflakeFileSchemaDetector.Builder builder =</b>
<b class="nc"><i class="no-highlight">3761</i>&nbsp;                        new DefaultSnowflakeFileSchemaDetector.Builder();</b>
<b class="nc"><i class="no-highlight">3762</i>&nbsp;                switch (sourceLocation) {</b>
<i class="no-highlight">3763</i>&nbsp;                    case AMAZON_S3:
<b class="nc"><i class="no-highlight">3764</i>&nbsp;                        String filePath = EMPTY_STRING;</b>
<b class="nc"><i class="no-highlight">3765</i>&nbsp;                        String fileKey = EMPTY_STRING;</b>
<b class="nc"><i class="no-highlight">3766</i>&nbsp;                        String folder = s3Folder.endsWith(SLASH) ? s3Folder : s3Folder + SLASH;</b>
<b class="nc"><i class="no-highlight">3767</i>&nbsp;                        String bucket = s3Bucket.endsWith(SLASH) ? s3Bucket : s3Bucket + SLASH;</b>
<b class="nc"><i class="no-highlight">3768</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3769</i>&nbsp;                        filePath = String.format(FULL_PATH_FILE_FORMAT_REDSHIFT, filePathStage,</b>
<b class="nc"><i class="no-highlight">3770</i>&nbsp;                                file);</b>
<b class="nc"><i class="no-highlight">3771</i>&nbsp;                        // fileKey should have a file path prefix that starts from folder.</b>
<b class="nc"><i class="no-highlight">3772</i>&nbsp;                        String prefixOfFilePathStage = S3_COLON_SLASHES + bucket;</b>
<b class="nc"><i class="no-highlight">3773</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3774</i>&nbsp;                        fileKey = String.format(</b>
<b class="nc"><i class="no-highlight">3775</i>&nbsp;                                FILE_KEY_FORMAT_REDSHIFT,</b>
<b class="nc"><i class="no-highlight">3776</i>&nbsp;                                filePathStage.substring(prefixOfFilePathStage.length()), file);</b>
<b class="nc"><i class="no-highlight">3777</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3778</i>&nbsp;                        builder.withLOGGER(LOGGER)</b>
<b class="nc"><i class="no-highlight">3779</i>&nbsp;                            .withStorageIntegrationUsed(isCreatedExternalStageForSchemaInference)</b>
<i class="no-highlight">3780</i>&nbsp;                            .withCloudStorageType(CLOUD_STORAGE_AWS_S3)
<b class="nc"><i class="no-highlight">3781</i>&nbsp;                            .withS3Client(s3Client)</b>
<b class="nc"><i class="no-highlight">3782</i>&nbsp;                            .withInFilePath(filePath)</b>
<b class="nc"><i class="no-highlight">3783</i>&nbsp;                            .withS3Bucket(s3Bucket)</b>
<b class="nc"><i class="no-highlight">3784</i>&nbsp;                            .withInFileKey(fileKey)</b>
<b class="nc"><i class="no-highlight">3785</i>&nbsp;                            .withAwsAccessKey(awsAccessKey)</b>
<b class="nc"><i class="no-highlight">3786</i>&nbsp;                            .withAwsSecretKey(awsSecretKey);</b>
<b class="nc"><i class="no-highlight">3787</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">3788</i>&nbsp;                    case AZURE:</b>
<b class="nc"><i class="no-highlight">3789</i>&nbsp;                        builder.withLOGGER(LOGGER)</b>
<b class="nc"><i class="no-highlight">3790</i>&nbsp;                                .withStorageIntegrationUsed(</b>
<b class="nc"><i class="no-highlight">3791</i>&nbsp;                                        isCreatedExternalStageForSchemaInference)</b>
<b class="nc"><i class="no-highlight">3792</i>&nbsp;                                .withCloudStorageType(AZURE_SYNAPSE_ADLSGEN2_STORAGE)</b>
<b class="nc"><i class="no-highlight">3793</i>&nbsp;                                .withAzureDataLakeClient(azureDataLakeClient)</b>
<b class="nc"><i class="no-highlight">3794</i>&nbsp;                                .withDataLakeFileSystemClient(dataLakeFileSystemClient)</b>
<b class="nc"><i class="no-highlight">3795</i>&nbsp;                                .withAzureFolder(azureFolder)</b>
<i class="no-highlight">3796</i>&nbsp;                                .withInFilePath(file);
<b class="nc"><i class="no-highlight">3797</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">3798</i>&nbsp;                    case GOOGLE_CLOUD_STORAGE:</b>
<b class="nc"><i class="no-highlight">3799</i>&nbsp;                        builder.withLOGGER(LOGGER)</b>
<b class="nc"><i class="no-highlight">3800</i>&nbsp;                                .withStorageIntegrationUsed(</b>
<b class="nc"><i class="no-highlight">3801</i>&nbsp;                                        isCreatedExternalStageForSchemaInference)</b>
<b class="nc"><i class="no-highlight">3802</i>&nbsp;                                .withCloudStorageType(GOOGLE_CLOUD_STORAGE)</b>
<b class="nc"><i class="no-highlight">3803</i>&nbsp;                                .withInFilePath(file);</b>
<b class="nc"><i class="no-highlight">3804</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">3805</i>&nbsp;                    default:</b>
<b class="nc"><i class="no-highlight">3806</i>&nbsp;                        throwExceptionIfInvalidSourceLocationForDetector(sourceLocation, dbType);</b>
<b class="nc"><i class="no-highlight">3807</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">3808</i>&nbsp;                switch(fileFormatType) {</b>
<b class="nc"><i class="no-highlight">3809</i>&nbsp;                    case CSV:</b>
<b class="nc"><i class="no-highlight">3810</i>&nbsp;                        schemaDetector = builder</b>
<b class="nc"><i class="no-highlight">3811</i>&nbsp;                                .withFileFormatType(CSV)</b>
<i class="no-highlight">3812</i>&nbsp;                                .withCompression(compressionType)
<b class="nc"><i class="no-highlight">3813</i>&nbsp;                                .withFieldDelimiter(fieldDelimiter)</b>
<b class="nc"><i class="no-highlight">3814</i>&nbsp;                                .withSkipHeader(skipHeader)</b>
<b class="nc"><i class="no-highlight">3815</i>&nbsp;                                .withDateFormat(dateFormat)</b>
<b class="nc"><i class="no-highlight">3816</i>&nbsp;                                .withTimeFormat(timeFormat)</b>
<b class="nc"><i class="no-highlight">3817</i>&nbsp;                                .withTimestampFormat(timestampFormat)</b>
<b class="nc"><i class="no-highlight">3818</i>&nbsp;                                .withBinaryFormat(binaryFormat)</b>
<b class="nc"><i class="no-highlight">3819</i>&nbsp;                                .withEscapeCharacter(escapeChar)</b>
<b class="nc"><i class="no-highlight">3820</i>&nbsp;                                .withQuoteCharacter(fieldOptionallyEnclosedBy)</b>
<b class="nc"><i class="no-highlight">3821</i>&nbsp;                                .withNullIf(nullIf)</b>
<b class="nc"><i class="no-highlight">3822</i>&nbsp;                                .withEncoding(encoding)</b>
<b class="nc"><i class="no-highlight">3823</i>&nbsp;                                .withCheckUnknownType(checkUnknownType)</b>
<b class="nc"><i class="no-highlight">3824</i>&nbsp;                                .build();</b>
<b class="nc"><i class="no-highlight">3825</i>&nbsp;                        break;</b>
<i class="no-highlight">3826</i>&nbsp;                    case JSON:
<b class="nc"><i class="no-highlight">3827</i>&nbsp;                        schemaDetector = builder</b>
<i class="no-highlight">3828</i>&nbsp;                                .withFileFormatType(JSON)
<b class="nc"><i class="no-highlight">3829</i>&nbsp;                                .withCompression(compressionType)</b>
<i class="no-highlight">3830</i>&nbsp;                                .withNullIf(nullIf)
<b class="nc"><i class="no-highlight">3831</i>&nbsp;                                .withCheckUnknownType(checkUnknownType)</b>
<i class="no-highlight">3832</i>&nbsp;                                .build();
<b class="nc"><i class="no-highlight">3833</i>&nbsp;                        break;</b>
<i class="no-highlight">3834</i>&nbsp;                    case AVRO:
<b class="nc"><i class="no-highlight">3835</i>&nbsp;                        schemaDetector = builder</b>
<i class="no-highlight">3836</i>&nbsp;                                .withFileFormatType(AVRO)
<i class="no-highlight">3837</i>&nbsp;                                .withCompression(compressionType)
<b class="nc"><i class="no-highlight">3838</i>&nbsp;                                .withNullIf(nullIf)</b>
<i class="no-highlight">3839</i>&nbsp;                                .withCheckUnknownType(checkUnknownType)
<i class="no-highlight">3840</i>&nbsp;                                .build();
<i class="no-highlight">3841</i>&nbsp;                        break;
<i class="no-highlight">3842</i>&nbsp;                    case ORC:
<i class="no-highlight">3843</i>&nbsp;                        schemaDetector = builder
<i class="no-highlight">3844</i>&nbsp;                                .withFileFormatType(ORC)
<i class="no-highlight">3845</i>&nbsp;                                .withCompression(compressionType)
<i class="no-highlight">3846</i>&nbsp;                                .withNullIf(nullIf)
<i class="no-highlight">3847</i>&nbsp;                                .withCheckUnknownType(checkUnknownType)
<i class="no-highlight">3848</i>&nbsp;                                .build();
<i class="no-highlight">3849</i>&nbsp;                        break;
<b class="nc"><i class="no-highlight">3850</i>&nbsp;                    case PARQUET:</b>
<i class="no-highlight">3851</i>&nbsp;                        schemaDetector = builder
<b class="nc"><i class="no-highlight">3852</i>&nbsp;                                .withFileFormatType(PARQUET)</b>
<i class="no-highlight">3853</i>&nbsp;                                .withCompression(compressionType)
<b class="nc"><i class="no-highlight">3854</i>&nbsp;                                .withNullIf(nullIf)</b>
<b class="nc"><i class="no-highlight">3855</i>&nbsp;                                .withCheckUnknownType(checkUnknownType)</b>
<i class="no-highlight">3856</i>&nbsp;                                .build();
<b class="nc"><i class="no-highlight">3857</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">3858</i>&nbsp;                    default:</b>
<i class="no-highlight">3859</i>&nbsp;                        throwExceptionIfNotSupportedFileTypeForSchemaInference(fileFormatType);
<i class="no-highlight">3860</i>&nbsp;                }
<i class="no-highlight">3861</i>&nbsp;                break;
<i class="no-highlight">3862</i>&nbsp;            case JdbcOperations.REDSHIFT:
<b class="nc"><i class="no-highlight">3863</i>&nbsp;                switch (sourceLocation) {</b>
<b class="nc"><i class="no-highlight">3864</i>&nbsp;                    case AMAZON_S3:</b>
<i class="no-highlight">3865</i>&nbsp;                        String folder = s3Folder.endsWith(SLASH) ? s3Folder : s3Folder + SLASH;
<b class="nc"><i class="no-highlight">3866</i>&nbsp;                        String filePath = String.format(</b>
<b class="nc"><i class="no-highlight">3867</i>&nbsp;                                FULL_PATH_FILE_FORMAT_REDSHIFT, filePathStage, file);</b>
<i class="no-highlight">3868</i>&nbsp;                        String fileKey = String.format(FILE_KEY_FORMAT_REDSHIFT, folder, file);
<i class="no-highlight">3869</i>&nbsp;
<i class="no-highlight">3870</i>&nbsp;                        // Create FileSchemaDetector per &quot;fileFormatType&quot;.
<b class="nc"><i class="no-highlight">3871</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3872</i>&nbsp;                        if (StringUtils.equalsIgnoreCase(CSV, fileFormatType)) {</b>
<b class="nc"><i class="no-highlight">3873</i>&nbsp;                            schemaDetector = new DefaultRedshiftFileSchemaDetector</b>
<b class="nc"><i class="no-highlight">3874</i>&nbsp;                                    .Builder()</b>
<b class="nc"><i class="no-highlight">3875</i>&nbsp;                                    .withFileFormatType(CSV)</b>
<i class="no-highlight">3876</i>&nbsp;                                    .withLOGGER(LOGGER)
<i class="no-highlight">3877</i>&nbsp;                                    .withCloudStorageType(CLOUD_STORAGE_AWS_S3)
<i class="no-highlight">3878</i>&nbsp;                                    .withS3Client(s3Client)
<b class="nc"><i class="no-highlight">3879</i>&nbsp;                                    .withInFilePath(filePath)</b>
<b class="nc"><i class="no-highlight">3880</i>&nbsp;                                    .withS3Bucket(s3Bucket)</b>
<b class="nc"><i class="no-highlight">3881</i>&nbsp;                                    .withInFileKey(fileKey)</b>
<i class="no-highlight">3882</i>&nbsp;                                    .withFieldDelimiter(fieldDelimiter)
<i class="no-highlight">3883</i>&nbsp;                                    .withIgnoreHeader(ignoreHeader)
<b class="nc"><i class="no-highlight">3884</i>&nbsp;                                    .withDateFormat(dateFormat)</b>
<i class="no-highlight">3885</i>&nbsp;                                    .withTimeFormat(timeFormat)
<b class="nc"><i class="no-highlight">3886</i>&nbsp;                                    .withQuoteCharacter(quoteChar)</b>
<b class="nc"><i class="no-highlight">3887</i>&nbsp;                                    .withNullAsStr(nullAsStr)</b>
<b class="nc"><i class="no-highlight">3888</i>&nbsp;                                    .withCompression(compressionType)</b>
<i class="no-highlight">3889</i>&nbsp;                                    .withEncoding(encoding)
<i class="no-highlight">3890</i>&nbsp;                                    .withCheckUnknownType(checkUnknownType)
<i class="no-highlight">3891</i>&nbsp;                                    .build();
<b class="nc"><i class="no-highlight">3892</i>&nbsp;                        } else if (isFileFormatJSON()) {</b>
<b class="nc"><i class="no-highlight">3893</i>&nbsp;                            schemaDetector = new DefaultRedshiftFileSchemaDetector</b>
<b class="nc"><i class="no-highlight">3894</i>&nbsp;                                    .Builder()</b>
<b class="nc"><i class="no-highlight">3895</i>&nbsp;                                    .withFileFormatType(JSON)</b>
<b class="nc"><i class="no-highlight">3896</i>&nbsp;                                    .withLOGGER(LOGGER)</b>
<i class="no-highlight">3897</i>&nbsp;                                    .withCloudStorageType(CLOUD_STORAGE_AWS_S3)
<b class="nc"><i class="no-highlight">3898</i>&nbsp;                                    .withS3Client(s3Client)</b>
<b class="nc"><i class="no-highlight">3899</i>&nbsp;                                    .withInFilePath(filePath)</b>
<i class="no-highlight">3900</i>&nbsp;                                    .withS3Bucket(s3Bucket)
<b class="nc"><i class="no-highlight">3901</i>&nbsp;                                    .withInFileKey(fileKey)</b>
<i class="no-highlight">3902</i>&nbsp;                                    .withFieldDelimiter(fieldDelimiter)
<b class="nc"><i class="no-highlight">3903</i>&nbsp;                                    .withDateFormat(dateFormat)</b>
<b class="nc"><i class="no-highlight">3904</i>&nbsp;                                    .withTimeFormat(timeFormat)</b>
<b class="nc"><i class="no-highlight">3905</i>&nbsp;                                    .withCompression(compressionType)</b>
<i class="no-highlight">3906</i>&nbsp;                                    .withEncoding(encoding)
<i class="no-highlight">3907</i>&nbsp;                                    .withCheckUnknownType(checkUnknownType)
<i class="no-highlight">3908</i>&nbsp;                                    .build();
<b class="nc"><i class="no-highlight">3909</i>&nbsp;                        } else if (StringUtils.equalsIgnoreCase(PARQUET, fileFormatType)) {</b>
<b class="nc"><i class="no-highlight">3910</i>&nbsp;                            schemaDetector = new DefaultRedshiftFileSchemaDetector</b>
<i class="no-highlight">3911</i>&nbsp;                                    .Builder()
<i class="no-highlight">3912</i>&nbsp;                                    .withFileFormatType(PARQUET)
<i class="no-highlight">3913</i>&nbsp;                                    .withLOGGER(LOGGER)
<b class="nc"><i class="no-highlight">3914</i>&nbsp;                                    .withCloudStorageType(CLOUD_STORAGE_AWS_S3)</b>
<b class="nc"><i class="no-highlight">3915</i>&nbsp;                                    .withInFilePath(filePath)</b>
<i class="no-highlight">3916</i>&nbsp;                                    .withS3Bucket(s3Bucket)
<i class="no-highlight">3917</i>&nbsp;                                    .withAwsAccessKey(awsAccessKey)
<i class="no-highlight">3918</i>&nbsp;                                    .withAwsSecretKey(awsSecretKey)
<b class="nc"><i class="no-highlight">3919</i>&nbsp;                                    .withDateFormat(dateFormat)</b>
<b class="nc"><i class="no-highlight">3920</i>&nbsp;                                    .withTimeFormat(timeFormat)</b>
<b class="nc"><i class="no-highlight">3921</i>&nbsp;                                    .withCompression(compressionType)</b>
<i class="no-highlight">3922</i>&nbsp;                                    .withEncoding(encoding)
<i class="no-highlight">3923</i>&nbsp;                                    .withCheckUnknownType(checkUnknownType)
<i class="no-highlight">3924</i>&nbsp;                                    .build();
<i class="no-highlight">3925</i>&nbsp;                        } else if (StringUtils.equalsIgnoreCase(ORC, fileFormatType)) {
<b class="nc"><i class="no-highlight">3926</i>&nbsp;                            schemaDetector = new DefaultRedshiftFileSchemaDetector</b>
<b class="nc"><i class="no-highlight">3927</i>&nbsp;                                    .Builder()</b>
<b class="nc"><i class="no-highlight">3928</i>&nbsp;                                    .withFileFormatType(ORC)</b>
<b class="nc"><i class="no-highlight">3929</i>&nbsp;                                    .withLOGGER(LOGGER)</b>
<i class="no-highlight">3930</i>&nbsp;                                    .withCloudStorageType(CLOUD_STORAGE_AWS_S3)
<i class="no-highlight">3931</i>&nbsp;                                    .withInFilePath(filePath)
<i class="no-highlight">3932</i>&nbsp;                                    .withS3Bucket(s3Bucket)
<i class="no-highlight">3933</i>&nbsp;                                    .withAwsAccessKey(awsAccessKey)
<b class="nc"><i class="no-highlight">3934</i>&nbsp;                                    .withAwsSecretKey(awsSecretKey)</b>
<b class="nc"><i class="no-highlight">3935</i>&nbsp;                                    .withDateFormat(dateFormat)</b>
<b class="nc"><i class="no-highlight">3936</i>&nbsp;                                    .withTimeFormat(timeFormat)</b>
<b class="nc"><i class="no-highlight">3937</i>&nbsp;                                    .withCompression(compressionType)</b>
<i class="no-highlight">3938</i>&nbsp;                                    .withEncoding(encoding)
<i class="no-highlight">3939</i>&nbsp;                                    .withCheckUnknownType(checkUnknownType)
<i class="no-highlight">3940</i>&nbsp;                                    .build();
<i class="no-highlight">3941</i>&nbsp;                        } else if (StringUtils.equalsIgnoreCase(AVRO, fileFormatType)) {
<i class="no-highlight">3942</i>&nbsp;                            schemaDetector = new DefaultRedshiftFileSchemaDetector
<b class="nc"><i class="no-highlight">3943</i>&nbsp;                                    .Builder()</b>
<b class="nc"><i class="no-highlight">3944</i>&nbsp;                                    .withFileFormatType(AVRO)</b>
<b class="nc"><i class="no-highlight">3945</i>&nbsp;                                    .withLOGGER(LOGGER)</b>
<b class="nc"><i class="no-highlight">3946</i>&nbsp;                                    .withCloudStorageType(CLOUD_STORAGE_AWS_S3)</b>
<i class="no-highlight">3947</i>&nbsp;                                    .withInFilePath(filePath)
<b class="nc"><i class="no-highlight">3948</i>&nbsp;                                    .withS3Bucket(s3Bucket)</b>
<i class="no-highlight">3949</i>&nbsp;                                    .withAwsAccessKey(awsAccessKey)
<b class="nc"><i class="no-highlight">3950</i>&nbsp;                                    .withAwsSecretKey(awsSecretKey)</b>
<b class="nc"><i class="no-highlight">3951</i>&nbsp;                                    .withDateFormat(dateFormat)</b>
<b class="nc"><i class="no-highlight">3952</i>&nbsp;                                    .withTimeFormat(timeFormat)</b>
<b class="nc"><i class="no-highlight">3953</i>&nbsp;                                    .withCompression(compressionType)</b>
<i class="no-highlight">3954</i>&nbsp;                                    .withEncoding(encoding)
<b class="nc"><i class="no-highlight">3955</i>&nbsp;                                    .withCheckUnknownType(checkUnknownType)</b>
<i class="no-highlight">3956</i>&nbsp;                                    .build();
<b class="nc"><i class="no-highlight">3957</i>&nbsp;                        } else {</b>
<i class="no-highlight">3958</i>&nbsp;                            throwExceptionIfNotSupportedFileTypeForSchemaInference(dbType);
<b class="nc"><i class="no-highlight">3959</i>&nbsp;                        }</b>
<b class="nc"><i class="no-highlight">3960</i>&nbsp;                        break;</b>
<b class="nc"><i class="no-highlight">3961</i>&nbsp;                    default:</b>
<i class="no-highlight">3962</i>&nbsp;                        throwExceptionIfInvalidSourceLocationForDetector(sourceLocation, dbType);
<b class="nc"><i class="no-highlight">3963</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">3964</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">3965</i>&nbsp;            default:</b>
<b class="nc"><i class="no-highlight">3966</i>&nbsp;                throwExceptionIfNotSupportedDbTypeForSchemaInference(dbType);</b>
<b class="nc"><i class="no-highlight">3967</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">3968</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3969</i>&nbsp;        return schemaDetector;</b>
<i class="no-highlight">3970</i>&nbsp;    }
<i class="no-highlight">3971</i>&nbsp;
<i class="no-highlight">3972</i>&nbsp;    /**
<i class="no-highlight">3973</i>&nbsp;     * Auto-detects source file column names and their data types
<b class="nc"><i class="no-highlight">3974</i>&nbsp;     *</b>
<i class="no-highlight">3975</i>&nbsp;     * @return source file column map on success.
<i class="no-highlight">3976</i>&nbsp;     *         null on failure or if not possible to find a complete
<i class="no-highlight">3977</i>&nbsp;     *          (in that every map key has a valid data type) map.
<i class="no-highlight">3978</i>&nbsp;     */
<i class="no-highlight">3979</i>&nbsp;    @VisibleForTesting
<i class="no-highlight">3980</i>&nbsp;    protected LinkedHashMap&lt;String, String&gt; autoDetectSourceFileSchema() {
<i class="no-highlight">3981</i>&nbsp;        validateFileFormatOptionsForSchemaInference();
<b class="nc"><i class="no-highlight">3982</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">3983</i>&nbsp;        preprocessForDetectorBuild();</b>
<i class="no-highlight">3984</i>&nbsp;
<b class="nc"><i class="no-highlight">3985</i>&nbsp;        SchemaDetectionResult result = null;</b>
<b class="nc"><i class="no-highlight">3986</i>&nbsp;        setUpFilesForSchemaInference();</b>
<i class="no-highlight">3987</i>&nbsp;        // If &quot;files&quot; has multiple files then try to merge results for each file.
<i class="no-highlight">3988</i>&nbsp;        boolean multipleFilesCase = filesForSchemaInference.size() &gt; 1;
<b class="nc"><i class="no-highlight">3989</i>&nbsp;        boolean performFinalProcessing = false;</b>
<i class="no-highlight">3990</i>&nbsp;
<i class="no-highlight">3991</i>&nbsp;        // If checkUnknownType is false and multipleFilesCase is true,
<i class="no-highlight">3992</i>&nbsp;        // set true to checkUnknownType and to performFinalProcessing,
<b class="nc"><i class="no-highlight">3993</i>&nbsp;        // so that we can try to merge results of multiple files.</b>
<b class="nc"><i class="no-highlight">3994</i>&nbsp;        if (!checkUnknownType) {</b>
<i class="no-highlight">3995</i>&nbsp;            performFinalProcessing = true;
<i class="no-highlight">3996</i>&nbsp;
<b class="nc"><i class="no-highlight">3997</i>&nbsp;            if (multipleFilesCase) {</b>
<i class="no-highlight">3998</i>&nbsp;                checkUnknownType = true;
<i class="no-highlight">3999</i>&nbsp;            }
<i class="no-highlight">4000</i>&nbsp;        }
<b class="nc"><i class="no-highlight">4001</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4002</i>&nbsp;        if (CollectionUtils.isNotEmpty(filesForSchemaInference)) {</b>
<i class="no-highlight">4003</i>&nbsp;            for (String file : filesForSchemaInference) {
<b class="nc"><i class="no-highlight">4004</i>&nbsp;                FileSchemaDetector schemaDetector = buildDetector(file);</b>
<i class="no-highlight">4005</i>&nbsp;                if (schemaDetector == null) {
<i class="no-highlight">4006</i>&nbsp;                    continue;
<i class="no-highlight">4007</i>&nbsp;                }
<b class="nc"><i class="no-highlight">4008</i>&nbsp;</b>
<i class="no-highlight">4009</i>&nbsp;                // Autodetect the schema of a source file.
<b class="nc"><i class="no-highlight">4010</i>&nbsp;                SchemaDetectionResult oneFileResults = null;</b>
<b class="nc"><i class="no-highlight">4011</i>&nbsp;                if (isCreatedExternalStageForSchemaInference) {</b>
<i class="no-highlight">4012</i>&nbsp;                    oneFileResults = detectSchemaStorageIntegrationSnowflake(
<b class="nc"><i class="no-highlight">4013</i>&nbsp;                            schemaDetector, file);</b>
<i class="no-highlight">4014</i>&nbsp;                } else {
<b class="nc"><i class="no-highlight">4015</i>&nbsp;                    oneFileResults = schemaDetector.detectSchema();</b>
<i class="no-highlight">4016</i>&nbsp;                }
<i class="no-highlight">4017</i>&nbsp;                if (oneFileResults == null ||
<b class="nc"><i class="no-highlight">4018</i>&nbsp;                        (oneFileResults != null &amp;&amp; oneFileResults.isEmpty())) {</b>
<i class="no-highlight">4019</i>&nbsp;                    continue;
<i class="no-highlight">4020</i>&nbsp;                }
<i class="no-highlight">4021</i>&nbsp;
<i class="no-highlight">4022</i>&nbsp;                // Merge oneFileResults and the previous result.
<i class="no-highlight">4023</i>&nbsp;                oneFileResults.merge(result);
<i class="no-highlight">4024</i>&nbsp;                result = oneFileResults;
<i class="no-highlight">4025</i>&nbsp;                if (result.isDataTypeListComplete()) {
<i class="no-highlight">4026</i>&nbsp;                    break;
<i class="no-highlight">4027</i>&nbsp;                } else if (result.areColumnNamesNotMatchingAmongFiles()) {
<b class="nc"><i class="no-highlight">4028</i>&nbsp;                    // Column names from multiple files do not match</b>
<b class="nc"><i class="no-highlight">4029</i>&nbsp;                    LOGGER.warn(&quot;Column names from multiple input files do not match&quot;);</b>
<i class="no-highlight">4030</i>&nbsp;                    return new LinkedHashMap&lt;&gt;();
<b class="nc"><i class="no-highlight">4031</i>&nbsp;                }</b>
<i class="no-highlight">4032</i>&nbsp;            }
<b class="nc"><i class="no-highlight">4033</i>&nbsp;        }  else {</b>
<i class="no-highlight">4034</i>&nbsp;            throw new ConfigurationException(ERR_NO_FILES_FOUND_TO_COPY_FROM)
<i class="no-highlight">4035</i>&nbsp;                    .withReason(REASON_NO_FILES_FOUND_FROM_LIST_PATTERN)
<i class="no-highlight">4036</i>&nbsp;                    .withResolution(RES_NO_FILES_FOUND_FROM_LIST_PATTERN);
<i class="no-highlight">4037</i>&nbsp;        }
<i class="no-highlight">4038</i>&nbsp;
<i class="no-highlight">4039</i>&nbsp;        // If performFinalProcessing is true, set varchar to unknown columns.
<b class="nc"><i class="no-highlight">4040</i>&nbsp;        if (result != null &amp;&amp; performFinalProcessing) {</b>
<b class="nc"><i class="no-highlight">4041</i>&nbsp;            result.setVarcharToUnknownType();</b>
<b class="nc"><i class="no-highlight">4042</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4043</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4044</i>&nbsp;        // Return only a complete source column map.</b>
<b class="nc"><i class="no-highlight">4045</i>&nbsp;        return result != null &amp;&amp; result.isDataTypeListComplete() ?</b>
<b class="nc"><i class="no-highlight">4046</i>&nbsp;                result.getSourceColumnMap() : null;</b>
<i class="no-highlight">4047</i>&nbsp;    }
<i class="no-highlight">4048</i>&nbsp;
<b class="nc"><i class="no-highlight">4049</i>&nbsp;    private void setUpFilesForSchemaInference() {</b>
<b class="nc"><i class="no-highlight">4050</i>&nbsp;        if (isRedshiftDb() ||</b>
<i class="no-highlight">4051</i>&nbsp;                isSnowflakeDb() &amp;&amp; !isSourceLocationAzureAndFileNamePatternNotEmpty()) {
<b class="nc"><i class="no-highlight">4052</i>&nbsp;            filesForSchemaInference = new ArrayList&lt;&gt;(files);</b>
<i class="no-highlight">4053</i>&nbsp;        }
<i class="no-highlight">4054</i>&nbsp;    }
<i class="no-highlight">4055</i>&nbsp;
<i class="no-highlight">4056</i>&nbsp;    private boolean isSourceLocationAzureAndFileNamePatternNotEmpty() {
<b class="nc"><i class="no-highlight">4057</i>&nbsp;        return StringUtils</b>
<i class="no-highlight">4058</i>&nbsp;                .equalsIgnoreCase(
<b class="nc"><i class="no-highlight">4059</i>&nbsp;                        AZURE, eltDatabaseAccount.getSourceLocation()) &amp;&amp;</b>
<b class="nc"><i class="no-highlight">4060</i>&nbsp;                StringUtils.isNotBlank(filePattern);</b>
<i class="no-highlight">4061</i>&nbsp;    }
<b class="nc"><i class="no-highlight">4062</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4063</i>&nbsp;    private SchemaDetectionResult detectSchemaStorageIntegrationSnowflake(</b>
<b class="nc"><i class="no-highlight">4064</i>&nbsp;            FileSchemaDetector schemaDetector, String filePath) {</b>
<i class="no-highlight">4065</i>&nbsp;        String[] chunk = null;
<i class="no-highlight">4066</i>&nbsp;        String sqlString = buildSelectSqlFromExtStageSnowflake(filePath);
<i class="no-highlight">4067</i>&nbsp;        chunk = executeSqlForInputFileChunk(account, sqlString, DEFAULT_READ_RECORD_COUNT);
<i class="no-highlight">4068</i>&nbsp;        return schemaDetector.detectSchema(chunk);
<b class="nc"><i class="no-highlight">4069</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">4070</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4071</i>&nbsp;    private String[] executeSqlForInputFileChunk(final DatabaseAccount account,</b>
<i class="no-highlight">4072</i>&nbsp;                                                   final String sqlString,
<b class="nc"><i class="no-highlight">4073</i>&nbsp;                                                   final int chunkSizeToRead) {</b>
<i class="no-highlight">4074</i>&nbsp;        try (DatabaseCursor cursor = executeSqlStmt(sqlString, bindValues, account)) {
<b class="nc"><i class="no-highlight">4075</i>&nbsp;            Map&lt;String, Object&gt; records = new LinkedHashMap&lt;&gt;();</b>
<b class="nc"><i class="no-highlight">4076</i>&nbsp;            List&lt;Object&gt; recordList = new ArrayList&lt;&gt;();</b>
<i class="no-highlight">4077</i>&nbsp;            int chunkRecordCount = 0;
<i class="no-highlight">4078</i>&nbsp;
<i class="no-highlight">4079</i>&nbsp;            while (cursor.hasNext() &amp;&amp;
<i class="no-highlight">4080</i>&nbsp;                    chunkRecordCount &lt; chunkSizeToRead) {
<i class="no-highlight">4081</i>&nbsp;                Collection&lt;Object&gt; values = cursor.fetchOne().values();
<b class="nc"><i class="no-highlight">4082</i>&nbsp;                if (!values.isEmpty()) {</b>
<b class="nc"><i class="no-highlight">4083</i>&nbsp;                    recordList.addAll(values);</b>
<b class="nc"><i class="no-highlight">4084</i>&nbsp;                    chunkRecordCount++;</b>
<b class="nc"><i class="no-highlight">4085</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">4086</i>&nbsp;            }</b>
<i class="no-highlight">4087</i>&nbsp;
<b class="nc"><i class="no-highlight">4088</i>&nbsp;            String[] chunk = recordList.isEmpty() ? null : recordList.toArray(new String[0]);</b>
<b class="nc"><i class="no-highlight">4089</i>&nbsp;</b>
<i class="no-highlight">4090</i>&nbsp;            return chunk;
<i class="no-highlight">4091</i>&nbsp;        } catch (SQLException e) {
<i class="no-highlight">4092</i>&nbsp;            SnapDataException exception =
<i class="no-highlight">4093</i>&nbsp;                    new SnapDataException(e, ERR_READ_FILE_USING_SQL_FOR_SCHEMA_INFERENCE)
<b class="nc"><i class="no-highlight">4094</i>&nbsp;                            .withReason(e.getLocalizedMessage())</b>
<b class="nc"><i class="no-highlight">4095</i>&nbsp;                            .withResolution(RESOLUTION_ADDRESS_ISSUE_OR_CONTACT);</b>
<b class="nc"><i class="no-highlight">4096</i>&nbsp;            throw exception;</b>
<b class="nc"><i class="no-highlight">4097</i>&nbsp;        } catch (Exception e) {</b>
<i class="no-highlight">4098</i>&nbsp;            throw new ExecutionException(e, ERR_READ_FILE_USING_SQL_FOR_SCHEMA_INFERENCE)
<b class="nc"><i class="no-highlight">4099</i>&nbsp;                    .withReason(e.getLocalizedMessage())</b>
<i class="no-highlight">4100</i>&nbsp;                    .withResolution(RESOLUTION_ADDRESS_ISSUE_OR_CONTACT);
<i class="no-highlight">4101</i>&nbsp;        }
<i class="no-highlight">4102</i>&nbsp;    }
<b class="nc"><i class="no-highlight">4103</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4104</i>&nbsp;    private String buildSelectSqlFromExtStageSnowflake(String filePath) {</b>
<b class="nc"><i class="no-highlight">4105</i>&nbsp;        return String.format(</b>
<b class="nc"><i class="no-highlight">4106</i>&nbsp;                SELECT_FROM_EXTERNAL_STAGE,</b>
<i class="no-highlight">4107</i>&nbsp;                externalStageName,
<i class="no-highlight">4108</i>&nbsp;                filePath);
<b class="nc"><i class="no-highlight">4109</i>&nbsp;    }</b>
<i class="no-highlight">4110</i>&nbsp;
<i class="no-highlight">4111</i>&nbsp;    private void throwExceptionIfInvalidSourceLocationForDetector(
<i class="no-highlight">4112</i>&nbsp;            String sourceLocation, String dbType) {
<b class="nc"><i class="no-highlight">4113</i>&nbsp;        if (StringUtils.isBlank(sourceLocation)) {</b>
<b class="nc"><i class="no-highlight">4114</i>&nbsp;            sourceLocation = &quot;NULL&quot;;</b>
<b class="nc"><i class="no-highlight">4115</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4116</i>&nbsp;        throw new ConfigurationException(ERR_INVALID_SOURCE_LOCATION_FOR_SCHEMA_INFERENCE)</b>
<b class="nc"><i class="no-highlight">4117</i>&nbsp;                .withReason(String.format(</b>
<i class="no-highlight">4118</i>&nbsp;                        REASON_INVALID_SOURCE_LOCATION_FOR_SCHEMA_INFERENCE,
<i class="no-highlight">4119</i>&nbsp;                        sourceLocation, dbType))
<i class="no-highlight">4120</i>&nbsp;                .withResolution(RESOLUTION_INVALID_SOURCE_LOCATION_FOR_SCHEMA_INFERENCE);
<i class="no-highlight">4121</i>&nbsp;    }
<i class="no-highlight">4122</i>&nbsp;
<i class="no-highlight">4123</i>&nbsp;    private void throwExceptionIfNotSupportedFileTypeForSchemaInference(String dbType) {
<b class="nc"><i class="no-highlight">4124</i>&nbsp;        throw new ConfigurationException(ERR_UNSUPPORTED_FILE_FORMAT_TYPE_FOR_SCHEMA_INFERENCE)</b>
<i class="no-highlight">4125</i>&nbsp;                .withReason(String.format(
<i class="no-highlight">4126</i>&nbsp;                        REASON_UNSUPPORTED_FILE_FORMAT_TYPE_FOR_SCHEMA_INFERENCE,
<i class="no-highlight">4127</i>&nbsp;                        fileFormatType, dbType))
<i class="no-highlight">4128</i>&nbsp;                .withResolution(RESOLUTION_UNSUPPORTED_FILE_FORMAT_TYPE_FOR_SCHEMA_INFERENCE);
<i class="no-highlight">4129</i>&nbsp;    }
<i class="no-highlight">4130</i>&nbsp;
<b class="nc"><i class="no-highlight">4131</i>&nbsp;    private void throwExceptionIfNotSupportedDbTypeForSchemaInference(String dbType) {</b>
<i class="no-highlight">4132</i>&nbsp;        throw new ConfigurationException(ERR_UNSUPPORTED_DB_TYPE_FOR_SCHEMA_INFERENCE)
<i class="no-highlight">4133</i>&nbsp;                .withReason(String.format(
<i class="no-highlight">4134</i>&nbsp;                        REASON_UNSUPPORTED_DB_TYPE_FOR_SCHEMA_INFERENCE, dbType))
<i class="no-highlight">4135</i>&nbsp;                .withResolution(RESOLUTION_UNSUPPORTED_DB_TYPE_FOR_SCHEMA_INFERENCE);
<b class="nc"><i class="no-highlight">4136</i>&nbsp;    }</b>
<i class="no-highlight">4137</i>&nbsp;
<i class="no-highlight">4138</i>&nbsp;    private void validateFileFormatOptionsForSchemaInference() {
<i class="no-highlight">4139</i>&nbsp;        if (isRedshiftDb()) {
<b class="nc"><i class="no-highlight">4140</i>&nbsp;            // Currently only support GZIP compression type</b>
<b class="nc"><i class="no-highlight">4141</i>&nbsp;            if (StringUtils.isNotEmpty(compressionType) &amp;&amp;</b>
<i class="no-highlight">4142</i>&nbsp;                    !StringUtils.equalsIgnoreCase(compressionType,
<b class="nc"><i class="no-highlight">4143</i>&nbsp;                            REDSHIFT_COMPRESSION_GZIP)) {</b>
<i class="no-highlight">4144</i>&nbsp;                throw new ConfigurationException(
<b class="nc"><i class="no-highlight">4145</i>&nbsp;                        ERR_UNSUPPORTED_COMPRESSION_TYPE_FOR_SCHEMA_INFERENCE)</b>
<b class="nc"><i class="no-highlight">4146</i>&nbsp;                        .withReason(String.format(</b>
<b class="nc"><i class="no-highlight">4147</i>&nbsp;                                REASON_UNSUPPORTED_COMPRESSION_TYPE_FOR_SCHEMA_INFERENCE,</b>
<b class="nc"><i class="no-highlight">4148</i>&nbsp;                                compressionType))</b>
<b class="nc"><i class="no-highlight">4149</i>&nbsp;                        .withResolution(</b>
<i class="no-highlight">4150</i>&nbsp;                                RESOLUTION_UNSUPPORTED_COMPRESSION_TYPE_FOR_SCHEMA_INFERENCE);
<i class="no-highlight">4151</i>&nbsp;            }
<b class="nc"><i class="no-highlight">4152</i>&nbsp;</b>
<i class="no-highlight">4153</i>&nbsp;            // &quot;JSON &#39;s3://somename&#39;&quot; file format option here indicates
<b class="nc"><i class="no-highlight">4154</i>&nbsp;            // JSONPaths file is given for JSON.</b>
<i class="no-highlight">4155</i>&nbsp;            // But if &quot;inferSchemaEnabled&quot; is TRUE, throw an exception
<i class="no-highlight">4156</i>&nbsp;            // since we do not support currently JSONPaths file for
<b class="nc"><i class="no-highlight">4157</i>&nbsp;            // automatic schema inference.</b>
<i class="no-highlight">4158</i>&nbsp;            // Currently does not support JSONPaths for schema inference.
<i class="no-highlight">4159</i>&nbsp;            if (isJsonPathsOptionGivenForJson) {
<i class="no-highlight">4160</i>&nbsp;                throw new ConfigurationException(
<i class="no-highlight">4161</i>&nbsp;                        ERR_JSONPATHS_AND_SCHEMA_INFERENCE_DETECTED)
<b class="nc"><i class="no-highlight">4162</i>&nbsp;                        .withReason(</b>
<i class="no-highlight">4163</i>&nbsp;                                REASON_JSONPATHS_FILE_UNSUPPORTED_FOR_SCHEMA_INFERENCE)
<i class="no-highlight">4164</i>&nbsp;                        .withResolution(
<i class="no-highlight">4165</i>&nbsp;                                RESOLUTION_JSONPATHS_FILE_UNSUPPORTED_FOR_SCHEMA_INFERENCE);
<b class="nc"><i class="no-highlight">4166</i>&nbsp;            }</b>
<i class="no-highlight">4167</i>&nbsp;        }
<b class="nc"><i class="no-highlight">4168</i>&nbsp;    }</b>
<i class="no-highlight">4169</i>&nbsp;
<b class="nc"><i class="no-highlight">4170</i>&nbsp;    private boolean isFileFormatJSON() {</b>
<b class="nc"><i class="no-highlight">4171</i>&nbsp;        if (isRedshiftDb()) {</b>
<b class="nc"><i class="no-highlight">4172</i>&nbsp;            if (FILE_FORMAT_TYPE_REDSHIFT.contains(fileFormatType)) {</b>
<b class="nc"><i class="no-highlight">4173</i>&nbsp;                if (StringUtils.equals(fileFormatType, JSON)) {</b>
<b class="nc"><i class="no-highlight">4174</i>&nbsp;                    return true;</b>
<i class="no-highlight">4175</i>&nbsp;                } else if (StringUtils.equals(fileFormatType, NONE)) {
<i class="no-highlight">4176</i>&nbsp;                    String formatOpts = StringUtils.join(fileFormatOptions, SPACE);
<b class="nc"><i class="no-highlight">4177</i>&nbsp;                    return StringUtils.indexOf(formatOpts, JSON) &gt;= 0;</b>
<i class="no-highlight">4178</i>&nbsp;                }
<b class="nc"><i class="no-highlight">4179</i>&nbsp;            }</b>
<i class="no-highlight">4180</i>&nbsp;        } else if (StringUtils.equalsIgnoreCase(fileFormatType, JSON)) {
<i class="no-highlight">4181</i>&nbsp;            return true;
<b class="nc"><i class="no-highlight">4182</i>&nbsp;        }</b>
<i class="no-highlight">4183</i>&nbsp;        return false;
<i class="no-highlight">4184</i>&nbsp;    }
<i class="no-highlight">4185</i>&nbsp;
<b class="nc"><i class="no-highlight">4186</i>&nbsp;    private void appendFilesOrPatternTypeDLP() {</b>
<i class="no-highlight">4187</i>&nbsp;        String fileStr;
<i class="no-highlight">4188</i>&nbsp;        if (CollectionUtils.isNotEmpty(filePaths)) {
<i class="no-highlight">4189</i>&nbsp;            // Format: FILES = ( &#39;file1&#39;,&#39;file2&#39;,&#39;file3&#39;... )
<b class="nc"><i class="no-highlight">4190</i>&nbsp;            fileStr = String.format(FILES_FMT, StringUtils.join(filePaths, COMMA_WITH_QUOTES));</b>
<b class="nc"><i class="no-highlight">4191</i>&nbsp;            queryBuilder.append(fileStr);</b>
<i class="no-highlight">4192</i>&nbsp;        }
<i class="no-highlight">4193</i>&nbsp;        if (StringUtils.isNotBlank(filePattern)) {
<i class="no-highlight">4194</i>&nbsp;            fileStr = String.format(FILE_FORMAT_PATTERN, filePattern);
<b class="nc"><i class="no-highlight">4195</i>&nbsp;            queryBuilder.append(fileStr);</b>
<i class="no-highlight">4196</i>&nbsp;        }
<i class="no-highlight">4197</i>&nbsp;    }
<i class="no-highlight">4198</i>&nbsp;
<b class="nc"><i class="no-highlight">4199</i>&nbsp;    private void buildGCSSourceURIsListFromFilesOrPatternTypeBigQuery() {</b>
<b class="nc"><i class="no-highlight">4200</i>&nbsp;        if (CollectionUtils.isNotEmpty(filePaths)) {</b>
<i class="no-highlight">4201</i>&nbsp;            for (String filePath : filePaths) {
<i class="no-highlight">4202</i>&nbsp;                gcsSourceURIs.add(String.format(GCS_SOURCE_URI_FORMAT,
<b class="nc"><i class="no-highlight">4203</i>&nbsp;                        GS, gcsBucket, gcsFolder, filePath));</b>
<b class="nc"><i class="no-highlight">4204</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">4205</i>&nbsp;        }</b>
<i class="no-highlight">4206</i>&nbsp;        if (StringUtils.isNotBlank(filePattern)) {
<i class="no-highlight">4207</i>&nbsp;            gcsSourceURIs.add(String.format(GCS_SOURCE_URI_FORMAT,
<i class="no-highlight">4208</i>&nbsp;                    GS, gcsBucket, gcsFolder, filePattern));
<i class="no-highlight">4209</i>&nbsp;        }
<b class="nc"><i class="no-highlight">4210</i>&nbsp;    }</b>
<i class="no-highlight">4211</i>&nbsp;
<b class="nc"><i class="no-highlight">4212</i>&nbsp;    private Set&lt;String&gt; buildS3SourceURIs() {</b>
<b class="nc"><i class="no-highlight">4213</i>&nbsp;        Set&lt;String&gt; sourceUris = new HashSet&lt;&gt;();</b>
<i class="no-highlight">4214</i>&nbsp;        if (CollectionUtils.isNotEmpty(filePaths)) {
<b class="nc"><i class="no-highlight">4215</i>&nbsp;            sourceUris = filePaths.stream()</b>
<b class="nc"><i class="no-highlight">4216</i>&nbsp;                    .map(path -&gt; String.format(S3_SOURCE_URI_FORMAT,</b>
<i class="no-highlight">4217</i>&nbsp;                            s3Bucket, s3Folder, path)).collect(Collectors.toSet());
<b class="nc"><i class="no-highlight">4218</i>&nbsp;        } else {</b>
<b class="nc"><i class="no-highlight">4219</i>&nbsp;            if (StringUtils.isNotBlank(filePattern)) {</b>
<i class="no-highlight">4220</i>&nbsp;                sourceUris = Set.of(String.format(S3_SOURCE_URI_FORMAT,
<i class="no-highlight">4221</i>&nbsp;                        s3Bucket, s3Folder, filePattern));
<i class="no-highlight">4222</i>&nbsp;            }
<b class="nc"><i class="no-highlight">4223</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4224</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4225</i>&nbsp;        if (CollectionUtils.isEmpty(sourceUris)) {</b>
<b class="nc"><i class="no-highlight">4226</i>&nbsp;            throw new ConfigurationException(ERR_NO_FILES_FOUND_TO_COPY_FROM)</b>
<b class="nc"><i class="no-highlight">4227</i>&nbsp;                    .withReason(REASON_NO_FILES_FOUND_TO_COPY_FROM)</b>
<b class="nc"><i class="no-highlight">4228</i>&nbsp;                    .withResolution(RES_NO_FILES_FOUND_TO_COPY_FROM);</b>
<b class="nc"><i class="no-highlight">4229</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4230</i>&nbsp;        return sourceUris;</b>
<i class="no-highlight">4231</i>&nbsp;    }
<i class="no-highlight">4232</i>&nbsp;
<i class="no-highlight">4233</i>&nbsp;    private void buildS3StagingFolderUriForBqRedshiftTransferLoad() {
<i class="no-highlight">4234</i>&nbsp;        if (StringUtils.isBlank(s3Bucket) || StringUtils.isBlank(s3Folder) ) {
<i class="no-highlight">4235</i>&nbsp;            throw new ConfigurationException(ERR_BLANK_S3_BUCKET_OR_FOLDER_NAME)
<b class="nc"><i class="no-highlight">4236</i>&nbsp;                    .withReason(REASON_BLANK_S3_BUCKET_OR_FOLDER_NAME)</b>
<i class="no-highlight">4237</i>&nbsp;                    .withResolution(RES_BLANK_S3_BUCKET_OR_FOLDER_NAME);
<b class="nc"><i class="no-highlight">4238</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4239</i>&nbsp;</b>
<i class="no-highlight">4240</i>&nbsp;        s3StagingFolderURI = String.format(S3_STAGING_FOLDER_URI_FORMAT, s3Bucket, s3Folder);
<i class="no-highlight">4241</i>&nbsp;    }
<i class="no-highlight">4242</i>&nbsp;
<i class="no-highlight">4243</i>&nbsp;    private void throwExceptionIfFileListEmpty() {
<i class="no-highlight">4244</i>&nbsp;        if (CollectionUtils.isEmpty(files)) {
<i class="no-highlight">4245</i>&nbsp;            if (StringUtils.isNotBlank(filePattern)) {
<b class="nc"><i class="no-highlight">4246</i>&nbsp;                throw new ConfigurationException(ERR_NO_FILES_FOUND_TO_COPY_FROM)</b>
<b class="nc"><i class="no-highlight">4247</i>&nbsp;                        .withReason(REASON_NO_FILES_FOUND_TO_COPY_FROM)</b>
<b class="nc"><i class="no-highlight">4248</i>&nbsp;                        .withResolution(RES_NO_FILES_FOUND_TO_COPY_FROM);</b>
<b class="nc"><i class="no-highlight">4249</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">4250</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4251</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">4252</i>&nbsp;</b>
<i class="no-highlight">4253</i>&nbsp;    @VisibleForTesting
<i class="no-highlight">4254</i>&nbsp;    protected AmazonS3 getS3Client(final AmazonS3ClientBuilder s3) {
<i class="no-highlight">4255</i>&nbsp;        return s3.build();
<b class="nc"><i class="no-highlight">4256</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">4257</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4258</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">4259</i>&nbsp;    protected ListObjectsV2Result getListObjectsV2Result(</b>
<b class="nc"><i class="no-highlight">4260</i>&nbsp;            final AmazonS3 s3Client, final ListObjectsV2Request listObjectsV2Request) {</b>
<b class="nc"><i class="no-highlight">4261</i>&nbsp;</b>
<i class="no-highlight">4262</i>&nbsp;        return s3Client.listObjectsV2(listObjectsV2Request);
<i class="no-highlight">4263</i>&nbsp;    }
<i class="no-highlight">4264</i>&nbsp;
<b class="nc"><i class="no-highlight">4265</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">4266</i>&nbsp;    protected ListObjectsV2Request getListObjectsV2Request() {</b>
<b class="nc"><i class="no-highlight">4267</i>&nbsp;        return new ListObjectsV2Request().withBucketName(s3Bucket).withPrefix(s3Folder);</b>
<i class="no-highlight">4268</i>&nbsp;    }
<i class="no-highlight">4269</i>&nbsp;
<i class="no-highlight">4270</i>&nbsp;    private String buildS3CredentialsForSnowFlake() {
<b class="nc"><i class="no-highlight">4271</i>&nbsp;        String snowflakeAuthType = eltDatabaseAccount.getSnowflakeCredentialsType();</b>
<b class="nc"><i class="no-highlight">4272</i>&nbsp;        StringBuilder credentialsStrBuilder = new StringBuilder();</b>
<b class="nc"><i class="no-highlight">4273</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4274</i>&nbsp;        switch (snowflakeAuthType) {</b>
<b class="nc"><i class="no-highlight">4275</i>&nbsp;            case SOURCE_LOCATION_SESSION_CREDENTIALS: {</b>
<b class="nc"><i class="no-highlight">4276</i>&nbsp;                credentialsStrBuilder.append(String.format(S3_SESSION_CREDENTIALS_FORMAT_SNOWFLAKE,</b>
<b class="nc"><i class="no-highlight">4277</i>&nbsp;                        eltDatabaseAccount.getS3SessionAccessKey(),</b>
<b class="nc"><i class="no-highlight">4278</i>&nbsp;                        eltDatabaseAccount.getS3SessionSecretKey(),</b>
<b class="nc"><i class="no-highlight">4279</i>&nbsp;                        eltDatabaseAccount.getAWSToken()));</b>
<i class="no-highlight">4280</i>&nbsp;                break;
<i class="no-highlight">4281</i>&nbsp;            }
<i class="no-highlight">4282</i>&nbsp;            case SOURCE_LOCATION_CREDENTIALS: {
<b class="nc"><i class="no-highlight">4283</i>&nbsp;                credentialsStrBuilder.append(String.format(S3_CREDENTIALS_FORMAT_SNOWFLAKE,</b>
<b class="nc"><i class="no-highlight">4284</i>&nbsp;                        awsAccessKey, awsSecretKey));</b>
<b class="nc"><i class="no-highlight">4285</i>&nbsp;                break;</b>
<i class="no-highlight">4286</i>&nbsp;            }
<b class="nc"><i class="no-highlight">4287</i>&nbsp;            case STORAGE_INTEGRATION: {</b>
<b class="nc"><i class="no-highlight">4288</i>&nbsp;                credentialsStrBuilder.append(String.format(STORAGE_INTEGRATION_SNOWFLAKE,</b>
<b class="nc"><i class="no-highlight">4289</i>&nbsp;                        storageIntegration));</b>
<b class="nc"><i class="no-highlight">4290</i>&nbsp;                break;</b>
<i class="no-highlight">4291</i>&nbsp;            }
<i class="no-highlight">4292</i>&nbsp;        }
<b class="nc"><i class="no-highlight">4293</i>&nbsp;        return credentialsStrBuilder.toString();</b>
<b class="nc"><i class="no-highlight">4294</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">4295</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4296</i>&nbsp;    private void appendS3CredentialsForRedshift() {</b>
<i class="no-highlight">4297</i>&nbsp;        String redshiftAuthType = eltDatabaseAccount.getRedshiftAuthType();
<i class="no-highlight">4298</i>&nbsp;
<b class="nc"><i class="no-highlight">4299</i>&nbsp;        switch (redshiftAuthType) {</b>
<b class="nc"><i class="no-highlight">4300</i>&nbsp;            case SOURCE_LOCATION_SESSION_CREDENTIALS: {</b>
<b class="nc"><i class="no-highlight">4301</i>&nbsp;                redshiftCredentials = String.format(S3_SESSION_CREDENTIALS_FORMAT_REDSHIFT,</b>
<b class="nc"><i class="no-highlight">4302</i>&nbsp;                        eltDatabaseAccount.getS3SessionAccessKey(),</b>
<i class="no-highlight">4303</i>&nbsp;                        eltDatabaseAccount.getS3SessionSecretKey(),
<i class="no-highlight">4304</i>&nbsp;                        eltDatabaseAccount.getAWSToken());
<i class="no-highlight">4305</i>&nbsp;                break;
<i class="no-highlight">4306</i>&nbsp;            }
<b class="nc"><i class="no-highlight">4307</i>&nbsp;            case SOURCE_LOCATION_CREDENTIALS: {</b>
<b class="nc"><i class="no-highlight">4308</i>&nbsp;                redshiftCredentials = String.format(S3_CREDENTIALS_FORMAT_REDSHIFT,</b>
<b class="nc"><i class="no-highlight">4309</i>&nbsp;                        awsAccessKey, awsSecretKey);</b>
<b class="nc"><i class="no-highlight">4310</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">4311</i>&nbsp;            }</b>
<i class="no-highlight">4312</i>&nbsp;            case IAM_ROLE_CREDENTIALS: {
<i class="no-highlight">4313</i>&nbsp;                redshiftCredentials = String.format(IAM_ROLE, iamRole);
<i class="no-highlight">4314</i>&nbsp;                break;
<i class="no-highlight">4315</i>&nbsp;            }
<i class="no-highlight">4316</i>&nbsp;        }
<b class="nc"><i class="no-highlight">4317</i>&nbsp;        queryBuilder.append(redshiftCredentials);</b>
<b class="nc"><i class="no-highlight">4318</i>&nbsp;    }</b>
<i class="no-highlight">4319</i>&nbsp;
<b class="nc"><i class="no-highlight">4320</i>&nbsp;    private String buildAzureCredentialsForSnowflake() {</b>
<i class="no-highlight">4321</i>&nbsp;        if (!StringUtils.isBlank(storageIntegration)) {
<b class="nc"><i class="no-highlight">4322</i>&nbsp;            return String.format(STORAGE_INTEGRATION_SNOWFLAKE,</b>
<i class="no-highlight">4323</i>&nbsp;                    storageIntegration);
<i class="no-highlight">4324</i>&nbsp;        }
<i class="no-highlight">4325</i>&nbsp;
<i class="no-highlight">4326</i>&nbsp;        return String.format(AZURE_CREDENTIALS_FORMAT, azureSasToken);
<i class="no-highlight">4327</i>&nbsp;    }
<b class="nc"><i class="no-highlight">4328</i>&nbsp;</b>
<i class="no-highlight">4329</i>&nbsp;    private String buildGcsCredentialsForSnowflake() {
<b class="nc"><i class="no-highlight">4330</i>&nbsp;        if (!StringUtils.isBlank(storageIntegration)) {</b>
<b class="nc"><i class="no-highlight">4331</i>&nbsp;            return String.format(STORAGE_INTEGRATION_SNOWFLAKE,</b>
<b class="nc"><i class="no-highlight">4332</i>&nbsp;                    storageIntegration);</b>
<b class="nc"><i class="no-highlight">4333</i>&nbsp;        } else {</b>
<i class="no-highlight">4334</i>&nbsp;            throw new ConfigurationException(ERR_BLANK_STORAGE_INTEGRATION_FIELD)
<i class="no-highlight">4335</i>&nbsp;                    .withReason(REASON_BLANK_STORAGE_INTEGRATION_FIELD)
<i class="no-highlight">4336</i>&nbsp;                    .withResolution(RESOLUTION_BLANK_STORAGE_INTEGRATION_FIELD);
<i class="no-highlight">4337</i>&nbsp;        }
<i class="no-highlight">4338</i>&nbsp;    }
<i class="no-highlight">4339</i>&nbsp;
<b class="nc"><i class="no-highlight">4340</i>&nbsp;    private void appendCredentialsWithSpecifiedEncryptionTypeSnowflake(String sourceLocation) {</b>
<b class="nc"><i class="no-highlight">4341</i>&nbsp;        switch (sourceLocation) {</b>
<b class="nc"><i class="no-highlight">4342</i>&nbsp;            case AMAZON_S3:</b>
<i class="no-highlight">4343</i>&nbsp;                snowFlakeCredentials = buildS3CredentialsForSnowFlake();
<b class="nc"><i class="no-highlight">4344</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">4345</i>&nbsp;            case AZURE:</b>
<b class="nc"><i class="no-highlight">4346</i>&nbsp;                snowFlakeCredentials = buildAzureCredentialsForSnowflake();</b>
<b class="nc"><i class="no-highlight">4347</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">4348</i>&nbsp;            case GOOGLE_CLOUD_STORAGE:</b>
<b class="nc"><i class="no-highlight">4349</i>&nbsp;                snowFlakeCredentials = buildGcsCredentialsForSnowflake();</b>
<b class="nc"><i class="no-highlight">4350</i>&nbsp;                break;</b>
<i class="no-highlight">4351</i>&nbsp;            default:
<i class="no-highlight">4352</i>&nbsp;                break;
<i class="no-highlight">4353</i>&nbsp;        }
<b class="nc"><i class="no-highlight">4354</i>&nbsp;        queryBuilder.append(snowFlakeCredentials);</b>
<b class="nc"><i class="no-highlight">4355</i>&nbsp;        if (encryptionType != null) {</b>
<b class="nc"><i class="no-highlight">4356</i>&nbsp;            if (StringUtils.equals(encryptionType, S3EncryptionType.SSE.toString())) {</b>
<b class="nc"><i class="no-highlight">4357</i>&nbsp;                queryBuilder.append(ENCRYPTION_SSE_S3);</b>
<i class="no-highlight">4358</i>&nbsp;            } else if (StringUtils.equals(encryptionType, S3EncryptionType.SSE_KMS.
<b class="nc"><i class="no-highlight">4359</i>&nbsp;                    toString())) {</b>
<b class="nc"><i class="no-highlight">4360</i>&nbsp;                String encryptionProp = String.format(ENCRYPTION_SSE_KMS, kmsKey);</b>
<b class="nc"><i class="no-highlight">4361</i>&nbsp;                queryBuilder.append(encryptionProp);</b>
<b class="nc"><i class="no-highlight">4362</i>&nbsp;            }</b>
<i class="no-highlight">4363</i>&nbsp;        }
<b class="nc"><i class="no-highlight">4364</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">4365</i>&nbsp;</b>
<i class="no-highlight">4366</i>&nbsp;    private void appendCredentialsWithSpecifiedEncryptionTypeRedshift(String sourceLocation) {
<b class="nc"><i class="no-highlight">4367</i>&nbsp;        switch (sourceLocation) {</b>
<b class="nc"><i class="no-highlight">4368</i>&nbsp;            case AMAZON_S3:</b>
<i class="no-highlight">4369</i>&nbsp;                appendS3CredentialsForRedshift();
<b class="nc"><i class="no-highlight">4370</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">4371</i>&nbsp;            default:</b>
<i class="no-highlight">4372</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">4373</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4374</i>&nbsp;    }</b>
<i class="no-highlight">4375</i>&nbsp;
<b class="nc"><i class="no-highlight">4376</i>&nbsp;    private void retrieveAwsS3Info() {</b>
<b class="nc"><i class="no-highlight">4377</i>&nbsp;        awsAccessKey = eltDatabaseAccount.getAWSAccessId();</b>
<i class="no-highlight">4378</i>&nbsp;        awsSecretKey = eltDatabaseAccount.getAWSSecretKey();
<b class="nc"><i class="no-highlight">4379</i>&nbsp;        s3Bucket = eltDatabaseAccount.getBucketName();</b>
<i class="no-highlight">4380</i>&nbsp;        s3Folder = eltDatabaseAccount.getFolderPath();
<i class="no-highlight">4381</i>&nbsp;        storageIntegration = eltDatabaseAccount.getStorageIntegration();
<b class="nc"><i class="no-highlight">4382</i>&nbsp;        iamRole = eltDatabaseAccount.getIamRole();</b>
<b class="nc"><i class="no-highlight">4383</i>&nbsp;        s3BucketRegion = eltDatabaseAccount.getS3BucketRegion();</b>
<i class="no-highlight">4384</i>&nbsp;    }
<i class="no-highlight">4385</i>&nbsp;
<i class="no-highlight">4386</i>&nbsp;    private void retrieveAzureInfo() {
<i class="no-highlight">4387</i>&nbsp;        azureExternalLocation = eltDatabaseAccount.getAzureExternalLocation();
<b class="nc"><i class="no-highlight">4388</i>&nbsp;        azureAccountName = eltDatabaseAccount.getAzureAccountName();</b>
<b class="nc"><i class="no-highlight">4389</i>&nbsp;        azureContainer = eltDatabaseAccount.getAzureContainer();</b>
<b class="nc"><i class="no-highlight">4390</i>&nbsp;        azureFolder = eltDatabaseAccount.getAzureFolder();</b>
<i class="no-highlight">4391</i>&nbsp;        azureSasToken = eltDatabaseAccount.getAzureSasToken();
<i class="no-highlight">4392</i>&nbsp;        storageIntegration = eltDatabaseAccount.getStorageIntegration();
<b class="nc"><i class="no-highlight">4393</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">4394</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4395</i>&nbsp;    private void retrieveGCSInfo() {</b>
<i class="no-highlight">4396</i>&nbsp;        gcsBucket = eltDatabaseAccount.getGCSBucketName();
<b class="nc"><i class="no-highlight">4397</i>&nbsp;        gcsFolder = eltDatabaseAccount.getGCSFolderPath();</b>
<b class="nc"><i class="no-highlight">4398</i>&nbsp;        storageIntegration = eltDatabaseAccount.getStorageIntegration();</b>
<i class="no-highlight">4399</i>&nbsp;    }
<b class="nc"><i class="no-highlight">4400</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4401</i>&nbsp;    private void retrieveDBFSFolderPathInfo() {</b>
<b class="nc"><i class="no-highlight">4402</i>&nbsp;        dbfsFolder = Stream.of(StringUtils.trim(eltDatabaseAccount.getDBFSFolderPath()),</b>
<i class="no-highlight">4403</i>&nbsp;                        eltDatabaseAccount.getDlpMounts().stream()
<i class="no-highlight">4404</i>&nbsp;                                .findFirst()
<b class="nc"><i class="no-highlight">4405</i>&nbsp;                                .orElse(EMPTY_STRING))</b>
<b class="nc"><i class="no-highlight">4406</i>&nbsp;                .filter(StringUtils::isNotBlank)</b>
<b class="nc"><i class="no-highlight">4407</i>&nbsp;                .findFirst()</b>
<b class="nc"><i class="no-highlight">4408</i>&nbsp;                .orElseThrow(() -&gt; new ConfigurationException(ERR_DBFS_FOLDER_EMPTY)</b>
<b class="nc"><i class="no-highlight">4409</i>&nbsp;                        .withReason(REASON_DBFS_FOLDER_EMPTY)</b>
<i class="no-highlight">4410</i>&nbsp;                        .withResolution(RESOLUTION_DBFS_FOLDER_EMPTY));
<i class="no-highlight">4411</i>&nbsp;    }
<b class="nc"><i class="no-highlight">4412</i>&nbsp;</b>
<i class="no-highlight">4413</i>&nbsp;    private void retrieveBqRedshiftJdbcUrlAndCredentialsInfo() {
<b class="nc"><i class="no-highlight">4414</i>&nbsp;        bqRedshiftJdbcUrl = eltDatabaseAccount.getBqRedshiftJdbcUrl();</b>
<b class="nc"><i class="no-highlight">4415</i>&nbsp;        bqRedshiftDbUserName = eltDatabaseAccount.getBqRedshiftDbUserName();</b>
<b class="nc"><i class="no-highlight">4416</i>&nbsp;        bqRedshiftDbPassword = eltDatabaseAccount.getBqRedshiftDbPassword();</b>
<b class="nc"><i class="no-highlight">4417</i>&nbsp;</b>
<i class="no-highlight">4418</i>&nbsp;        if (StringUtils.isBlank(bqRedshiftJdbcUrl)) {
<i class="no-highlight">4419</i>&nbsp;            throw new ConfigurationException(ERR_BLANK_BQ_REDSHIFT_JDBC_URL)
<i class="no-highlight">4420</i>&nbsp;                    .withReason(REASON_BLANK_BQ_REDSHIFT_JDBC_URL)
<i class="no-highlight">4421</i>&nbsp;                    .withResolution(RESOLUTION_BLANK_BQ_REDSHIFT_JDBC_URL);
<b class="nc"><i class="no-highlight">4422</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4423</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4424</i>&nbsp;        if (StringUtils.isBlank(bqRedshiftDbUserName)) {</b>
<i class="no-highlight">4425</i>&nbsp;            throw new ConfigurationException(ERR_BLANK_BQ_REDSHIFT_DB_USER_NAME)
<b class="nc"><i class="no-highlight">4426</i>&nbsp;                    .withReason(REASON_BLANK_BQ_REDSHIFT_DB_USER_NAME)</b>
<b class="nc"><i class="no-highlight">4427</i>&nbsp;                    .withResolution(RESOLUTION_BLANK_BQ_REDSHIFT_DB_USER_NAME);</b>
<b class="nc"><i class="no-highlight">4428</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4429</i>&nbsp;</b>
<i class="no-highlight">4430</i>&nbsp;        if (StringUtils.isBlank(bqRedshiftDbPassword)) {
<b class="nc"><i class="no-highlight">4431</i>&nbsp;            throw new ConfigurationException(ERR_BLANK_BQ_REDSHIFT_DB_PASSWORD)</b>
<i class="no-highlight">4432</i>&nbsp;                    .withReason(REASON_BLANK_BQ_REDSHIFT_DB_PASSWORD)
<i class="no-highlight">4433</i>&nbsp;                    .withResolution(RESOLUTION_BLANK_BQ_REDSHIFT_DB_PASSWORD);
<i class="no-highlight">4434</i>&nbsp;        }
<b class="nc"><i class="no-highlight">4435</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">4436</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4437</i>&nbsp;    private void retrieveBqRedshiftSchemaAndTableNames() {</b>
<i class="no-highlight">4438</i>&nbsp;        if (StringUtils.isBlank(bqRedshiftSchemaName) ||
<b class="nc"><i class="no-highlight">4439</i>&nbsp;                StringUtils.isBlank(bqRedshiftTableName)) {</b>
<b class="nc"><i class="no-highlight">4440</i>&nbsp;            throw new ConfigurationException(ERR_BLANK_BQ_REDSHIFT_SCHEMA_OR_TABLE_NAME)</b>
<b class="nc"><i class="no-highlight">4441</i>&nbsp;                    .withReason(REASON_BLANK_BQ_REDSHIFT_SCHEMA_OR_TABLE_NAME)</b>
<b class="nc"><i class="no-highlight">4442</i>&nbsp;                    .withResolution(RESOLUTION_BLANK_BQ_REDSHIFT_SCHEMA_OR_TABLE_NAME);</b>
<b class="nc"><i class="no-highlight">4443</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4444</i>&nbsp;</b>
<i class="no-highlight">4445</i>&nbsp;        // BigQuery Transfer APIs used to load from Redshift table into BigQuery table
<i class="no-highlight">4446</i>&nbsp;        // preserves the table name. That means source and target table names must be
<i class="no-highlight">4447</i>&nbsp;        // same.
<i class="no-highlight">4448</i>&nbsp;        if (!bqRedshiftTableName.equalsIgnoreCase(getTableName())) {
<i class="no-highlight">4449</i>&nbsp;            throw new ConfigurationException(
<b class="nc"><i class="no-highlight">4450</i>&nbsp;                        ERR_MISMATCHED_SOURCE_REDSHIFT_AND_TARGET_BIGQUERY_TABLE_NAME)</b>
<i class="no-highlight">4451</i>&nbsp;                    .withReason(
<b class="nc"><i class="no-highlight">4452</i>&nbsp;                        REASON_MISMATCHED_SOURCE_REDSHIFT_AND_TARGET_BIGQUERY_TABLE_NAME)</b>
<i class="no-highlight">4453</i>&nbsp;                    .withResolution(
<b class="nc"><i class="no-highlight">4454</i>&nbsp;                        RES_MISMATCHED_SOURCE_REDSHIFT_AND_TARGET_BIGQUERY_TABLE_NAME);</b>
<i class="no-highlight">4455</i>&nbsp;        }
<b class="nc"><i class="no-highlight">4456</i>&nbsp;    }</b>
<i class="no-highlight">4457</i>&nbsp;
<b class="nc"><i class="no-highlight">4458</i>&nbsp;    private void retrieveBqTransferDisplayName() {</b>
<i class="no-highlight">4459</i>&nbsp;        bqTransferDisplayName = StringUtils.trim(eltDatabaseAccount.getBQTransferDisplayName());
<b class="nc"><i class="no-highlight">4460</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4461</i>&nbsp;        if (StringUtils.isBlank(bqTransferDisplayName)) {</b>
<i class="no-highlight">4462</i>&nbsp;            throw new ConfigurationException(ERR_BLANK_BQ_TRANSFER_DISPLAY_NAME)
<b class="nc"><i class="no-highlight">4463</i>&nbsp;                    .withReason(REASON_BLANK_BQ_TRANSFER_DISPLAY_NAME)</b>
<i class="no-highlight">4464</i>&nbsp;                    .withResolution(RESOLUTION_BLANK_BQ_TRANSFER_DISPLAY_NAME);
<b class="nc"><i class="no-highlight">4465</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4466</i>&nbsp;    }</b>
<i class="no-highlight">4467</i>&nbsp;
<i class="no-highlight">4468</i>&nbsp;    @Override
<i class="no-highlight">4469</i>&nbsp;    public void execute() {
<b class="nc"><i class="no-highlight">4470</i>&nbsp;        try {</b>
<b class="nc"><i class="no-highlight">4471</i>&nbsp;            Set&lt;String&gt; pendingViews = new HashSet&lt;&gt;(inputViews.names());</b>
<i class="no-highlight">4472</i>&nbsp;            if (!pendingViews.isEmpty()) {
<b class="nc"><i class="no-highlight">4473</i>&nbsp;                pollInputView(pendingViews);</b>
<i class="no-highlight">4474</i>&nbsp;            }
<i class="no-highlight">4475</i>&nbsp;            executeLoad();
<i class="no-highlight">4476</i>&nbsp;            notifyStatusReporter(statusReporter, SNAP_STATS, statistic);
<i class="no-highlight">4477</i>&nbsp;        } catch (Exception ex) {
<b class="nc"><i class="no-highlight">4478</i>&nbsp;            statistic.setSnapStatus(StatisticHolder.SnapStatus.FAIL);</b>
<b class="nc"><i class="no-highlight">4479</i>&nbsp;            notifyStatusReporter(statusReporter, SNAP_STATS, statistic);</b>
<b class="nc"><i class="no-highlight">4480</i>&nbsp;            throw ex;</b>
<b class="nc"><i class="no-highlight">4481</i>&nbsp;        }</b>
<i class="no-highlight">4482</i>&nbsp;    }
<i class="no-highlight">4483</i>&nbsp;
<i class="no-highlight">4484</i>&nbsp;    private void executeLoad() {
<i class="no-highlight">4485</i>&nbsp;        doesTableExist = doesTargetTableExist(ELT_LOAD_TITLE);
<b class="nc"><i class="no-highlight">4486</i>&nbsp;        buildQueryBuilder();</b>
<i class="no-highlight">4487</i>&nbsp;        if (!isAzureSynapseDb()) {
<b class="nc"><i class="no-highlight">4488</i>&nbsp;            setAutoCommitLevel(false);</b>
<b class="nc"><i class="no-highlight">4489</i>&nbsp;        }</b>
<i class="no-highlight">4490</i>&nbsp;
<i class="no-highlight">4491</i>&nbsp;        // if isCreatedStagedTable is true, validateAndExecuteLoadAction() is called
<i class="no-highlight">4492</i>&nbsp;        // as part of the second phase inside executeSnowflakeBulkLoadWithRollback()
<i class="no-highlight">4493</i>&nbsp;        if (!isCreatedStagedTable) {
<i class="no-highlight">4494</i>&nbsp;            validateAndExecuteLoadAction();
<b class="nc"><i class="no-highlight">4495</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4496</i>&nbsp;</b>
<i class="no-highlight">4497</i>&nbsp;        String dbType = getName();
<i class="no-highlight">4498</i>&nbsp;        sqlBulkLoad = queryBuilder.toString().trim();
<i class="no-highlight">4499</i>&nbsp;        switch (dbType) {
<b class="nc"><i class="no-highlight">4500</i>&nbsp;            case JdbcOperations.SNOWFLAKE:</b>
<i class="no-highlight">4501</i>&nbsp;                executeSnowflakeBulkLoadWithRollback();
<i class="no-highlight">4502</i>&nbsp;                break;
<i class="no-highlight">4503</i>&nbsp;            case JdbcOperations.REDSHIFT:
<i class="no-highlight">4504</i>&nbsp;                executeRedshiftBulkLoadWithRollback();
<b class="nc"><i class="no-highlight">4505</i>&nbsp;                break;</b>
<i class="no-highlight">4506</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:
<i class="no-highlight">4507</i>&nbsp;                executeAzureSynapseBulkLoadWithRollback();
<b class="nc"><i class="no-highlight">4508</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">4509</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:</b>
<b class="nc"><i class="no-highlight">4510</i>&nbsp;                executeDLPBulkLoadWithRollback();</b>
<b class="nc"><i class="no-highlight">4511</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">4512</i>&nbsp;            case JdbcOperations.BIGQUERY:</b>
<b class="nc"><i class="no-highlight">4513</i>&nbsp;                executeBigQueryBulkLoadWithRollback();</b>
<b class="nc"><i class="no-highlight">4514</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">4515</i>&nbsp;            default:</b>
<i class="no-highlight">4516</i>&nbsp;                throwInvalidDbTypeException();
<i class="no-highlight">4517</i>&nbsp;        }
<i class="no-highlight">4518</i>&nbsp;
<b class="nc"><i class="no-highlight">4519</i>&nbsp;        handleSuccess();</b>
<i class="no-highlight">4520</i>&nbsp;        processDocument(null, null);
<i class="no-highlight">4521</i>&nbsp;    }
<i class="no-highlight">4522</i>&nbsp;
<i class="no-highlight">4523</i>&nbsp;    protected void validateCsvFileColumNames(Set&lt;String&gt; targetTableColumnNames) {
<i class="no-highlight">4524</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">4525</i>&nbsp;            if (fileFormatType.equals(&quot;CSV&quot;) &amp;&amp;</b>
<i class="no-highlight">4526</i>&nbsp;                    CollectionUtils.isNotEmpty(filePaths) &amp;&amp;
<b class="nc"><i class="no-highlight">4527</i>&nbsp;                    MapUtils.isEmpty(this.columnMappingMap)</b>
<b class="nc"><i class="no-highlight">4528</i>&nbsp;            ) {</b>
<i class="no-highlight">4529</i>&nbsp;
<b class="nc"><i class="no-highlight">4530</i>&nbsp;                for (String path : filePaths) {</b>
<i class="no-highlight">4531</i>&nbsp;                    Set&lt;String&gt; columnNamesFromCsvFile =
<b class="nc"><i class="no-highlight">4532</i>&nbsp;                            toUpperCase(getColumnNamesFromCsvFile(path));</b>
<b class="nc"><i class="no-highlight">4533</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4534</i>&nbsp;                    if (StringUtils.equals(loadAction, ALTER_TABLE)) {</b>
<b class="nc"><i class="no-highlight">4535</i>&nbsp;                        if (!areCsvFileColumnNamesValidForAlterTableLoadActionDLP(</b>
<i class="no-highlight">4536</i>&nbsp;                                targetTableColumnNames, columnNamesFromCsvFile)) {
<i class="no-highlight">4537</i>&nbsp;                            throw new ConfigurationException(MSG_REASON_DIFFERENT_COLUMN_NAMES)
<b class="nc"><i class="no-highlight">4538</i>&nbsp;                                    .withReason(MSG_REASON_DIFFERENT_COLUMN_NAMES)</b>
<b class="nc"><i class="no-highlight">4539</i>&nbsp;                                    .withResolution(RES_DIFFERENT_COLUMN_NAMES );</b>
<b class="nc"><i class="no-highlight">4540</i>&nbsp;                        }</b>
<b class="nc"><i class="no-highlight">4541</i>&nbsp;                    } else {</b>
<i class="no-highlight">4542</i>&nbsp;                        if (!(targetTableColumnNames.size() == columnNamesFromCsvFile.size() &amp;&amp;
<b class="nc"><i class="no-highlight">4543</i>&nbsp;                                targetTableColumnNames.containsAll(columnNamesFromCsvFile))) {</b>
<b class="nc"><i class="no-highlight">4544</i>&nbsp;                            throw new ConfigurationException(MSG_REASON_DIFFERENT_COLUMN_NAMES)</b>
<b class="nc"><i class="no-highlight">4545</i>&nbsp;                                    .withReason(MSG_REASON_DIFFERENT_COLUMN_NAMES)</b>
<b class="nc"><i class="no-highlight">4546</i>&nbsp;                                    .withResolution(RES_DIFFERENT_COLUMN_NAMES );</b>
<b class="nc"><i class="no-highlight">4547</i>&nbsp;                        }</b>
<b class="nc"><i class="no-highlight">4548</i>&nbsp;                    }</b>
<i class="no-highlight">4549</i>&nbsp;                }
<b class="nc"><i class="no-highlight">4550</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">4551</i>&nbsp;        } catch (SQLException sqlException) {</b>
<b class="nc"><i class="no-highlight">4552</i>&nbsp;            throw new ConfigurationException(&quot;Exception during the creation of a temporary table&quot;)</b>
<b class="nc"><i class="no-highlight">4553</i>&nbsp;                    .withReason(sqlException.getMessage());</b>
<i class="no-highlight">4554</i>&nbsp;        }
<b class="nc"><i class="no-highlight">4555</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">4556</i>&nbsp;</b>
<i class="no-highlight">4557</i>&nbsp;    private boolean areCsvFileColumnNamesValidForAlterTableLoadActionDLP(
<i class="no-highlight">4558</i>&nbsp;            Set&lt;String&gt; targetTableColumnNames, Set&lt;String&gt; columnNamesFromCsvFile) {
<b class="nc"><i class="no-highlight">4559</i>&nbsp;        int targetSize = targetTableColumnNames.size();</b>
<b class="nc"><i class="no-highlight">4560</i>&nbsp;        int sourceSize = columnNamesFromCsvFile.size();</b>
<i class="no-highlight">4561</i>&nbsp;        boolean returnValue = false;
<b class="nc"><i class="no-highlight">4562</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4563</i>&nbsp;        if (targetSize &gt;= sourceSize) {</b>
<b class="nc"><i class="no-highlight">4564</i>&nbsp;            returnValue = targetTableColumnNames.containsAll(columnNamesFromCsvFile);</b>
<b class="nc"><i class="no-highlight">4565</i>&nbsp;        } else if (targetSize &lt; sourceSize) {</b>
<b class="nc"><i class="no-highlight">4566</i>&nbsp;            returnValue = columnNamesFromCsvFile.containsAll(targetTableColumnNames);</b>
<b class="nc"><i class="no-highlight">4567</i>&nbsp;        }</b>
<i class="no-highlight">4568</i>&nbsp;        return returnValue;
<i class="no-highlight">4569</i>&nbsp;    }
<i class="no-highlight">4570</i>&nbsp;
<b class="nc"><i class="no-highlight">4571</i>&nbsp;    private void createDLPTableIfDoesntExist(String tableName) throws SQLException {</b>
<b class="nc"><i class="no-highlight">4572</i>&nbsp;        if (!doesTableExist) {</b>
<b class="nc"><i class="no-highlight">4573</i>&nbsp;            sqlCreateTable = buildDLPCreateOrReplaceTableSql(tableName,</b>
<i class="no-highlight">4574</i>&nbsp;                    buildColumnWithDataTypeCreateTable(targetColumns, targetDataTypes),
<b class="nc"><i class="no-highlight">4575</i>&nbsp;                    eltDatabaseAccount, tableOptions);</b>
<b class="nc"><i class="no-highlight">4576</i>&nbsp;            executedQueries.add(sqlCreateTable);</b>
<i class="no-highlight">4577</i>&nbsp;            statistic.addQueryStatistic(
<b class="nc"><i class="no-highlight">4578</i>&nbsp;                    new QueryStatisticHolderBuilder(sqlCreateTable).build());</b>
<b class="nc"><i class="no-highlight">4579</i>&nbsp;            executeSqlStmt(sqlCreateTable, bindValues, account);</b>
<b class="nc"><i class="no-highlight">4580</i>&nbsp;            doesTableExist = true;</b>
<b class="nc"><i class="no-highlight">4581</i>&nbsp;            isCreateTargetTable = true;</b>
<i class="no-highlight">4582</i>&nbsp;        }
<i class="no-highlight">4583</i>&nbsp;    }
<b class="nc"><i class="no-highlight">4584</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4585</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">4586</i>&nbsp;    protected Set&lt;String&gt; getColumnNamesFromCsvFile(String path) throws SQLException {</b>
<b class="nc"><i class="no-highlight">4587</i>&nbsp;        String filePath = String.format(&quot;%s/%s&quot;, dbfsFolder, path);</b>
<b class="nc"><i class="no-highlight">4588</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4589</i>&nbsp;        String tempTableName = getTempTableName(false);</b>
<b class="nc"><i class="no-highlight">4590</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4591</i>&nbsp;        String createTmpTableStatement = String.format(&quot;CREATE TEMPORARY VIEW %s &quot; +</b>
<i class="no-highlight">4592</i>&nbsp;                &quot;USING CSV OPTIONS (&#39;path&#39;=&#39;%s&#39;, &#39;mode&#39;=&#39;FAILFAST&#39; %s)&quot;,
<b class="nc"><i class="no-highlight">4593</i>&nbsp;                tempTableName, filePath, getFileFormatOptionsDLP());</b>
<b class="nc"><i class="no-highlight">4594</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4595</i>&nbsp;        executeSqlStmt(createTmpTableStatement, bindValues, account);</b>
<b class="nc"><i class="no-highlight">4596</i>&nbsp;</b>
<i class="no-highlight">4597</i>&nbsp;        Map&lt;String, String&gt; tableColumnNameDataTypeMap =
<b class="nc"><i class="no-highlight">4598</i>&nbsp;                getTableColumnNameDataTypeMap(tempTableName);</b>
<i class="no-highlight">4599</i>&nbsp;
<b class="nc"><i class="no-highlight">4600</i>&nbsp;        String dropTableQuery = String.format(&quot;drop table %s&quot;, tempTableName);</b>
<b class="nc"><i class="no-highlight">4601</i>&nbsp;</b>
<i class="no-highlight">4602</i>&nbsp;        executeSqlStmt(dropTableQuery, bindValues, account);
<b class="nc"><i class="no-highlight">4603</i>&nbsp;        return tableColumnNameDataTypeMap.keySet();</b>
<i class="no-highlight">4604</i>&nbsp;    }
<i class="no-highlight">4605</i>&nbsp;
<i class="no-highlight">4606</i>&nbsp;    private String getFileFormatOptionsDLP() {
<i class="no-highlight">4607</i>&nbsp;        if (CollectionUtils.isNotEmpty(fileFormatOptions)) {
<i class="no-highlight">4608</i>&nbsp;            return &quot;, &quot; + StringUtils.join(fileFormatOptions, COMMA_SPACE);
<i class="no-highlight">4609</i>&nbsp;        } else {
<i class="no-highlight">4610</i>&nbsp;            return EMPTY_STRING;
<i class="no-highlight">4611</i>&nbsp;        }
<i class="no-highlight">4612</i>&nbsp;    }
<i class="no-highlight">4613</i>&nbsp;
<i class="no-highlight">4614</i>&nbsp;    protected Map&lt;String, String&gt; getTableColumnNameDataTypeMap(String tempTableName) {
<i class="no-highlight">4615</i>&nbsp;        String describeTable = String.format(&quot;describe table %s&quot;, tempTableName);
<i class="no-highlight">4616</i>&nbsp;        Map&lt;String, String&gt; tableColumnNameDataTypeMap = new LinkedHashMap&lt;&gt;();
<i class="no-highlight">4617</i>&nbsp;        findColumnNameDataTypeMap(tableColumnNameDataTypeMap, describeTable);
<i class="no-highlight">4618</i>&nbsp;        return tableColumnNameDataTypeMap;
<i class="no-highlight">4619</i>&nbsp;    }
<b class="nc"><i class="no-highlight">4620</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4621</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4622</i>&nbsp;    private void buildSqlBulkLoadStringForAlterTableAfterLoadAction() {</b>
<b class="nc"><i class="no-highlight">4623</i>&nbsp;        if (!validationInProgress &amp;&amp; StringUtils.equals(loadAction, ALTER_TABLE)) {</b>
<i class="no-highlight">4624</i>&nbsp;            // Complete building COPY INTO SQL.
<b class="nc"><i class="no-highlight">4625</i>&nbsp;            buildQuery(eltDatabaseAccount.getSourceLocation());</b>
<b class="nc"><i class="no-highlight">4626</i>&nbsp;            sqlBulkLoad = queryBuilder.toString().trim();</b>
<i class="no-highlight">4627</i>&nbsp;        }
<i class="no-highlight">4628</i>&nbsp;    }
<i class="no-highlight">4629</i>&nbsp;
<i class="no-highlight">4630</i>&nbsp;    private String buildCreateIntermediateTableSqlRedshift(
<i class="no-highlight">4631</i>&nbsp;            String intermediateTableName) {
<i class="no-highlight">4632</i>&nbsp;        sqlCreateTable = buildRedshiftSnowflakeCreateTableSql(intermediateTableName,
<i class="no-highlight">4633</i>&nbsp;            buildColumnWithDataTypeCreateTable(
<i class="no-highlight">4634</i>&nbsp;                new ArrayList(sourceFileColumnNames),
<b class="nc"><i class="no-highlight">4635</i>&nbsp;                sourceFileColumnTypes),</b>
<i class="no-highlight">4636</i>&nbsp;                null);
<b class="nc"><i class="no-highlight">4637</i>&nbsp;        return sqlCreateTable;</b>
<i class="no-highlight">4638</i>&nbsp;    }
<b class="nc"><i class="no-highlight">4639</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4640</i>&nbsp;    private void executeSnowflakeBulkLoadWithRollback() {</b>
<b class="nc"><i class="no-highlight">4641</i>&nbsp;        // If ALTER_TABLE load action, complete building COPY INTO SQL.</b>
<b class="nc"><i class="no-highlight">4642</i>&nbsp;        buildSqlBulkLoadStringForAlterTableAfterLoadAction();</b>
<i class="no-highlight">4643</i>&nbsp;
<i class="no-highlight">4644</i>&nbsp;        if (!(matchByColumnNameOption &amp;&amp; validationInProgress)) {
<b class="nc"><i class="no-highlight">4645</i>&nbsp;            // MATCH_BY_COLUMN_NAME = CASE_SENSITIVE | CASE_INSENSITIVE and</b>
<i class="no-highlight">4646</i>&nbsp;            // VALIDATION_MODE can not be used together in Snowflake COPY INTO command:
<i class="no-highlight">4647</i>&nbsp;            // SQL compilation error occurs.
<b class="nc"><i class="no-highlight">4648</i>&nbsp;            // Thus execute COPY INTO in validation mode only when matchByColumnNameOption</b>
<b class="nc"><i class="no-highlight">4649</i>&nbsp;            // is false.</b>
<b class="nc"><i class="no-highlight">4650</i>&nbsp;            try {</b>
<i class="no-highlight">4651</i>&nbsp;                // Execute COPY INTO to load data into the target or the staged table
<i class="no-highlight">4652</i>&nbsp;                executeBulkLoadOperationSnowflake(this.sqlBulkLoad);
<b class="nc"><i class="no-highlight">4653</i>&nbsp;            } catch (Exception e) {</b>
<b class="nc"><i class="no-highlight">4654</i>&nbsp;                handleFailures(ERR_BULK_LOAD_SNOWFLAKE);</b>
<i class="no-highlight">4655</i>&nbsp;                throw new SnapDataException(ERR_BULK_LOAD_SNOWFLAKE)
<i class="no-highlight">4656</i>&nbsp;                        .withReason(e.getCause() != null ? e.getCause().getMessage() :
<b class="nc"><i class="no-highlight">4657</i>&nbsp;                                e.getMessage())</b>
<i class="no-highlight">4658</i>&nbsp;                        .withResolution(RESOLUTION_BULK_LOAD);
<b class="nc"><i class="no-highlight">4659</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">4660</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4661</i>&nbsp;</b>
<i class="no-highlight">4662</i>&nbsp;        if (isCreatedStagedTable) {
<b class="nc"><i class="no-highlight">4663</i>&nbsp;            // If the first step is done for two-step based Snowflake transformation,</b>
<i class="no-highlight">4664</i>&nbsp;            // perform the second step here:
<b class="nc"><i class="no-highlight">4665</i>&nbsp;            // Validate and execute load action for target table</b>
<i class="no-highlight">4666</i>&nbsp;            validateAndExecuteLoadAction(); // TODO possibly modify this for ALTER action
<b class="nc"><i class="no-highlight">4667</i>&nbsp;            // Insert Select into the target table</b>
<i class="no-highlight">4668</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">4669</i>&nbsp;                insertSelectToTargetTableSnowflake();</b>
<b class="nc"><i class="no-highlight">4670</i>&nbsp;            } catch (Exception e) {</b>
<b class="nc"><i class="no-highlight">4671</i>&nbsp;                handleFailures(ERR_BULK_LOAD_SNOWFLAKE);</b>
<b class="nc"><i class="no-highlight">4672</i>&nbsp;                throw new SnapDataException(ERR_BULK_LOAD_SNOWFLAKE)</b>
<i class="no-highlight">4673</i>&nbsp;                        .withReason(e.getCause() != null ? e.getCause().getMessage() :
<i class="no-highlight">4674</i>&nbsp;                                e.getMessage())
<b class="nc"><i class="no-highlight">4675</i>&nbsp;                        .withResolution(RESOLUTION_BULK_LOAD);</b>
<i class="no-highlight">4676</i>&nbsp;            }
<i class="no-highlight">4677</i>&nbsp;        }
<b class="nc"><i class="no-highlight">4678</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">4679</i>&nbsp;</b>
<i class="no-highlight">4680</i>&nbsp;    /**
<b class="nc"><i class="no-highlight">4681</i>&nbsp;     * Builds INSERT SELECT INTO the target table SQL and execute.</b>
<i class="no-highlight">4682</i>&nbsp;     * This function builds SQL using
<b class="nc"><i class="no-highlight">4683</i>&nbsp;     * @throws SQLException</b>
<b class="nc"><i class="no-highlight">4684</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">4685</i>&nbsp;    private void insertSelectToTargetTableSnowflake() throws SQLException {</b>
<i class="no-highlight">4686</i>&nbsp;        trimListEntries(targetColumns);
<b class="nc"><i class="no-highlight">4687</i>&nbsp;        List&lt;String&gt; targetColumnNameListToScan = new ArrayList&lt;&gt;(columnMappingMap.keySet());</b>
<i class="no-highlight">4688</i>&nbsp;        List&lt;String&gt; sourceColumnExpressionStrings = new ArrayList&lt;&gt;();
<b class="nc"><i class="no-highlight">4689</i>&nbsp;</b>
<i class="no-highlight">4690</i>&nbsp;        for (String sourceFileFieldName : columnMappingMap.values()) {
<i class="no-highlight">4691</i>&nbsp;            sourceColumnExpressionStrings.add(String.format(SNOWFLAKE_FILE_COLUMN_FORMAT,
<i class="no-highlight">4692</i>&nbsp;                    VARIANT_COL1, sourceFileFieldName, sourceFileFieldName));
<i class="no-highlight">4693</i>&nbsp;        }
<i class="no-highlight">4694</i>&nbsp;
<i class="no-highlight">4695</i>&nbsp;        insertSelectSql = String.format(
<i class="no-highlight">4696</i>&nbsp;                INSERT_INTO_TARGET_SELECT_FROM_STAGED_SNOWFLAKE,
<i class="no-highlight">4697</i>&nbsp;                targetTablePath,
<i class="no-highlight">4698</i>&nbsp;                String.join(COMMA_SPACE, columnMappingMap.keySet()),
<i class="no-highlight">4699</i>&nbsp;                String.join(COMMA_SPACE, sourceColumnExpressionStrings),
<i class="no-highlight">4700</i>&nbsp;                stagedTablePath);
<i class="no-highlight">4701</i>&nbsp;
<i class="no-highlight">4702</i>&nbsp;            executedQueries.add(insertSelectSql);
<i class="no-highlight">4703</i>&nbsp;            int numberOfInserts =
<i class="no-highlight">4704</i>&nbsp;                    executeStatement(insertSelectSql, bindValues, account);
<b class="nc"><i class="no-highlight">4705</i>&nbsp;            statistic.addNumberOfInserts(numberOfInserts);</b>
<b class="nc"><i class="no-highlight">4706</i>&nbsp;            statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">4707</i>&nbsp;                    new QueryStatisticHolderBuilder(insertSelectSql)</b>
<b class="nc"><i class="no-highlight">4708</i>&nbsp;                            .setNumberOfInserts(numberOfInserts)</b>
<b class="nc"><i class="no-highlight">4709</i>&nbsp;                            .build());</b>
<b class="nc"><i class="no-highlight">4710</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">4711</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4712</i>&nbsp;    private void executeRedshiftBulkLoadWithRollback() {</b>
<b class="nc"><i class="no-highlight">4713</i>&nbsp;        if (SKIP_VALIDATION_FILE_FORMAT_REDSHIFT.contains(fileFormatType)</b>
<b class="nc"><i class="no-highlight">4714</i>&nbsp;                &amp;&amp; validationInProgress) {</b>
<b class="nc"><i class="no-highlight">4715</i>&nbsp;            return;</b>
<i class="no-highlight">4716</i>&nbsp;        }
<i class="no-highlight">4717</i>&nbsp;
<i class="no-highlight">4718</i>&nbsp;        // If ALTER_TABLE load action, complete building COPY INTO SQL.
<i class="no-highlight">4719</i>&nbsp;        buildSqlBulkLoadStringForAlterTableAfterLoadAction();
<b class="nc"><i class="no-highlight">4720</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4721</i>&nbsp;        String fileName = EMPTY_STRING;</b>
<b class="nc"><i class="no-highlight">4722</i>&nbsp;        String filePath = EMPTY_STRING;</b>
<b class="nc"><i class="no-highlight">4723</i>&nbsp;        try {</b>
<b class="nc"><i class="no-highlight">4724</i>&nbsp;            if (isIntermediateTargetTableRequired) {</b>
<b class="nc"><i class="no-highlight">4725</i>&nbsp;                // Create an intermediate target table here.</b>
<i class="no-highlight">4726</i>&nbsp;                sqlCreateTable =
<b class="nc"><i class="no-highlight">4727</i>&nbsp;                        buildCreateIntermediateTableSqlRedshift(fqIntermediateTargetTableName);</b>
<b class="nc"><i class="no-highlight">4728</i>&nbsp;                executeSqlStmt(sqlCreateTable, bindValues, account);</b>
<b class="nc"><i class="no-highlight">4729</i>&nbsp;                isIntermediateTableCreated = true;</b>
<b class="nc"><i class="no-highlight">4730</i>&nbsp;            }</b>
<i class="no-highlight">4731</i>&nbsp;
<i class="no-highlight">4732</i>&nbsp;            if (CollectionUtils.isNotEmpty(files)) {
<i class="no-highlight">4733</i>&nbsp;                for (String file : files) {
<i class="no-highlight">4734</i>&nbsp;                    fileName = file;
<i class="no-highlight">4735</i>&nbsp;                    filePath = String.format(FULL_PATH_FILE_FORMAT_REDSHIFT, filePathStage,
<i class="no-highlight">4736</i>&nbsp;                            file);
<b class="nc"><i class="no-highlight">4737</i>&nbsp;                    sqlLoadPerFile = sqlBulkLoad.replaceFirst(filePathStage, filePath);</b>
<b class="nc"><i class="no-highlight">4738</i>&nbsp;                    executedQueries.add(sqlLoadPerFile);</b>
<i class="no-highlight">4739</i>&nbsp;                    statistic.addQueryStatistic(
<b class="nc"><i class="no-highlight">4740</i>&nbsp;                            new QueryStatisticHolderBuilder(sqlLoadPerFile).build());</b>
<b class="nc"><i class="no-highlight">4741</i>&nbsp;                    executeSqlStmt(sqlLoadPerFile, null, account);</b>
<i class="no-highlight">4742</i>&nbsp;                }
<b class="nc"><i class="no-highlight">4743</i>&nbsp;            } else {</b>
<b class="nc"><i class="no-highlight">4744</i>&nbsp;                executedQueries.add(sqlBulkLoad);</b>
<b class="nc"><i class="no-highlight">4745</i>&nbsp;                int numberOfInserts = executeStatement(sqlBulkLoad, null, account);</b>
<b class="nc"><i class="no-highlight">4746</i>&nbsp;                statistic.addNumberOfInserts(numberOfInserts);</b>
<b class="nc"><i class="no-highlight">4747</i>&nbsp;                statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">4748</i>&nbsp;                        new QueryStatisticHolderBuilder(sqlBulkLoad)</b>
<b class="nc"><i class="no-highlight">4749</i>&nbsp;                                .setNumberOfInserts(numberOfInserts)</b>
<b class="nc"><i class="no-highlight">4750</i>&nbsp;                                .build());</b>
<i class="no-highlight">4751</i>&nbsp;
<i class="no-highlight">4752</i>&nbsp;            }
<i class="no-highlight">4753</i>&nbsp;            if (isIntermediateTableCreated) {
<b class="nc"><i class="no-highlight">4754</i>&nbsp;                copyIntoTargetTableRedshift(fqIntermediateTargetTableName, targetTablePath);</b>
<b class="nc"><i class="no-highlight">4755</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">4756</i>&nbsp;        } catch (Exception e) {</b>
<b class="nc"><i class="no-highlight">4757</i>&nbsp;            handleFailures(ERR_BULK_LOAD);</b>
<i class="no-highlight">4758</i>&nbsp;            if (e instanceof SnapDataException) {
<i class="no-highlight">4759</i>&nbsp;                String reason = ((SnapDataException) e).getReason();
<i class="no-highlight">4760</i>&nbsp;                if (StringUtils.containsIgnoreCase(reason, REDSHIFT_CHECK_SYSTEM_TABLE)) {
<i class="no-highlight">4761</i>&nbsp;                    redshiftThrowFileError(fileName, filePath);
<b class="nc"><i class="no-highlight">4762</i>&nbsp;                } else {</b>
<b class="nc"><i class="no-highlight">4763</i>&nbsp;                    String file;</b>
<b class="nc"><i class="no-highlight">4764</i>&nbsp;                    String exception;</b>
<b class="nc"><i class="no-highlight">4765</i>&nbsp;                    if (CollectionUtils.isNotEmpty(files)) {</b>
<i class="no-highlight">4766</i>&nbsp;                        file = fileName;
<i class="no-highlight">4767</i>&nbsp;                        exception = ERR_BULK_LOAD_REDSHIFT;
<i class="no-highlight">4768</i>&nbsp;                    } else {
<i class="no-highlight">4769</i>&nbsp;                        file = filePathStage;
<i class="no-highlight">4770</i>&nbsp;                        exception = ERR_BULK_LOAD_FOLDER_REDSHIFT;
<b class="nc"><i class="no-highlight">4771</i>&nbsp;                    }</b>
<i class="no-highlight">4772</i>&nbsp;                    throw new SnapDataException(exception)
<i class="no-highlight">4773</i>&nbsp;                            .formatWith(file)
<i class="no-highlight">4774</i>&nbsp;                            .withReason(((SnapDataException) e).getReason())
<i class="no-highlight">4775</i>&nbsp;                            .withResolution(RESOLUTION_BULK_LOAD);
<i class="no-highlight">4776</i>&nbsp;                }
<i class="no-highlight">4777</i>&nbsp;            }
<i class="no-highlight">4778</i>&nbsp;            if (e instanceof SnapException) {
<i class="no-highlight">4779</i>&nbsp;                throw new SnapException(ERR_BULK_LOAD)
<b class="nc"><i class="no-highlight">4780</i>&nbsp;                        .withReason(((SnapException)e).getReason() != null ?</b>
<b class="nc"><i class="no-highlight">4781</i>&nbsp;                                ((SnapException)e).getReason() :</b>
<b class="nc"><i class="no-highlight">4782</i>&nbsp;                                e.getMessage())</b>
<i class="no-highlight">4783</i>&nbsp;                        .withResolution(((SnapException)e).getResolution() != null ?
<b class="nc"><i class="no-highlight">4784</i>&nbsp;                                ((SnapException)e).getResolution() :</b>
<i class="no-highlight">4785</i>&nbsp;                                RESOLUTION_BULK_LOAD);
<b class="nc"><i class="no-highlight">4786</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">4787</i>&nbsp;            throw new SnapException(ERR_BULK_LOAD)</b>
<b class="nc"><i class="no-highlight">4788</i>&nbsp;                    .withReason(e.getCause() != null ? e.getCause().getMessage() :</b>
<b class="nc"><i class="no-highlight">4789</i>&nbsp;                            e.getMessage())</b>
<b class="nc"><i class="no-highlight">4790</i>&nbsp;                    .withResolution(RESOLUTION_BULK_LOAD);</b>
<b class="nc"><i class="no-highlight">4791</i>&nbsp;        } finally {</b>
<i class="no-highlight">4792</i>&nbsp;            if (isIntermediateTableCreated) {
<i class="no-highlight">4793</i>&nbsp;                try {
<b class="nc"><i class="no-highlight">4794</i>&nbsp;                    dropTable(fqIntermediateTargetTableName, bindValues);</b>
<b class="nc"><i class="no-highlight">4795</i>&nbsp;                } catch (Exception e) {}</b>
<b class="nc"><i class="no-highlight">4796</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">4797</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4798</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">4799</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4800</i>&nbsp;    /**</b>
<b class="nc"><i class="no-highlight">4801</i>&nbsp;     * This module is used to handle the errors observed during load operation for Redshift;</b>
<i class="no-highlight">4802</i>&nbsp;     * For Folder level load operations, we don&#39;t know which for which file in that folder failed
<b class="nc"><i class="no-highlight">4803</i>&nbsp;     * to load, so we need to fetch the query id which is then mapped in stl_load_errors table</b>
<b class="nc"><i class="no-highlight">4804</i>&nbsp;     * and the row fetched from that table shows the correct filename having an error with other</b>
<i class="no-highlight">4805</i>&nbsp;     * description
<b class="nc"><i class="no-highlight">4806</i>&nbsp;     * For File level load operations, we know exactly which file failed so we don&#39;t need to</b>
<b class="nc"><i class="no-highlight">4807</i>&nbsp;     * fetch the query id. We directly execute the appropriate query in stl_load_errors table</b>
<i class="no-highlight">4808</i>&nbsp;     * filtering by that file, which provides the description accordingly.
<i class="no-highlight">4809</i>&nbsp;     *
<i class="no-highlight">4810</i>&nbsp;     * @param fileName error file name
<i class="no-highlight">4811</i>&nbsp;     * @param filePath error file path
<b class="nc"><i class="no-highlight">4812</i>&nbsp;     */</b>
<i class="no-highlight">4813</i>&nbsp;    private void redshiftThrowFileError(final String fileName, final String filePath) {
<b class="nc"><i class="no-highlight">4814</i>&nbsp;        dbConnection = jdbcOperations.acquireConnection(account);</b>
<b class="nc"><i class="no-highlight">4815</i>&nbsp;        ResultSet rs = null;</b>
<b class="nc"><i class="no-highlight">4816</i>&nbsp;        if (CollectionUtils.isEmpty(files)) {</b>
<b class="nc"><i class="no-highlight">4817</i>&nbsp;            try (PreparedStatement stmt = dbConnection.prepareStatement(</b>
<b class="nc"><i class="no-highlight">4818</i>&nbsp;                    REDSHIFT_FETCH_LAST_QUERY_ID)) {</b>
<b class="nc"><i class="no-highlight">4819</i>&nbsp;                rs = stmt.executeQuery();</b>
<b class="nc"><i class="no-highlight">4820</i>&nbsp;                if (rs.next()) {</b>
<b class="nc"><i class="no-highlight">4821</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4822</i>&nbsp;                    // QueryId in Redshift is not guaranteed to be in order; We need to</b>
<b class="nc"><i class="no-highlight">4823</i>&nbsp;                    // get the query id for COPY operation after performing the END</b>
<i class="no-highlight">4824</i>&nbsp;                    // TRANSACTION which is being done rolling back the failed COPY operation.
<b class="nc"><i class="no-highlight">4825</i>&nbsp;                    // So END TRANSACTION/ ROLLBACK also increments the query# by some number.</b>
<b class="nc"><i class="no-highlight">4826</i>&nbsp;                    // QueryId of failed COPY operation is some number less than fetching the</b>
<b class="nc"><i class="no-highlight">4827</i>&nbsp;                    // current query id; As we don&#39;t know &#39;some&#39; number so we can use &lt; to</b>
<i class="no-highlight">4828</i>&nbsp;                    // fetch the last failed query to get the results
<b class="nc"><i class="no-highlight">4829</i>&nbsp;                    int queryId = rs.getInt(1);</b>
<b class="nc"><i class="no-highlight">4830</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4831</i>&nbsp;                    try (PreparedStatement stmt2 = dbConnection.prepareStatement(</b>
<b class="nc"><i class="no-highlight">4832</i>&nbsp;                            REDSHIFT_LOAD_ERROR_SQL_QUERY_ID)) {</b>
<b class="nc"><i class="no-highlight">4833</i>&nbsp;                        stmt2.setInt(1, queryId);</b>
<b class="nc"><i class="no-highlight">4834</i>&nbsp;                        rs = stmt2.executeQuery();</b>
<b class="nc"><i class="no-highlight">4835</i>&nbsp;                        if (rs.next()) {</b>
<b class="nc"><i class="no-highlight">4836</i>&nbsp;                            redshiftThrowExceptionAfterReadingErrorTable(rs,</b>
<b class="nc"><i class="no-highlight">4837</i>&nbsp;                                    RESOLUTION_LOAD_FILE_FOLDER_REDSHIFT);</b>
<b class="nc"><i class="no-highlight">4838</i>&nbsp;                        } else {</b>
<b class="nc"><i class="no-highlight">4839</i>&nbsp;                            redshiftThrowExceptionBasedOnFileOrFolderLevel(</b>
<b class="nc"><i class="no-highlight">4840</i>&nbsp;                                    ERR_BULK_LOAD_FOLDER_REDSHIFT, filePathStage, null);</b>
<i class="no-highlight">4841</i>&nbsp;                        }
<i class="no-highlight">4842</i>&nbsp;                    }
<i class="no-highlight">4843</i>&nbsp;                } else {
<i class="no-highlight">4844</i>&nbsp;                    redshiftThrowExceptionBasedOnFileOrFolderLevel(ERR_BULK_LOAD_FOLDER_REDSHIFT,
<i class="no-highlight">4845</i>&nbsp;                            filePathStage, null);
<b class="nc"><i class="no-highlight">4846</i>&nbsp;                }</b>
<i class="no-highlight">4847</i>&nbsp;            } catch (SQLException e) {
<i class="no-highlight">4848</i>&nbsp;                redshiftThrowExceptionBasedOnFileOrFolderLevel(ERR_BULK_LOAD_FOLDER_REDSHIFT,
<i class="no-highlight">4849</i>&nbsp;                        filePathStage, e);
<i class="no-highlight">4850</i>&nbsp;            } finally {
<i class="no-highlight">4851</i>&nbsp;                if (rs != null) {
<b class="nc"><i class="no-highlight">4852</i>&nbsp;                    try {</b>
<b class="nc"><i class="no-highlight">4853</i>&nbsp;                        rs.close();</b>
<b class="nc"><i class="no-highlight">4854</i>&nbsp;                    } catch (SQLException e) {</b>
<b class="nc"><i class="no-highlight">4855</i>&nbsp;                        redshiftThrowExceptionBasedOnFileOrFolderLevel(</b>
<i class="no-highlight">4856</i>&nbsp;                                ERR_BULK_LOAD_FOLDER_REDSHIFT, filePathStage, e);
<b class="nc"><i class="no-highlight">4857</i>&nbsp;                    }</b>
<b class="nc"><i class="no-highlight">4858</i>&nbsp;                }</b>
<i class="no-highlight">4859</i>&nbsp;            }
<i class="no-highlight">4860</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">4861</i>&nbsp;            try (PreparedStatement stmt = dbConnection.prepareStatement(</b>
<b class="nc"><i class="no-highlight">4862</i>&nbsp;                    REDSHIFT_LOAD_ERROR_SQL_FILENAME)) {</b>
<b class="nc"><i class="no-highlight">4863</i>&nbsp;                stmt.setString(1, filePath);</b>
<b class="nc"><i class="no-highlight">4864</i>&nbsp;                rs = stmt.executeQuery();</b>
<b class="nc"><i class="no-highlight">4865</i>&nbsp;                if (rs.next()) {</b>
<i class="no-highlight">4866</i>&nbsp;                    redshiftThrowExceptionAfterReadingErrorTable(rs,
<i class="no-highlight">4867</i>&nbsp;                            RESOLUTION_LOAD_FILE_REDSHIFT);
<b class="nc"><i class="no-highlight">4868</i>&nbsp;                } else {</b>
<b class="nc"><i class="no-highlight">4869</i>&nbsp;                    redshiftThrowExceptionBasedOnFileOrFolderLevel(ERR_BULK_LOAD_REDSHIFT,</b>
<b class="nc"><i class="no-highlight">4870</i>&nbsp;                            fileName, null);</b>
<i class="no-highlight">4871</i>&nbsp;                }
<b class="nc"><i class="no-highlight">4872</i>&nbsp;            } catch (SQLException e) {</b>
<b class="nc"><i class="no-highlight">4873</i>&nbsp;                redshiftThrowExceptionBasedOnFileOrFolderLevel(ERR_BULK_LOAD_REDSHIFT, fileName, e);</b>
<i class="no-highlight">4874</i>&nbsp;            } finally {
<b class="nc"><i class="no-highlight">4875</i>&nbsp;                if (rs != null) {</b>
<b class="nc"><i class="no-highlight">4876</i>&nbsp;                    try {</b>
<b class="nc"><i class="no-highlight">4877</i>&nbsp;                        rs.close();</b>
<i class="no-highlight">4878</i>&nbsp;                    } catch (SQLException e) {
<b class="nc"><i class="no-highlight">4879</i>&nbsp;                        redshiftThrowExceptionBasedOnFileOrFolderLevel(ERR_BULK_LOAD_REDSHIFT,</b>
<b class="nc"><i class="no-highlight">4880</i>&nbsp;                                fileName, e);</b>
<b class="nc"><i class="no-highlight">4881</i>&nbsp;                    }</b>
<b class="nc"><i class="no-highlight">4882</i>&nbsp;                }</b>
<i class="no-highlight">4883</i>&nbsp;            }
<i class="no-highlight">4884</i>&nbsp;        }
<i class="no-highlight">4885</i>&nbsp;    }
<b class="nc"><i class="no-highlight">4886</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4887</i>&nbsp;    /**</b>
<i class="no-highlight">4888</i>&nbsp;     * This is a helper module for redshiftThrowFileError which is used to fetch the error
<b class="nc"><i class="no-highlight">4889</i>&nbsp;     * details from the stl_load_errors table</b>
<i class="no-highlight">4890</i>&nbsp;     *
<i class="no-highlight">4891</i>&nbsp;     * @param rs         A table of data representing a database result set, which is usually
<i class="no-highlight">4892</i>&nbsp;     *                   generated by executing a statement that queries the database.
<i class="no-highlight">4893</i>&nbsp;     * @param resolution error resolution message that will be thrown in exception case
<i class="no-highlight">4894</i>&nbsp;     * @throws SQLException if the columnIndex is not valid; if a database access error occurs
<b class="nc"><i class="no-highlight">4895</i>&nbsp;     *                      or this method is called on a closed result set</b>
<b class="nc"><i class="no-highlight">4896</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">4897</i>&nbsp;    private void redshiftThrowExceptionAfterReadingErrorTable(</b>
<i class="no-highlight">4898</i>&nbsp;            final ResultSet rs, final String resolution) throws SQLException {
<b class="nc"><i class="no-highlight">4899</i>&nbsp;        String fileName = rs.getString(1);</b>
<i class="no-highlight">4900</i>&nbsp;        int lineNumber = rs.getInt(2);
<i class="no-highlight">4901</i>&nbsp;        String colName = rs.getString(3);
<i class="no-highlight">4902</i>&nbsp;        int errorCode = rs.getInt(4);
<i class="no-highlight">4903</i>&nbsp;        String errorMessage = rs.getString(5);
<i class="no-highlight">4904</i>&nbsp;        String rawFieldValue = rs.getString(6);
<b class="nc"><i class="no-highlight">4905</i>&nbsp;        String rawLine = rs.getString(7);</b>
<b class="nc"><i class="no-highlight">4906</i>&nbsp;        throw new SnapDataException(errorMessage)</b>
<i class="no-highlight">4907</i>&nbsp;                .withReason(String.format(ERROR_LOAD_FILE_REDSHIFT, lineNumber,
<b class="nc"><i class="no-highlight">4908</i>&nbsp;                        colName, rawFieldValue, rawLine, errorCode, errorMessage))</b>
<b class="nc"><i class="no-highlight">4909</i>&nbsp;                .withResolution(String.format(resolution, fileName));</b>
<i class="no-highlight">4910</i>&nbsp;    }
<b class="nc"><i class="no-highlight">4911</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4912</i>&nbsp;    private void redshiftThrowExceptionBasedOnFileOrFolderLevel(</b>
<i class="no-highlight">4913</i>&nbsp;            final String message,final String fileName, final SQLException e) {
<i class="no-highlight">4914</i>&nbsp;        if (e != null) {
<i class="no-highlight">4915</i>&nbsp;            throw new SnapDataException(e, message)
<i class="no-highlight">4916</i>&nbsp;                    .formatWith(fileName)
<b class="nc"><i class="no-highlight">4917</i>&nbsp;                    .withReason(e.getCause() != null ?</b>
<i class="no-highlight">4918</i>&nbsp;                            e.getCause().getMessage() : e.getMessage())
<i class="no-highlight">4919</i>&nbsp;                    .withResolution(RESOLUTION_BULK_LOAD);
<b class="nc"><i class="no-highlight">4920</i>&nbsp;        } else {</b>
<i class="no-highlight">4921</i>&nbsp;            throw new SnapDataException(message)
<b class="nc"><i class="no-highlight">4922</i>&nbsp;                    .formatWith(fileName)</b>
<i class="no-highlight">4923</i>&nbsp;                    .withReason(REASON_LOAD_ERRORS_REDSHIFT)
<i class="no-highlight">4924</i>&nbsp;                    .withResolution(RESOLUTION_BULK_LOAD);
<i class="no-highlight">4925</i>&nbsp;        }
<i class="no-highlight">4926</i>&nbsp;    }
<i class="no-highlight">4927</i>&nbsp;
<i class="no-highlight">4928</i>&nbsp;    @VisibleForTesting
<b class="nc"><i class="no-highlight">4929</i>&nbsp;    protected void executeBulkLoadOperationSnowflake(final String sqlBulkLoad)</b>
<b class="nc"><i class="no-highlight">4930</i>&nbsp;            throws SQLException {</b>
<i class="no-highlight">4931</i>&nbsp;        if (dbConnection == null) {
<b class="nc"><i class="no-highlight">4932</i>&nbsp;            dbConnection = jdbcOperations.acquireConnection(account);</b>
<b class="nc"><i class="no-highlight">4933</i>&nbsp;        }</b>
<i class="no-highlight">4934</i>&nbsp;        try (Statement stmt = dbConnection.createStatement()) {
<b class="nc"><i class="no-highlight">4935</i>&nbsp;            LOGGER.debug(&quot;(+++) executeBulkLoadOperationSnowflake()&quot; +</b>
<b class="nc"><i class="no-highlight">4936</i>&nbsp;                    &quot; executing SQL :: {}&quot;, sqlBulkLoad);</b>
<i class="no-highlight">4937</i>&nbsp;            executedQueries.add(sqlBulkLoad);
<i class="no-highlight">4938</i>&nbsp;            statistic.addQueryStatistic(
<i class="no-highlight">4939</i>&nbsp;                    new QueryStatisticHolderBuilder(sqlBulkLoad).build());
<i class="no-highlight">4940</i>&nbsp;            stmt.executeQuery(sqlBulkLoad);
<i class="no-highlight">4941</i>&nbsp;            try (ResultSet rs = stmt.getResultSet()) {
<b class="nc"><i class="no-highlight">4942</i>&nbsp;                createResultForOutputView(rs);</b>
<i class="no-highlight">4943</i>&nbsp;            }
<b class="nc"><i class="no-highlight">4944</i>&nbsp;        }</b>
<i class="no-highlight">4945</i>&nbsp;    }
<i class="no-highlight">4946</i>&nbsp;
<i class="no-highlight">4947</i>&nbsp;    private void throwExceptionIfNotDropAndCreateLoadAction() {
<i class="no-highlight">4948</i>&nbsp;        if (!StringUtils.equals(loadAction, DROP_CREATE_TABLE)) {
<i class="no-highlight">4949</i>&nbsp;            throw new ConfigurationException(ERR_TARGET_TABLE_DOES_NOT_EXIST)
<i class="no-highlight">4950</i>&nbsp;                    .withReason(REASON_TARGET_TABLE_DOES_NOT_EXIST)
<i class="no-highlight">4951</i>&nbsp;                    .withResolution(RESOLUTION_TARGET_TABLE_DOES_NOT_EXIST);
<b class="nc"><i class="no-highlight">4952</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4953</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">4954</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4955</i>&nbsp;    private void throwExceptionIfNotDropAndCreateWithSchemaInference() {</b>
<i class="no-highlight">4956</i>&nbsp;        if (!StringUtils.equals(loadAction, DROP_CREATE_TABLE)) {
<b class="nc"><i class="no-highlight">4957</i>&nbsp;            throw new ConfigurationException(ERR_TARGET_TABLE_DOES_NOT_EXIST)</b>
<b class="nc"><i class="no-highlight">4958</i>&nbsp;                    .withReason(REASON_TARGET_TABLE_DOES_NOT_EXIST)</b>
<b class="nc"><i class="no-highlight">4959</i>&nbsp;                    .withResolution(</b>
<i class="no-highlight">4960</i>&nbsp;                            RESOLUTION_TARGET_TABLE_DOES_NOT_EXIST_WITH_INFERENCE);
<b class="nc"><i class="no-highlight">4961</i>&nbsp;        }</b>
<i class="no-highlight">4962</i>&nbsp;    }
<b class="nc"><i class="no-highlight">4963</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">4964</i>&nbsp;    private void validateAndExecuteLoadAction() {</b>
<i class="no-highlight">4965</i>&nbsp;        if (isAzureSynapseDb() || isDeltalakeDb() || isBigQueryDb()) {
<i class="no-highlight">4966</i>&nbsp;            // In case of Azure Synapse or DLP or BigQuery, rollback needs to be handled
<i class="no-highlight">4967</i>&nbsp;            // manually and it&#39;s cleaner to handle that in a separate function.
<b class="nc"><i class="no-highlight">4968</i>&nbsp;            // So all the validation and safety mechanism is moved to the functions</b>
<i class="no-highlight">4969</i>&nbsp;            // executeAzureSynapseBulkLoadWithRollback() and executeDLPBulkLoadWithRollback()
<i class="no-highlight">4970</i>&nbsp;            // respectively
<i class="no-highlight">4971</i>&nbsp;            return;
<b class="nc"><i class="no-highlight">4972</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">4973</i>&nbsp;        try {</b>
<b class="nc"><i class="no-highlight">4974</i>&nbsp;            if (!doesTableExist) {</b>
<i class="no-highlight">4975</i>&nbsp;                if (isRedshiftDb() || isSnowflakeDb()) {
<i class="no-highlight">4976</i>&nbsp;                    throwExceptionIfNotDropAndCreateWithSchemaInference();
<b class="nc"><i class="no-highlight">4977</i>&nbsp;                } else {</b>
<b class="nc"><i class="no-highlight">4978</i>&nbsp;                    throwExceptionIfNotDropAndCreateLoadAction();</b>
<i class="no-highlight">4979</i>&nbsp;                }
<b class="nc"><i class="no-highlight">4980</i>&nbsp;                sqlCreateTable = buildCreateTableSql();</b>
<i class="no-highlight">4981</i>&nbsp;                executedQueries.add(sqlCreateTable);
<b class="nc"><i class="no-highlight">4982</i>&nbsp;                statistic.addQueryStatistic(</b>
<i class="no-highlight">4983</i>&nbsp;                        new QueryStatisticHolderBuilder(sqlCreateTable).build());
<b class="nc"><i class="no-highlight">4984</i>&nbsp;                executeSqlStmt(sqlCreateTable, bindValues, account);</b>
<i class="no-highlight">4985</i>&nbsp;                doesTableExist = true;
<b class="nc"><i class="no-highlight">4986</i>&nbsp;            }</b>
<i class="no-highlight">4987</i>&nbsp;
<b class="nc"><i class="no-highlight">4988</i>&nbsp;            if (StringUtils.equals(loadAction, OVERWRITE_TABLE)) {</b>
<i class="no-highlight">4989</i>&nbsp;                if (!validationInProgress) {
<i class="no-highlight">4990</i>&nbsp;                    sqlDeleteTable = buildDeleteTableSql(targetTablePath);
<i class="no-highlight">4991</i>&nbsp;                    executedQueries.add(sqlDeleteTable);
<b class="nc"><i class="no-highlight">4992</i>&nbsp;                    int numberOfDeletes =</b>
<i class="no-highlight">4993</i>&nbsp;                            executeStatement(sqlDeleteTable, bindValues, account);
<i class="no-highlight">4994</i>&nbsp;                    statistic.addNumberOfDeletes(numberOfDeletes);
<i class="no-highlight">4995</i>&nbsp;                    statistic.addQueryStatistic(
<i class="no-highlight">4996</i>&nbsp;                            new QueryStatisticHolderBuilder(sqlDeleteTable)
<b class="nc"><i class="no-highlight">4997</i>&nbsp;                                    .setNumberOfDeletes(numberOfDeletes)</b>
<i class="no-highlight">4998</i>&nbsp;                                    .build());
<b class="nc"><i class="no-highlight">4999</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">5000</i>&nbsp;            } else if (StringUtils.equals(loadAction, DROP_CREATE_TABLE)) {</b>
<b class="nc"><i class="no-highlight">5001</i>&nbsp;                if (!validationInProgress) {</b>
<i class="no-highlight">5002</i>&nbsp;                    cloneTablePath();
<b class="nc"><i class="no-highlight">5003</i>&nbsp;                    sqlDropTable = buildDropTableSql(targetTablePath);</b>
<b class="nc"><i class="no-highlight">5004</i>&nbsp;                    executedQueries.add(sqlDropTable);</b>
<i class="no-highlight">5005</i>&nbsp;                    int numberOfDeletes =
<i class="no-highlight">5006</i>&nbsp;                            executeStatement(sqlDropTable, bindValues, account);
<b class="nc"><i class="no-highlight">5007</i>&nbsp;                    statistic.addNumberOfDeletes(numberOfDeletes);</b>
<i class="no-highlight">5008</i>&nbsp;                    statistic.addQueryStatistic(
<b class="nc"><i class="no-highlight">5009</i>&nbsp;                            new QueryStatisticHolderBuilder(sqlDropTable)</b>
<b class="nc"><i class="no-highlight">5010</i>&nbsp;                                    .setNumberOfDeletes(numberOfDeletes)</b>
<i class="no-highlight">5011</i>&nbsp;                                    .build());
<i class="no-highlight">5012</i>&nbsp;                    isDropTable = true;
<i class="no-highlight">5013</i>&nbsp;
<i class="no-highlight">5014</i>&nbsp;                    sqlCreateTable = buildCreateTableSql();
<i class="no-highlight">5015</i>&nbsp;                    executedQueries.add(sqlCreateTable);
<b class="nc"><i class="no-highlight">5016</i>&nbsp;                    statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">5017</i>&nbsp;                            new QueryStatisticHolderBuilder(sqlCreateTable).build());</b>
<b class="nc"><i class="no-highlight">5018</i>&nbsp;                    executeSqlStmt(sqlCreateTable, bindValues, account);</b>
<i class="no-highlight">5019</i>&nbsp;                    isCreateTargetTable = true;
<i class="no-highlight">5020</i>&nbsp;                }
<i class="no-highlight">5021</i>&nbsp;            } else if (StringUtils.equals(loadAction, ALTER_TABLE)) {
<b class="nc"><i class="no-highlight">5022</i>&nbsp;                if (!validationInProgress) {</b>
<b class="nc"><i class="no-highlight">5023</i>&nbsp;                    if (isRedshiftDb()) {</b>
<b class="nc"><i class="no-highlight">5024</i>&nbsp;                        sqlAlterTable =</b>
<b class="nc"><i class="no-highlight">5025</i>&nbsp;                                buildRedshiftAlterTableSql(targetColumns, targetDataTypes,</b>
<i class="no-highlight">5026</i>&nbsp;                                        alterColumnModifiers,
<b class="nc"><i class="no-highlight">5027</i>&nbsp;                                        targetTablePath,</b>
<b class="nc"><i class="no-highlight">5028</i>&nbsp;                                        ALTER_TABLE_MULTI_ADD_SQL_FMT,</b>
<i class="no-highlight">5029</i>&nbsp;                                        ALTER_TABLE_MULTI_DROP_SQL_FMT);
<b class="nc"><i class="no-highlight">5030</i>&nbsp;                    } else {</b>
<i class="no-highlight">5031</i>&nbsp;                        sqlAlterTable = buildAlterTableSql(targetColumns, targetDataTypes,
<i class="no-highlight">5032</i>&nbsp;                                alterColumnModifiers,
<i class="no-highlight">5033</i>&nbsp;                                targetTablePath,
<i class="no-highlight">5034</i>&nbsp;                                ALTER_TABLE_MULTI_ADD_SQL_FMT,
<b class="nc"><i class="no-highlight">5035</i>&nbsp;                                ALTER_TABLE_MULTI_DROP_SQL_FMT);</b>
<b class="nc"><i class="no-highlight">5036</i>&nbsp;                    }</b>
<b class="nc"><i class="no-highlight">5037</i>&nbsp;                    cloneTablePath();</b>
<i class="no-highlight">5038</i>&nbsp;                    if (isSnowflakeDb()) {
<b class="nc"><i class="no-highlight">5039</i>&nbsp;                        executedQueries.add(SNOWFLAKE_ALLOW_MULTI_EXECUTE_STATEMENTS);</b>
<b class="nc"><i class="no-highlight">5040</i>&nbsp;                        statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">5041</i>&nbsp;                                new QueryStatisticHolderBuilder(</b>
<b class="nc"><i class="no-highlight">5042</i>&nbsp;                                        SNOWFLAKE_ALLOW_MULTI_EXECUTE_STATEMENTS).build());</b>
<i class="no-highlight">5043</i>&nbsp;                        executeSqlStmt(SNOWFLAKE_ALLOW_MULTI_EXECUTE_STATEMENTS, bindValues,
<i class="no-highlight">5044</i>&nbsp;                                account);
<b class="nc"><i class="no-highlight">5045</i>&nbsp;                    }</b>
<i class="no-highlight">5046</i>&nbsp;                    executedQueries.add(sqlAlterTable);
<i class="no-highlight">5047</i>&nbsp;                    statistic.addQueryStatistic(
<i class="no-highlight">5048</i>&nbsp;                            new QueryStatisticHolderBuilder(sqlAlterTable).build());
<b class="nc"><i class="no-highlight">5049</i>&nbsp;                    executeSqlStmt(sqlAlterTable, bindValues, account);</b>
<b class="nc"><i class="no-highlight">5050</i>&nbsp;                    hasAlterTableBeenExecuted = true;</b>
<i class="no-highlight">5051</i>&nbsp;                }
<b class="nc"><i class="no-highlight">5052</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5053</i>&nbsp;        } catch (Exception e) {</b>
<i class="no-highlight">5054</i>&nbsp;            if (isCreateTargetTable) {
<b class="nc"><i class="no-highlight">5055</i>&nbsp;                sqlDropTable = buildDropTableSql(targetTablePath);</b>
<i class="no-highlight">5056</i>&nbsp;                try {
<i class="no-highlight">5057</i>&nbsp;                    executeSqlStmt(sqlDropTable, bindValues, account);
<b class="nc"><i class="no-highlight">5058</i>&nbsp;                } catch (Exception ex) {}</b>
<b class="nc"><i class="no-highlight">5059</i>&nbsp;            }</b>
<i class="no-highlight">5060</i>&nbsp;            handleFailures(ERR_BULK_LOAD);
<b class="nc"><i class="no-highlight">5061</i>&nbsp;            if (e instanceof ConfigurationException) {</b>
<i class="no-highlight">5062</i>&nbsp;                throw ((ConfigurationException) e);
<i class="no-highlight">5063</i>&nbsp;            }
<b class="nc"><i class="no-highlight">5064</i>&nbsp;            throw new SnapDataException(e, ERR_LOAD_ACTION_BULK_LOAD)</b>
<i class="no-highlight">5065</i>&nbsp;                    .withReason(e.getMessage())
<i class="no-highlight">5066</i>&nbsp;                    .withResolution(RESOLUTION_BULK_LOAD);
<i class="no-highlight">5067</i>&nbsp;        }
<i class="no-highlight">5068</i>&nbsp;    }
<b class="nc"><i class="no-highlight">5069</i>&nbsp;</b>
<i class="no-highlight">5070</i>&nbsp;    private List&lt;String&gt; getTargetColumnsAfterLoadAction() {
<i class="no-highlight">5071</i>&nbsp;        if (CollectionUtils.isEmpty(targetColumnsAfterLoadAction)) {
<i class="no-highlight">5072</i>&nbsp;            setUpTargetColumnsAfterLoadAction();
<i class="no-highlight">5073</i>&nbsp;        }
<i class="no-highlight">5074</i>&nbsp;        return targetColumnsAfterLoadAction;
<b class="nc"><i class="no-highlight">5075</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5076</i>&nbsp;</b>
<i class="no-highlight">5077</i>&nbsp;    private void setUpTargetColumnsAfterLoadAction() {
<i class="no-highlight">5078</i>&nbsp;        // Retrieve target table column list if the load action
<i class="no-highlight">5079</i>&nbsp;        // is ALTER_TABLE ater the load action is finished.
<i class="no-highlight">5080</i>&nbsp;        if (!validationInProgress &amp;&amp; StringUtils.equals(loadAction, ALTER_TABLE)) {
<b class="nc"><i class="no-highlight">5081</i>&nbsp;            targetColumnsAfterLoadAction =</b>
<i class="no-highlight">5082</i>&nbsp;                    new ArrayList&lt;String&gt;(findTableColumns(targetTableName));
<i class="no-highlight">5083</i>&nbsp;        } else {
<i class="no-highlight">5084</i>&nbsp;            targetColumnsAfterLoadAction = targetColumns;
<i class="no-highlight">5085</i>&nbsp;        }
<b class="nc"><i class="no-highlight">5086</i>&nbsp;    }</b>
<i class="no-highlight">5087</i>&nbsp;
<i class="no-highlight">5088</i>&nbsp;    @Override
<i class="no-highlight">5089</i>&nbsp;    protected void handleFailures(String error) {
<i class="no-highlight">5090</i>&nbsp;        String dbType = getName();
<b class="nc"><i class="no-highlight">5091</i>&nbsp;        switch (dbType) {</b>
<i class="no-highlight">5092</i>&nbsp;            case JdbcOperations.SNOWFLAKE:
<i class="no-highlight">5093</i>&nbsp;                handleSnowflakeDDLRollback(error);
<i class="no-highlight">5094</i>&nbsp;                break;
<i class="no-highlight">5095</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:
<b class="nc"><i class="no-highlight">5096</i>&nbsp;                if (shouldRollbackOrCommit) {</b>
<i class="no-highlight">5097</i>&nbsp;                    rollbackOperation();
<i class="no-highlight">5098</i>&nbsp;                }
<i class="no-highlight">5099</i>&nbsp;                break;
<i class="no-highlight">5100</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:
<b class="nc"><i class="no-highlight">5101</i>&nbsp;                // rollbacks are not supported in Databricks Lakehouse Platform.</b>
<i class="no-highlight">5102</i>&nbsp;                break;
<i class="no-highlight">5103</i>&nbsp;            case JdbcOperations.BIGQUERY:
<i class="no-highlight">5104</i>&nbsp;                // rollbacks are not supported in BigQuery Platform.
<i class="no-highlight">5105</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">5106</i>&nbsp;            default:</b>
<i class="no-highlight">5107</i>&nbsp;                rollbackOperation();
<i class="no-highlight">5108</i>&nbsp;                break;
<i class="no-highlight">5109</i>&nbsp;        }
<i class="no-highlight">5110</i>&nbsp;    }
<b class="nc"><i class="no-highlight">5111</i>&nbsp;</b>
<i class="no-highlight">5112</i>&nbsp;    @Override
<i class="no-highlight">5113</i>&nbsp;    protected void handleSuccess() {
<i class="no-highlight">5114</i>&nbsp;        String dbType = getName();
<i class="no-highlight">5115</i>&nbsp;        switch (dbType) {
<b class="nc"><i class="no-highlight">5116</i>&nbsp;            case JdbcOperations.SNOWFLAKE:</b>
<i class="no-highlight">5117</i>&nbsp;                handleSnowflakeDDLSuccess(ERR_BULK_LOAD_SNOWFLAKE);
<i class="no-highlight">5118</i>&nbsp;                break;
<i class="no-highlight">5119</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:
<i class="no-highlight">5120</i>&nbsp;                if (shouldRollbackOrCommit) {
<b class="nc"><i class="no-highlight">5121</i>&nbsp;                    commitOperation();</b>
<i class="no-highlight">5122</i>&nbsp;                }
<i class="no-highlight">5123</i>&nbsp;                break;
<i class="no-highlight">5124</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:
<i class="no-highlight">5125</i>&nbsp;            case JdbcOperations.BIGQUERY:
<b class="nc"><i class="no-highlight">5126</i>&nbsp;                // commits are not supported in DLP and BigQuery platforms</b>
<i class="no-highlight">5127</i>&nbsp;                break;
<i class="no-highlight">5128</i>&nbsp;            default:
<i class="no-highlight">5129</i>&nbsp;                commitOperation();
<i class="no-highlight">5130</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">5131</i>&nbsp;        }</b>
<i class="no-highlight">5132</i>&nbsp;    }
<i class="no-highlight">5133</i>&nbsp;
<i class="no-highlight">5134</i>&nbsp;    private void modifyCopyOption(final String option, final String optionName,
<i class="no-highlight">5135</i>&nbsp;                                  boolean rebuildCopyIntoCommand) {
<b class="nc"><i class="no-highlight">5136</i>&nbsp;        // option is &quot;name = value&quot; i.e. &quot;FORCE = TRUE&quot;</b>
<i class="no-highlight">5137</i>&nbsp;        // optionName is &quot;name&quot; i.e. &quot;FORCE&quot;
<i class="no-highlight">5138</i>&nbsp;        String existingForceOption = null;
<i class="no-highlight">5139</i>&nbsp;        for (String copyOption : copyOptions) {
<i class="no-highlight">5140</i>&nbsp;            if (StringUtils.startsWith(copyOption.trim(), optionName)) {
<b class="nc"><i class="no-highlight">5141</i>&nbsp;                existingForceOption = copyOption;</b>
<i class="no-highlight">5142</i>&nbsp;            }
<i class="no-highlight">5143</i>&nbsp;        }
<i class="no-highlight">5144</i>&nbsp;        if (existingForceOption != null) {
<i class="no-highlight">5145</i>&nbsp;            copyOptions.remove(existingForceOption);
<b class="nc"><i class="no-highlight">5146</i>&nbsp;        }</b>
<i class="no-highlight">5147</i>&nbsp;        copyOptions.add(option);
<i class="no-highlight">5148</i>&nbsp;        if (rebuildCopyIntoCommand) {
<i class="no-highlight">5149</i>&nbsp;            // Rebuild COPY INTO command only when it is safe
<i class="no-highlight">5150</i>&nbsp;            queryBuilder.setLength(0);
<b class="nc"><i class="no-highlight">5151</i>&nbsp;            buildQueryBuilder();</b>
<i class="no-highlight">5152</i>&nbsp;        }
<i class="no-highlight">5153</i>&nbsp;    }
<i class="no-highlight">5154</i>&nbsp;
<i class="no-highlight">5155</i>&nbsp;    private String buildCreateTableSql() {
<b class="nc"><i class="no-highlight">5156</i>&nbsp;        return buildCreateTableSql(targetTablePath, targetColumns, targetDataTypes);</b>
<i class="no-highlight">5157</i>&nbsp;    }
<i class="no-highlight">5158</i>&nbsp;
<i class="no-highlight">5159</i>&nbsp;    private String buildCreateTableSql(String tablePath, List&lt;String&gt; columns,
<b class="nc"><i class="no-highlight">5160</i>&nbsp;                                       List&lt;String&gt; dataTypes) {</b>
<b class="nc"><i class="no-highlight">5161</i>&nbsp;        String sqlCreateTable = EMPTY_STRING;</b>
<b class="nc"><i class="no-highlight">5162</i>&nbsp;        String dbType = getName();</b>
<b class="nc"><i class="no-highlight">5163</i>&nbsp;        switch (dbType) {</b>
<b class="nc"><i class="no-highlight">5164</i>&nbsp;            case JdbcOperations.SNOWFLAKE:</b>
<b class="nc"><i class="no-highlight">5165</i>&nbsp;            case JdbcOperations.REDSHIFT:</b>
<b class="nc"><i class="no-highlight">5166</i>&nbsp;                sqlCreateTable = buildRedshiftSnowflakeCreateTableSql(tablePath,</b>
<i class="no-highlight">5167</i>&nbsp;                        buildColumnWithDataTypeCreateTable(columns, dataTypes),
<b class="nc"><i class="no-highlight">5168</i>&nbsp;                        tableOptions);</b>
<b class="nc"><i class="no-highlight">5169</i>&nbsp;                break;</b>
<i class="no-highlight">5170</i>&nbsp;            case JdbcOperations.AZURE_SYNAPSE:
<i class="no-highlight">5171</i>&nbsp;                sqlCreateTable = buildAzureSynapseCreateTableSql(tablePath,
<i class="no-highlight">5172</i>&nbsp;                        hashDistributionColumnName,
<i class="no-highlight">5173</i>&nbsp;                        buildColumnWithDataTypeCreateTable(columns, dataTypes),
<b class="nc"><i class="no-highlight">5174</i>&nbsp;                        tableOptions);</b>
<b class="nc"><i class="no-highlight">5175</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">5176</i>&nbsp;            case JdbcOperations.DATABRICKS_LAKEHOUSE_PLATFORM:</b>
<b class="nc"><i class="no-highlight">5177</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">5178</i>&nbsp;            default:</b>
<i class="no-highlight">5179</i>&nbsp;                break;
<i class="no-highlight">5180</i>&nbsp;        }
<i class="no-highlight">5181</i>&nbsp;        return sqlCreateTable;
<i class="no-highlight">5182</i>&nbsp;    }
<i class="no-highlight">5183</i>&nbsp;
<i class="no-highlight">5184</i>&nbsp;    @Override
<i class="no-highlight">5185</i>&nbsp;    protected void processDocument(final Document document, final String inputViewName) {
<b class="nc"><i class="no-highlight">5186</i>&nbsp;        String sqlSelect = String.format(SELECT_WITH_TABLE_PATH_SQL, targetTablePath);</b>
<b class="nc"><i class="no-highlight">5187</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5188</i>&nbsp;        Map&lt;String, Object&gt; output = getOutputViewMap(document, sqlSelect,</b>
<b class="nc"><i class="no-highlight">5189</i>&nbsp;                Collections.singletonList(ELT_LOAD_TITLE),</b>
<b class="nc"><i class="no-highlight">5190</i>&nbsp;                createNewPushdownContext(targetTablePath));</b>
<b class="nc"><i class="no-highlight">5191</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5192</i>&nbsp;        if (isSnowflakeDb()) {</b>
<b class="nc"><i class="no-highlight">5193</i>&nbsp;            output.put(STATUS, results);</b>
<i class="no-highlight">5194</i>&nbsp;        }
<b class="nc"><i class="no-highlight">5195</i>&nbsp;</b>
<i class="no-highlight">5196</i>&nbsp;        statistic.setSnapStatus(StatisticHolder.SnapStatus.DONE);
<i class="no-highlight">5197</i>&nbsp;
<b class="nc"><i class="no-highlight">5198</i>&nbsp;        addValidationQueryToOutput(output);</b>
<i class="no-highlight">5199</i>&nbsp;        if (handlePreview(documentUtility.newDocument(output), document,
<b class="nc"><i class="no-highlight">5200</i>&nbsp;                account, validationInProgress, previewRowCount, executionMode,</b>
<b class="nc"><i class="no-highlight">5201</i>&nbsp;                executeSqlInPreview)) {</b>
<i class="no-highlight">5202</i>&nbsp;            return;
<b class="nc"><i class="no-highlight">5203</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">5204</i>&nbsp;</b>
<i class="no-highlight">5205</i>&nbsp;        statusReporter.beginUnknown();
<b class="nc"><i class="no-highlight">5206</i>&nbsp;        output.put(STATISTIC_KEY, toMap(statistic));</b>
<i class="no-highlight">5207</i>&nbsp;        outputViews.write(documentUtility.newDocument(output), document);
<b class="nc"><i class="no-highlight">5208</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5209</i>&nbsp;</b>
<i class="no-highlight">5210</i>&nbsp;    private void addValidationQueryToOutput(Map&lt;String, Object&gt; output) {
<i class="no-highlight">5211</i>&nbsp;        if (validationInProgress) {
<i class="no-highlight">5212</i>&nbsp;            Map&lt;String, String&gt; queries = new LinkedHashMap&lt;&gt;();
<i class="no-highlight">5213</i>&nbsp;            if (StringUtils.isNotBlank(sqlCreateTable)) {
<b class="nc"><i class="no-highlight">5214</i>&nbsp;                queries.put(&quot;sqlCreateTable&quot;, sqlCreateTable);</b>
<b class="nc"><i class="no-highlight">5215</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5216</i>&nbsp;            if (!queryBuilder.toString().isEmpty()) {</b>
<b class="nc"><i class="no-highlight">5217</i>&nbsp;                queries.put(&quot;sqlLoadQuery&quot;, getWriterQueryWithObfuscatedCredentials());</b>
<b class="nc"><i class="no-highlight">5218</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5219</i>&nbsp;            output.put(TARGET_TABLE_WRITER_SQL, queries);</b>
<b class="nc"><i class="no-highlight">5220</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">5221</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5222</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5223</i>&nbsp;    private String getWriterQueryWithObfuscatedCredentials() {</b>
<b class="nc"><i class="no-highlight">5224</i>&nbsp;        String writerQuery = queryBuilder.toString();</b>
<i class="no-highlight">5225</i>&nbsp;        if (isAzureSynapseDb() &amp;&amp; StringUtils.contains(writerQuery, azureSynapseCredential)) {
<b class="nc"><i class="no-highlight">5226</i>&nbsp;            writerQuery = StringUtils.replace(writerQuery, azureSynapseCredential,</b>
<b class="nc"><i class="no-highlight">5227</i>&nbsp;                    AZURE_SYNAPSE_CREDENTIAL_REPLACEMENT);</b>
<i class="no-highlight">5228</i>&nbsp;        } else if (isRedshiftDb() &amp;&amp; StringUtils.contains(writerQuery, redshiftCredentials)) {
<b class="nc"><i class="no-highlight">5229</i>&nbsp;            writerQuery = getObfuscatedRedShift(writerQuery);</b>
<b class="nc"><i class="no-highlight">5230</i>&nbsp;        } else if (isSnowflakeDb() &amp;&amp; StringUtils.contains(writerQuery, snowFlakeCredentials)) {</b>
<i class="no-highlight">5231</i>&nbsp;            writerQuery = StringUtils.replace(writerQuery, snowFlakeCredentials,
<b class="nc"><i class="no-highlight">5232</i>&nbsp;                    SNOWFLAKE_CREDENTIALS_REPLACEMENT);</b>
<i class="no-highlight">5233</i>&nbsp;        }
<b class="nc"><i class="no-highlight">5234</i>&nbsp;        return writerQuery;</b>
<b class="nc"><i class="no-highlight">5235</i>&nbsp;    }</b>
<i class="no-highlight">5236</i>&nbsp;
<i class="no-highlight">5237</i>&nbsp;    private String getObfuscatedRedShift(String writerQuery) {
<i class="no-highlight">5238</i>&nbsp;        String redshiftCredentialsObfuscated = CREDENTIALS_HIDDEN;
<i class="no-highlight">5239</i>&nbsp;        switch (eltDatabaseAccount.getRedshiftAuthType()) {
<i class="no-highlight">5240</i>&nbsp;            case SOURCE_LOCATION_SESSION_CREDENTIALS: {
<i class="no-highlight">5241</i>&nbsp;                redshiftCredentialsObfuscated =
<b class="nc"><i class="no-highlight">5242</i>&nbsp;                 String.format(S3_SESSION_CREDENTIALS_FORMAT_REDSHIFT, CREDENTIALS_HIDDEN,</b>
<b class="nc"><i class="no-highlight">5243</i>&nbsp;                         CREDENTIALS_HIDDEN, CREDENTIALS_HIDDEN);</b>
<i class="no-highlight">5244</i>&nbsp;                break;
<i class="no-highlight">5245</i>&nbsp;            }
<i class="no-highlight">5246</i>&nbsp;            case SOURCE_LOCATION_CREDENTIALS: {
<i class="no-highlight">5247</i>&nbsp;                redshiftCredentialsObfuscated =
<b class="nc"><i class="no-highlight">5248</i>&nbsp;                 String.format(S3_CREDENTIALS_FORMAT_REDSHIFT, CREDENTIALS_HIDDEN,</b>
<b class="nc"><i class="no-highlight">5249</i>&nbsp;                  CREDENTIALS_HIDDEN);</b>
<i class="no-highlight">5250</i>&nbsp;                break;
<i class="no-highlight">5251</i>&nbsp;            }
<i class="no-highlight">5252</i>&nbsp;            case IAM_ROLE_CREDENTIALS: {
<i class="no-highlight">5253</i>&nbsp;                redshiftCredentialsObfuscated = String.format(IAM_ROLE, CREDENTIALS_HIDDEN);
<b class="nc"><i class="no-highlight">5254</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">5255</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5256</i>&nbsp;        }</b>
<i class="no-highlight">5257</i>&nbsp;
<i class="no-highlight">5258</i>&nbsp;        return StringUtils.replace(writerQuery, redshiftCredentials, redshiftCredentialsObfuscated);
<b class="nc"><i class="no-highlight">5259</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5260</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5261</i>&nbsp;    @Override</b>
<b class="nc"><i class="no-highlight">5262</i>&nbsp;    public void configureForSuggest(final PropertyValues propertyValues,</b>
<i class="no-highlight">5263</i>&nbsp;                                    final BigInteger maxSuggestValue) {
<i class="no-highlight">5264</i>&nbsp;        configurePreviewProps(maxSuggestValue);
<b class="nc"><i class="no-highlight">5265</i>&nbsp;        super.configure(propertyValues);</b>
<b class="nc"><i class="no-highlight">5266</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5267</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5268</i>&nbsp;    @Override</b>
<b class="nc"><i class="no-highlight">5269</i>&nbsp;    public void executeForSuggest() {</b>
<i class="no-highlight">5270</i>&nbsp;        execute();
<i class="no-highlight">5271</i>&nbsp;    }
<i class="no-highlight">5272</i>&nbsp;
<i class="no-highlight">5273</i>&nbsp;    @VisibleForTesting
<i class="no-highlight">5274</i>&nbsp;    protected String getFilePattern() {
<i class="no-highlight">5275</i>&nbsp;        return filePattern;
<b class="nc"><i class="no-highlight">5276</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5277</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5278</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">5279</i>&nbsp;    protected String getQuery() {</b>
<i class="no-highlight">5280</i>&nbsp;        return sqlBulkLoad;
<b class="nc"><i class="no-highlight">5281</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5282</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5283</i>&nbsp;    @VisibleForTesting</b>
<i class="no-highlight">5284</i>&nbsp;    protected String getInsertSelectQuery() {
<i class="no-highlight">5285</i>&nbsp;        return insertSelectSql;
<i class="no-highlight">5286</i>&nbsp;    }
<i class="no-highlight">5287</i>&nbsp;
<b class="nc"><i class="no-highlight">5288</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">5289</i>&nbsp;    protected String getQueryPerFile() {</b>
<b class="nc"><i class="no-highlight">5290</i>&nbsp;        return sqlLoadPerFile;</b>
<b class="nc"><i class="no-highlight">5291</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5292</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5293</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">5294</i>&nbsp;    protected String getDropTableSql() {</b>
<i class="no-highlight">5295</i>&nbsp;        return sqlDropTable;
<i class="no-highlight">5296</i>&nbsp;    }
<i class="no-highlight">5297</i>&nbsp;
<b class="nc"><i class="no-highlight">5298</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">5299</i>&nbsp;    protected String getCreateTableSql() {</b>
<i class="no-highlight">5300</i>&nbsp;        return sqlCreateTable;
<i class="no-highlight">5301</i>&nbsp;    }
<i class="no-highlight">5302</i>&nbsp;
<b class="nc"><i class="no-highlight">5303</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">5304</i>&nbsp;    protected String getCreateStageSql() {</b>
<i class="no-highlight">5305</i>&nbsp;        return sqlCreateStage;
<b class="nc"><i class="no-highlight">5306</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5307</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5308</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">5309</i>&nbsp;    protected String getAlterTableSql() {</b>
<b class="nc"><i class="no-highlight">5310</i>&nbsp;        return sqlAlterTable;</b>
<i class="no-highlight">5311</i>&nbsp;    }
<b class="nc"><i class="no-highlight">5312</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5313</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">5314</i>&nbsp;    protected String getDeleteTableSql() {</b>
<b class="nc"><i class="no-highlight">5315</i>&nbsp;        return sqlDeleteTable;</b>
<b class="nc"><i class="no-highlight">5316</i>&nbsp;    }</b>
<i class="no-highlight">5317</i>&nbsp;
<i class="no-highlight">5318</i>&nbsp;    @VisibleForTesting
<i class="no-highlight">5319</i>&nbsp;    protected List&lt;String&gt; getFileList() {
<i class="no-highlight">5320</i>&nbsp;        return files;
<i class="no-highlight">5321</i>&nbsp;    }
<i class="no-highlight">5322</i>&nbsp;
<b class="nc"><i class="no-highlight">5323</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">5324</i>&nbsp;    protected String getSqlAlterTable() {</b>
<b class="nc"><i class="no-highlight">5325</i>&nbsp;        return sqlAlterTable;</b>
<b class="nc"><i class="no-highlight">5326</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5327</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5328</i>&nbsp;    @VisibleForTesting</b>
<i class="no-highlight">5329</i>&nbsp;    protected String getSqlRenameTable() {
<i class="no-highlight">5330</i>&nbsp;        return sqlRenameTable;
<i class="no-highlight">5331</i>&nbsp;    }
<i class="no-highlight">5332</i>&nbsp;
<i class="no-highlight">5333</i>&nbsp;    @VisibleForTesting
<b class="nc"><i class="no-highlight">5334</i>&nbsp;    protected String getSqlInsertIntoSelectAs() {</b>
<i class="no-highlight">5335</i>&nbsp;        return sqlInsertIntoSelectAs;
<i class="no-highlight">5336</i>&nbsp;    }
<i class="no-highlight">5337</i>&nbsp;
<i class="no-highlight">5338</i>&nbsp;    @VisibleForTesting
<i class="no-highlight">5339</i>&nbsp;    protected String getSqlAlterTableDropColumns() {
<i class="no-highlight">5340</i>&nbsp;        return sqlAlterTableDropColumns;
<i class="no-highlight">5341</i>&nbsp;    }
<i class="no-highlight">5342</i>&nbsp;
<b class="nc"><i class="no-highlight">5343</i>&nbsp;    @VisibleForTesting</b>
<i class="no-highlight">5344</i>&nbsp;    String getCreateBackUpSql() {
<b class="nc"><i class="no-highlight">5345</i>&nbsp;        return createBackUpSql;</b>
<b class="nc"><i class="no-highlight">5346</i>&nbsp;    }</b>
<i class="no-highlight">5347</i>&nbsp;
<i class="no-highlight">5348</i>&nbsp;    private void createResultForOutputView(final ResultSet rs) throws SQLException {
<b class="nc"><i class="no-highlight">5349</i>&nbsp;        if (rs != null) {</b>
<b class="nc"><i class="no-highlight">5350</i>&nbsp;            ResultSetMetaData metaData = rs.getMetaData();</b>
<b class="nc"><i class="no-highlight">5351</i>&nbsp;            int columnCount = metaData.getColumnCount();</b>
<b class="nc"><i class="no-highlight">5352</i>&nbsp;            while (rs.next()) {</b>
<b class="nc"><i class="no-highlight">5353</i>&nbsp;                Map&lt;String, Object&gt; resultMap = Maps.newLinkedHashMap();</b>
<b class="nc"><i class="no-highlight">5354</i>&nbsp;                for (int i = 1; i &lt;= columnCount; i++) {</b>
<i class="no-highlight">5355</i>&nbsp;                    resultMap.put(metaData.getColumnName(i), rs.getString(i));
<b class="nc"><i class="no-highlight">5356</i>&nbsp;                }</b>
<i class="no-highlight">5357</i>&nbsp;                results.add(resultMap);
<b class="nc"><i class="no-highlight">5358</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5359</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">5360</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5361</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5362</i>&nbsp;    private void validateCopyFromFilesConfig() {</b>
<i class="no-highlight">5363</i>&nbsp;        if (isAzureSynapseDb()) {
<i class="no-highlight">5364</i>&nbsp;            if (StringUtils.isBlank(filePattern) &amp;&amp; CollectionUtils.isEmpty(filePaths)) {
<b class="nc"><i class="no-highlight">5365</i>&nbsp;                throw new ConfigurationException(ERR_NO_EXTERNAL_FILES_FOR_COPY)</b>
<b class="nc"><i class="no-highlight">5366</i>&nbsp;                        .withReason(REASON_NO_EXTERNAL_FILES_FOR_COPY)</b>
<i class="no-highlight">5367</i>&nbsp;                        .withResolution(RES_NO_EXTERNAL_FILES_FOR_COPY);
<b class="nc"><i class="no-highlight">5368</i>&nbsp;            }</b>
<i class="no-highlight">5369</i>&nbsp;        }
<i class="no-highlight">5370</i>&nbsp;    }
<i class="no-highlight">5371</i>&nbsp;
<b class="nc"><i class="no-highlight">5372</i>&nbsp;    //********** AZURE SYNAPSE METHODS *************//</b>
<b class="nc"><i class="no-highlight">5373</i>&nbsp;</b>
<i class="no-highlight">5374</i>&nbsp;    private void retrieveAzureSynapseAccountInfo() {
<i class="no-highlight">5375</i>&nbsp;        azureSynapseExternalStorage = eltDatabaseAccount.getExternalStorageAzureSynapse();
<i class="no-highlight">5376</i>&nbsp;        azureSynapseAuthType = eltDatabaseAccount.getAzureSynapseAuthType();
<i class="no-highlight">5377</i>&nbsp;        azureSynapseEndpoint = eltDatabaseAccount.getAzureSynapseStorageEndpoint();
<b class="nc"><i class="no-highlight">5378</i>&nbsp;        azureAccountName = eltDatabaseAccount.getAzureAccountName();</b>
<i class="no-highlight">5379</i>&nbsp;        azureContainer = eltDatabaseAccount.getAzureContainer();
<b class="nc"><i class="no-highlight">5380</i>&nbsp;        azureFolder = eltDatabaseAccount.getAzureFolder();</b>
<i class="no-highlight">5381</i>&nbsp;        azureIdentity = eltDatabaseAccount.getAzureSynapseIdentity();
<b class="nc"><i class="no-highlight">5382</i>&nbsp;        azureSecret = eltDatabaseAccount.getAzureSynapseSecret();</b>
<i class="no-highlight">5383</i>&nbsp;
<b class="nc"><i class="no-highlight">5384</i>&nbsp;        validateAzureSynapseAccountSettingsForLoad(azureSynapseEndpoint, azureAccountName,</b>
<i class="no-highlight">5385</i>&nbsp;                azureContainer, StringUtils.EMPTY, false);
<i class="no-highlight">5386</i>&nbsp;
<i class="no-highlight">5387</i>&nbsp;        switch (azureSynapseAuthType) {
<b class="nc"><i class="no-highlight">5388</i>&nbsp;            case AZURE_SYNAPSE_AAD_USER_AUTH:</b>
<b class="nc"><i class="no-highlight">5389</i>&nbsp;                azureSynapseCredential = StringUtils.EMPTY;</b>
<b class="nc"><i class="no-highlight">5390</i>&nbsp;                break;</b>
<i class="no-highlight">5391</i>&nbsp;            case AZURE_SYNAPSE_MANAGED_IDENTITY_AUTH:
<b class="nc"><i class="no-highlight">5392</i>&nbsp;                azureSynapseCredential =</b>
<b class="nc"><i class="no-highlight">5393</i>&nbsp;                        String.format(AZURE_SYNAPSE_ONLY_IDENTITY_CREDENTIAL_FORMAT,</b>
<i class="no-highlight">5394</i>&nbsp;                                azureIdentity);
<b class="nc"><i class="no-highlight">5395</i>&nbsp;                break;</b>
<i class="no-highlight">5396</i>&nbsp;            default:
<i class="no-highlight">5397</i>&nbsp;                azureSynapseCredential =
<i class="no-highlight">5398</i>&nbsp;                        String.format(AZURE_SYNAPSE_CREDENTIAL_FORMAT, azureIdentity, azureSecret);
<i class="no-highlight">5399</i>&nbsp;        }
<i class="no-highlight">5400</i>&nbsp;    }
<b class="nc"><i class="no-highlight">5401</i>&nbsp;</b>
<i class="no-highlight">5402</i>&nbsp;    private void retrieveErrorFileAzureSynapseAccountInfo() {
<i class="no-highlight">5403</i>&nbsp;        isErrFileEnabled = eltDatabaseAccount.isErrorFileEnabled();
<i class="no-highlight">5404</i>&nbsp;        if (isErrFileEnabled) {
<b class="nc"><i class="no-highlight">5405</i>&nbsp;            errFileAzureAccountName = eltDatabaseAccount.getErrFileAzureAccountName();</b>
<b class="nc"><i class="no-highlight">5406</i>&nbsp;            errFileAzureEndpoint = eltDatabaseAccount.getAzureSynapseStorageEndpoint();</b>
<b class="nc"><i class="no-highlight">5407</i>&nbsp;            errFileAzureContainer = eltDatabaseAccount.getErrFileAzureContainer();</b>
<b class="nc"><i class="no-highlight">5408</i>&nbsp;            errFileAzureFolder = eltDatabaseAccount.getErrFileAzureFolder();</b>
<i class="no-highlight">5409</i>&nbsp;            errAzureFilePath = eltDatabaseAccount.getErrFileAzureFilePath();
<i class="no-highlight">5410</i>&nbsp;            errAzureIdentity = eltDatabaseAccount.getErrFileAzureIdentity();
<b class="nc"><i class="no-highlight">5411</i>&nbsp;            errAzureSecret = eltDatabaseAccount.getErrFileAzureSecret();</b>
<b class="nc"><i class="no-highlight">5412</i>&nbsp;            errFileAzureAuthType = eltDatabaseAccount.getErrFileAzureAuthType();</b>
<i class="no-highlight">5413</i>&nbsp;            switch (errFileAzureAuthType) {
<i class="no-highlight">5414</i>&nbsp;                case AZURE_SYNAPSE_AAD_USER_AUTH:
<b class="nc"><i class="no-highlight">5415</i>&nbsp;                    errAzureCredential = StringUtils.EMPTY;</b>
<i class="no-highlight">5416</i>&nbsp;                    break;
<i class="no-highlight">5417</i>&nbsp;                case AZURE_SYNAPSE_MANAGED_IDENTITY_AUTH:
<i class="no-highlight">5418</i>&nbsp;                    errAzureCredential =
<i class="no-highlight">5419</i>&nbsp;                            String.format(AZURE_SYNAPSE_ERROR_ONLY_IDENTITY_CREDENTIAL_FORMAT,
<i class="no-highlight">5420</i>&nbsp;                                    azureIdentity);
<b class="nc"><i class="no-highlight">5421</i>&nbsp;                    break;</b>
<b class="nc"><i class="no-highlight">5422</i>&nbsp;                default:</b>
<b class="nc"><i class="no-highlight">5423</i>&nbsp;                    errAzureCredential =</b>
<i class="no-highlight">5424</i>&nbsp;                            String.format(AZURE_SYNAPSE_ERROR_CREDENTIAL_FORMAT,
<i class="no-highlight">5425</i>&nbsp;                                    azureIdentity, azureSecret);
<i class="no-highlight">5426</i>&nbsp;            }
<i class="no-highlight">5427</i>&nbsp;        }
<b class="nc"><i class="no-highlight">5428</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5429</i>&nbsp;</b>
<i class="no-highlight">5430</i>&nbsp;    private void addFileTypeAzureSynapse(List&lt;String&gt; azureSynapseOptionsList) {
<b class="nc"><i class="no-highlight">5431</i>&nbsp;        if (StringUtils.isNotBlank(fileFormatType)) {</b>
<b class="nc"><i class="no-highlight">5432</i>&nbsp;            azureSynapseOptionsList.add(String.format(AZURE_SYNAPSE_FILE_TYPE_FMT, fileFormatType));</b>
<b class="nc"><i class="no-highlight">5433</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">5434</i>&nbsp;    }</b>
<i class="no-highlight">5435</i>&nbsp;
<b class="nc"><i class="no-highlight">5436</i>&nbsp;    private void addCredentialsAzureSynapse(List&lt;String&gt; azureSynapseOptionsList) {</b>
<b class="nc"><i class="no-highlight">5437</i>&nbsp;        if (StringUtils.isNotBlank(azureSynapseCredential)) {</b>
<b class="nc"><i class="no-highlight">5438</i>&nbsp;            azureSynapseOptionsList.add(azureSynapseCredential);</b>
<i class="no-highlight">5439</i>&nbsp;        }
<b class="nc"><i class="no-highlight">5440</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5441</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5442</i>&nbsp;    private void addErrorFileAndCredentialsAzureSynapse(List&lt;String&gt; azureSynapseOptionsList) {</b>
<b class="nc"><i class="no-highlight">5443</i>&nbsp;        if (isErrFileEnabled) {</b>
<i class="no-highlight">5444</i>&nbsp;            if (!StringUtils.equalsIgnoreCase(fileFormatType, CSV)) {
<b class="nc"><i class="no-highlight">5445</i>&nbsp;                LOGGER.info(&quot;Only file type CSV allows errorfile configuration. Ignoring ...&quot;);</b>
<b class="nc"><i class="no-highlight">5446</i>&nbsp;                return;</b>
<b class="nc"><i class="no-highlight">5447</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5448</i>&nbsp;            Matcher errFileFormat = AZURE_SYNAPSE_EXTFILE_PATTERN.matcher(errAzureFilePath);</b>
<i class="no-highlight">5449</i>&nbsp;            if (isErrFileNewConfigEnabled || errFileFormat.matches()) {
<i class="no-highlight">5450</i>&nbsp;                List&lt;String&gt; errorFileList = Lists.newArrayList(errAzureFilePath);
<b class="nc"><i class="no-highlight">5451</i>&nbsp;                formatFilePathsForAzureSynapse(errorFileList, errFileAzureAccountName,</b>
<b class="nc"><i class="no-highlight">5452</i>&nbsp;                        errFileAzureEndpoint, errFileAzureContainer,</b>
<i class="no-highlight">5453</i>&nbsp;                        errFileAzureFolder);
<b class="nc"><i class="no-highlight">5454</i>&nbsp;                azureSynapseOptionsList.add(String.format(AZURE_SYNAPSE_ERRORFILE_PATH,</b>
<b class="nc"><i class="no-highlight">5455</i>&nbsp;                        errorFileList.get(0)));</b>
<b class="nc"><i class="no-highlight">5456</i>&nbsp;                azureSynapseOptionsList.add(errAzureCredential);</b>
<i class="no-highlight">5457</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">5458</i>&nbsp;                azureSynapseOptionsList.add(String.format(AZURE_SYNAPSE_ERRORFILE_PATH,</b>
<i class="no-highlight">5459</i>&nbsp;                        errAzureFilePath));
<i class="no-highlight">5460</i>&nbsp;            }
<i class="no-highlight">5461</i>&nbsp;        }
<i class="no-highlight">5462</i>&nbsp;    }
<b class="nc"><i class="no-highlight">5463</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5464</i>&nbsp;    private void addFileFormatOptionsAzureSynapse(List&lt;String&gt; azureSynapseOptionsList) {</b>
<b class="nc"><i class="no-highlight">5465</i>&nbsp;        if (!FILE_FORMAT_TYPE_AZURE_SYNAPSE.contains(fileFormatType)) {</b>
<b class="nc"><i class="no-highlight">5466</i>&nbsp;            throw new ConfigurationException(ERR_INVALID_FILE_FORMAT_TYPE)</b>
<b class="nc"><i class="no-highlight">5467</i>&nbsp;                    .withReason(REASON_INVALID_FILE_FORMAT_TYPE)</b>
<b class="nc"><i class="no-highlight">5468</i>&nbsp;                    .withResolution(RESOLUTION_INVALID_FILE_FORMAT_TYPE);</b>
<b class="nc"><i class="no-highlight">5469</i>&nbsp;        }</b>
<i class="no-highlight">5470</i>&nbsp;        if (CollectionUtils.isNotEmpty(fileFormatOptions)) {
<i class="no-highlight">5471</i>&nbsp;            String formatOpts = StringUtils.join(fileFormatOptions, COMMA);
<i class="no-highlight">5472</i>&nbsp;            azureSynapseOptionsList.add(formatOpts);
<b class="nc"><i class="no-highlight">5473</i>&nbsp;        }</b>
<i class="no-highlight">5474</i>&nbsp;    }
<i class="no-highlight">5475</i>&nbsp;
<i class="no-highlight">5476</i>&nbsp;    private void appendFormatOptionsAzureSynapse() {
<i class="no-highlight">5477</i>&nbsp;        List&lt;String&gt; azureSynapseLoadOptionsList = Lists.newArrayList();
<i class="no-highlight">5478</i>&nbsp;        addFileTypeAzureSynapse(azureSynapseLoadOptionsList);
<i class="no-highlight">5479</i>&nbsp;        addCredentialsAzureSynapse(azureSynapseLoadOptionsList);
<i class="no-highlight">5480</i>&nbsp;        addErrorFileAndCredentialsAzureSynapse(azureSynapseLoadOptionsList);
<b class="nc"><i class="no-highlight">5481</i>&nbsp;        addFileFormatOptionsAzureSynapse(azureSynapseLoadOptionsList);</b>
<b class="nc"><i class="no-highlight">5482</i>&nbsp;        String formatOptionsDelimited = StringUtils.join(azureSynapseLoadOptionsList, COMMA);</b>
<i class="no-highlight">5483</i>&nbsp;        queryBuilder.append(String.format(WITH_CLAUSE_FMT, formatOptionsDelimited));
<b class="nc"><i class="no-highlight">5484</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5485</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5486</i>&nbsp;    private boolean isTargetColumnsNotEmpty(List&lt;String&gt; targetColumns) {</b>
<b class="nc"><i class="no-highlight">5487</i>&nbsp;        return CollectionUtils.isNotEmpty(targetColumns)</b>
<b class="nc"><i class="no-highlight">5488</i>&nbsp;                &amp;&amp; !StringUtils.equals(OVERWRITE_TABLE, loadAction);</b>
<i class="no-highlight">5489</i>&nbsp;    }
<b class="nc"><i class="no-highlight">5490</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5491</i>&nbsp;    private void appendTargetTableNameAndColumnsAzureSynapse() {</b>
<b class="nc"><i class="no-highlight">5492</i>&nbsp;        boolean columnMappingMapNotEmpty = MapUtils.isNotEmpty(this.columnMappingMap);</b>
<i class="no-highlight">5493</i>&nbsp;        boolean targetColumnsNotEmpty = isTargetColumnsNotEmpty(targetColumns);
<b class="nc"><i class="no-highlight">5494</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5495</i>&nbsp;        if (targetColumnsNotEmpty) {</b>
<i class="no-highlight">5496</i>&nbsp;            if (columnMappingMapNotEmpty &amp;&amp;
<i class="no-highlight">5497</i>&nbsp;                    StringUtils.equals(loadAction, DROP_CREATE_TABLE)) {
<i class="no-highlight">5498</i>&nbsp;                validateColumnMappingMap();
<b class="nc"><i class="no-highlight">5499</i>&nbsp;                appendStageFilePathWithNonEmptyColumnsWithMapAzureSynapse();</b>
<b class="nc"><i class="no-highlight">5500</i>&nbsp;                return;</b>
<b class="nc"><i class="no-highlight">5501</i>&nbsp;            } else if (StringUtils.equals(loadAction, DROP_CREATE_TABLE) ||</b>
<i class="no-highlight">5502</i>&nbsp;                    StringUtils.equals(loadAction, APPEND_ROWS_TABLE) ||
<i class="no-highlight">5503</i>&nbsp;                    StringUtils.equals(loadAction, OVERWRITE_TABLE)) {
<i class="no-highlight">5504</i>&nbsp;                String headerColumns = StringUtils.join(targetColumns, COMMA);
<i class="no-highlight">5505</i>&nbsp;                queryBuilder.append(String.format(
<i class="no-highlight">5506</i>&nbsp;                        COPY_COLUMNS_FROM_EXTERNAL_STORAGE_AZURE_SYNAPSE,
<i class="no-highlight">5507</i>&nbsp;                        targetTablePath, headerColumns));
<b class="nc"><i class="no-highlight">5508</i>&nbsp;                return;</b>
<b class="nc"><i class="no-highlight">5509</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5510</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">5511</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5512</i>&nbsp;        if (columnMappingMapNotEmpty &amp;&amp;</b>
<b class="nc"><i class="no-highlight">5513</i>&nbsp;                (StringUtils.equals(loadAction, OVERWRITE_TABLE) ||</b>
<b class="nc"><i class="no-highlight">5514</i>&nbsp;                        StringUtils.equals(loadAction, APPEND_ROWS_TABLE))) {</b>
<i class="no-highlight">5515</i>&nbsp;            String headerColumns = StringUtils.join(
<b class="nc"><i class="no-highlight">5516</i>&nbsp;                    this.columnMappingMap.keySet(), COMMA);</b>
<b class="nc"><i class="no-highlight">5517</i>&nbsp;            queryBuilder.append(String.format(</b>
<b class="nc"><i class="no-highlight">5518</i>&nbsp;                    COPY_COLUMNS_FROM_EXTERNAL_STORAGE_AZURE_SYNAPSE,</b>
<b class="nc"><i class="no-highlight">5519</i>&nbsp;                    targetTablePath, headerColumns));</b>
<b class="nc"><i class="no-highlight">5520</i>&nbsp;            return;</b>
<b class="nc"><i class="no-highlight">5521</i>&nbsp;        }</b>
<i class="no-highlight">5522</i>&nbsp;
<b class="nc"><i class="no-highlight">5523</i>&nbsp;        queryBuilder.append(String.format(COPY_FROM_EXTERNAL_STORAGE_AZURE_SYNAPSE,</b>
<b class="nc"><i class="no-highlight">5524</i>&nbsp;                targetTablePath));</b>
<b class="nc"><i class="no-highlight">5525</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5526</i>&nbsp;</b>
<i class="no-highlight">5527</i>&nbsp;    /**
<b class="nc"><i class="no-highlight">5528</i>&nbsp;     * Append target column list from the &quot;columnMappingMap&quot; for</b>
<b class="nc"><i class="no-highlight">5529</i>&nbsp;     * DROP_CREATE load action.</b>
<b class="nc"><i class="no-highlight">5530</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">5531</i>&nbsp;    private void appendStageFilePathWithNonEmptyColumnsWithMapAzureSynapse() {</b>
<i class="no-highlight">5532</i>&nbsp;        trimListEntries(targetColumns);
<i class="no-highlight">5533</i>&nbsp;
<i class="no-highlight">5534</i>&nbsp;        Set&lt;String&gt; targetTableColumns =
<i class="no-highlight">5535</i>&nbsp;                new HashSet&lt;&gt;(this.columnMappingMap.keySet());
<i class="no-highlight">5536</i>&nbsp;
<b class="nc"><i class="no-highlight">5537</i>&nbsp;        // Append target column names with source column positions from the map.</b>
<b class="nc"><i class="no-highlight">5538</i>&nbsp;        StringBuilder headerColumnsBuilder = new StringBuilder();</b>
<b class="nc"><i class="no-highlight">5539</i>&nbsp;        boolean firstEntry = true;</b>
<i class="no-highlight">5540</i>&nbsp;        for (String targetColName : this.targetColumns) {
<b class="nc"><i class="no-highlight">5541</i>&nbsp;            if (targetTableColumns.contains(targetColName)) {</b>
<b class="nc"><i class="no-highlight">5542</i>&nbsp;                if (firstEntry) {</b>
<i class="no-highlight">5543</i>&nbsp;                    firstEntry = false;
<i class="no-highlight">5544</i>&nbsp;                } else {
<b class="nc"><i class="no-highlight">5545</i>&nbsp;                    headerColumnsBuilder.append(COMMA);</b>
<b class="nc"><i class="no-highlight">5546</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">5547</i>&nbsp;                headerColumnsBuilder.append(targetColName);</b>
<b class="nc"><i class="no-highlight">5548</i>&nbsp;                String sourcePosition = this.columnMappingMap.get(targetColName);</b>
<i class="no-highlight">5549</i>&nbsp;                if (StringUtils.isNotBlank(sourcePosition)) {
<i class="no-highlight">5550</i>&nbsp;                    headerColumnsBuilder.append(SPACE);
<b class="nc"><i class="no-highlight">5551</i>&nbsp;                    headerColumnsBuilder.append(sourcePosition);</b>
<i class="no-highlight">5552</i>&nbsp;                }
<b class="nc"><i class="no-highlight">5553</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5554</i>&nbsp;        }</b>
<i class="no-highlight">5555</i>&nbsp;        queryBuilder.append(String.format(
<b class="nc"><i class="no-highlight">5556</i>&nbsp;                COPY_COLUMNS_FROM_EXTERNAL_STORAGE_AZURE_SYNAPSE,</b>
<b class="nc"><i class="no-highlight">5557</i>&nbsp;                targetTablePath, headerColumnsBuilder.toString()));</b>
<i class="no-highlight">5558</i>&nbsp;    }
<i class="no-highlight">5559</i>&nbsp;
<i class="no-highlight">5560</i>&nbsp;    private void trimListEntries(List&lt;String&gt; stringList) {
<i class="no-highlight">5561</i>&nbsp;        for (int i = 0; i &lt; stringList.size(); i++) {
<b class="nc"><i class="no-highlight">5562</i>&nbsp;            stringList.set(i, StringUtils.trim(stringList.get(i)));</b>
<b class="nc"><i class="no-highlight">5563</i>&nbsp;        }</b>
<i class="no-highlight">5564</i>&nbsp;    }
<i class="no-highlight">5565</i>&nbsp;
<b class="nc"><i class="no-highlight">5566</i>&nbsp;    private void appendFilesOrPatternTypeAzureSynapse() {</b>
<i class="no-highlight">5567</i>&nbsp;        formatFilePathsForAzureSynapse(filePaths, azureAccountName, azureSynapseEndpoint,
<b class="nc"><i class="no-highlight">5568</i>&nbsp;                azureContainer, azureFolder);</b>
<i class="no-highlight">5569</i>&nbsp;        getFilesAzureSynapse();
<b class="nc"><i class="no-highlight">5570</i>&nbsp;        // Format: FILES = ( &#39;file1&#39;,&#39;file2&#39;,&#39;file3&#39;... )</b>
<b class="nc"><i class="no-highlight">5571</i>&nbsp;        String fileStr = String.format(AZURE_SYNAPSE_FILES_FMT, StringUtils.join(filePaths,</b>
<i class="no-highlight">5572</i>&nbsp;                COMMA_WITH_QUOTES));
<b class="nc"><i class="no-highlight">5573</i>&nbsp;        queryBuilder.append(fileStr);</b>
<i class="no-highlight">5574</i>&nbsp;    }
<i class="no-highlight">5575</i>&nbsp;
<b class="nc"><i class="no-highlight">5576</i>&nbsp;    private void getAzureStorageFilesForFilePatternSnowflake() {</b>
<b class="nc"><i class="no-highlight">5577</i>&nbsp;        if (StringUtils.isNotBlank(filePattern)) {</b>
<b class="nc"><i class="no-highlight">5578</i>&nbsp;            if (azureDataLakeClient == null) {</b>
<b class="nc"><i class="no-highlight">5579</i>&nbsp;                buildAzureClientForSnowflake();</b>
<i class="no-highlight">5580</i>&nbsp;            }
<b class="nc"><i class="no-highlight">5581</i>&nbsp;            if (StringUtils.isNotBlank(azureContainer)) {</b>
<b class="nc"><i class="no-highlight">5582</i>&nbsp;                listAzureFilesBasedOnPatternMatchingSnowflake();</b>
<i class="no-highlight">5583</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">5584</i>&nbsp;                throwExceptionIfAzureContainerBlank();</b>
<i class="no-highlight">5585</i>&nbsp;            }
<i class="no-highlight">5586</i>&nbsp;        }
<b class="nc"><i class="no-highlight">5587</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5588</i>&nbsp;</b>
<i class="no-highlight">5589</i>&nbsp;    private void getFilesAzureSynapse() {
<i class="no-highlight">5590</i>&nbsp;        if (StringUtils.isNotBlank(filePattern)) {
<b class="nc"><i class="no-highlight">5591</i>&nbsp;            /* Azure Synapse COPY command does not allow to load files based on pattern matching</b>
<i class="no-highlight">5592</i>&nbsp;             * So, we will find all the pattern of files in azure container and load them;
<i class="no-highlight">5593</i>&nbsp;             */
<b class="nc"><i class="no-highlight">5594</i>&nbsp;            buildAzureClient();</b>
<b class="nc"><i class="no-highlight">5595</i>&nbsp;            if (StringUtils.isNotBlank(azureContainer)) {</b>
<b class="nc"><i class="no-highlight">5596</i>&nbsp;                listFilesBasedOnPatternMatchingAzureSynapse();</b>
<i class="no-highlight">5597</i>&nbsp;                filePaths.addAll(files);
<i class="no-highlight">5598</i>&nbsp;                // if no file paths listed in file list property and the file pattern doesn&#39;t
<i class="no-highlight">5599</i>&nbsp;                // return any matches, throw an error
<b class="nc"><i class="no-highlight">5600</i>&nbsp;                if (CollectionUtils.isEmpty(filePaths)) {</b>
<b class="nc"><i class="no-highlight">5601</i>&nbsp;                    throwExceptionIfFileListEmpty();</b>
<i class="no-highlight">5602</i>&nbsp;                }
<b class="nc"><i class="no-highlight">5603</i>&nbsp;            } else {</b>
<i class="no-highlight">5604</i>&nbsp;                throwExceptionIfAzureContainerBlank();
<i class="no-highlight">5605</i>&nbsp;            }
<i class="no-highlight">5606</i>&nbsp;        }
<i class="no-highlight">5607</i>&nbsp;    }
<i class="no-highlight">5608</i>&nbsp;
<b class="nc"><i class="no-highlight">5609</i>&nbsp;    private void throwExceptionIfAzureContainerBlank() {</b>
<b class="nc"><i class="no-highlight">5610</i>&nbsp;        throw new ConfigurationException(ERR_FETCH_FILES_FROM_PATTERN)</b>
<b class="nc"><i class="no-highlight">5611</i>&nbsp;                .withReason(REASON_FETCH_FILES_FROM_PATTERN)</b>
<i class="no-highlight">5612</i>&nbsp;                .withResolution(RESOLUTION_FETCH_FILES_FROM_PATTERN);
<i class="no-highlight">5613</i>&nbsp;    }
<b class="nc"><i class="no-highlight">5614</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5615</i>&nbsp;    private void formatFilePathsForAzureSynapse(List&lt;String&gt; filesList, String accountName,</b>
<i class="no-highlight">5616</i>&nbsp;                                                String endpoint, String container, String folder) {
<i class="no-highlight">5617</i>&nbsp;        if (CollectionUtils.isNotEmpty(filesList)) {
<b class="nc"><i class="no-highlight">5618</i>&nbsp;            for (String filePath : filesList) {</b>
<i class="no-highlight">5619</i>&nbsp;                String filePathReformatted;
<i class="no-highlight">5620</i>&nbsp;                Matcher extFileMatcher = AZURE_SYNAPSE_EXTFILE_PATTERN.matcher(filePath);
<b class="nc"><i class="no-highlight">5621</i>&nbsp;                if (!extFileMatcher.matches()) {</b>
<b class="nc"><i class="no-highlight">5622</i>&nbsp;                    filePathReformatted = reformatAzureFilePathIfInUrlFormat(filePath);</b>
<b class="nc"><i class="no-highlight">5623</i>&nbsp;                    StringBuilder azureContainerFolderFilePathBuilder =</b>
<i class="no-highlight">5624</i>&nbsp;                            new StringBuilder(2048);
<i class="no-highlight">5625</i>&nbsp;                    if (StringUtils.isNotBlank(container)) {
<i class="no-highlight">5626</i>&nbsp;                        azureContainerFolderFilePathBuilder
<i class="no-highlight">5627</i>&nbsp;                                .append(StringUtils.strip(container, SLASH));
<b class="nc"><i class="no-highlight">5628</i>&nbsp;                    }</b>
<b class="nc"><i class="no-highlight">5629</i>&nbsp;                    if (StringUtils.isNotBlank(folder)) {</b>
<i class="no-highlight">5630</i>&nbsp;                        azureContainerFolderFilePathBuilder.append(SLASH);
<i class="no-highlight">5631</i>&nbsp;                        azureContainerFolderFilePathBuilder
<b class="nc"><i class="no-highlight">5632</i>&nbsp;                                .append(StringUtils.strip(folder, SLASH));</b>
<i class="no-highlight">5633</i>&nbsp;                    }
<i class="no-highlight">5634</i>&nbsp;                    if (StringUtils.isNotBlank(filePathReformatted)) {
<b class="nc"><i class="no-highlight">5635</i>&nbsp;                        azureContainerFolderFilePathBuilder.append(SLASH);</b>
<b class="nc"><i class="no-highlight">5636</i>&nbsp;                        azureContainerFolderFilePathBuilder</b>
<i class="no-highlight">5637</i>&nbsp;                                .append(StringUtils.strip(filePathReformatted,
<i class="no-highlight">5638</i>&nbsp;                                        SLASH));
<b class="nc"><i class="no-highlight">5639</i>&nbsp;                    }</b>
<i class="no-highlight">5640</i>&nbsp;                    String fullFilePath =
<b class="nc"><i class="no-highlight">5641</i>&nbsp;                            String.format(AZURE_SYNAPSE_EXTERNAL_FILE_FMT, accountName,</b>
<b class="nc"><i class="no-highlight">5642</i>&nbsp;                                    endpoint,</b>
<i class="no-highlight">5643</i>&nbsp;                                    azureContainerFolderFilePathBuilder.toString());
<i class="no-highlight">5644</i>&nbsp;                    int index = filesList.indexOf(filePathReformatted);
<i class="no-highlight">5645</i>&nbsp;                    filesList.set(index, fullFilePath);
<i class="no-highlight">5646</i>&nbsp;                }
<i class="no-highlight">5647</i>&nbsp;            }
<i class="no-highlight">5648</i>&nbsp;        }
<i class="no-highlight">5649</i>&nbsp;    }
<b class="nc"><i class="no-highlight">5650</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5651</i>&nbsp;    private String reformatAzureFilePathIfInUrlFormat(String filePath) {</b>
<b class="nc"><i class="no-highlight">5652</i>&nbsp;        if (StringUtils.isNotBlank(filePath)) {</b>
<i class="no-highlight">5653</i>&nbsp;            int index = filePath.lastIndexOf(URL_PROTOCOL_DELIM);
<b class="nc"><i class="no-highlight">5654</i>&nbsp;            if (index &gt; 0) {</b>
<i class="no-highlight">5655</i>&nbsp;                filePath = filePath.substring(index + URL_PROTOCOL_DELIM.length());
<b class="nc"><i class="no-highlight">5656</i>&nbsp;                index = filePath.indexOf(SLASH);</b>
<i class="no-highlight">5657</i>&nbsp;                if (index &gt; 0) {
<b class="nc"><i class="no-highlight">5658</i>&nbsp;                    filePath = filePath.substring(++index);</b>
<b class="nc"><i class="no-highlight">5659</i>&nbsp;                }</b>
<i class="no-highlight">5660</i>&nbsp;            }
<i class="no-highlight">5661</i>&nbsp;        }
<b class="nc"><i class="no-highlight">5662</i>&nbsp;        return filePath;</b>
<i class="no-highlight">5663</i>&nbsp;    }
<i class="no-highlight">5664</i>&nbsp;
<b class="nc"><i class="no-highlight">5665</i>&nbsp;    /**</b>
<b class="nc"><i class="no-highlight">5666</i>&nbsp;     * Sets up, if necessary, azureDataLakeClient and dataLakeFileSystemClient.</b>
<b class="nc"><i class="no-highlight">5667</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">5668</i>&nbsp;    private void prepareAzureStorageForSchemaInferenceSnowflake() {</b>
<b class="nc"><i class="no-highlight">5669</i>&nbsp;        try {</b>
<i class="no-highlight">5670</i>&nbsp;            if (azureDataLakeClient == null) {
<i class="no-highlight">5671</i>&nbsp;                buildAzureClientForSnowflake();
<b class="nc"><i class="no-highlight">5672</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5673</i>&nbsp;            if (dataLakeFileSystemClient == null) {</b>
<i class="no-highlight">5674</i>&nbsp;                DataLakeServiceClient dataLakeServiceClient =
<i class="no-highlight">5675</i>&nbsp;                        azureDataLakeClient.getDataLakeServiceClient();
<i class="no-highlight">5676</i>&nbsp;                dataLakeFileSystemClient =
<i class="no-highlight">5677</i>&nbsp;                        dataLakeServiceClient.getFileSystemClient(azureContainer);
<i class="no-highlight">5678</i>&nbsp;            }
<i class="no-highlight">5679</i>&nbsp;        } catch (Exception ex) {
<i class="no-highlight">5680</i>&nbsp;            throw new SnapDataException(ex, ERR_OPEN_SCHEMA_INFERENCE_AZURE)
<b class="nc"><i class="no-highlight">5681</i>&nbsp;                    .withReason(String.format(REASON_OPEN_SCHEMA_INFERENCE_AZURE,</b>
<b class="nc"><i class="no-highlight">5682</i>&nbsp;                            azureSynapseExternalStorage))</b>
<b class="nc"><i class="no-highlight">5683</i>&nbsp;                    .withResolution(RESOLUTION_OPEN_SCHEMA_INFERENCE_AZURE);</b>
<b class="nc"><i class="no-highlight">5684</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">5685</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5686</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5687</i>&nbsp;    private void buildAzureClientForSnowflake() {</b>
<i class="no-highlight">5688</i>&nbsp;        if (StringUtils.isNotEmpty(azureSasToken)) {
<i class="no-highlight">5689</i>&nbsp;            azureDataLakeClient =
<b class="nc"><i class="no-highlight">5690</i>&nbsp;                    getAzureSasTokenClients(eltDatabaseAccount.getAzureAccountName(),</b>
<b class="nc"><i class="no-highlight">5691</i>&nbsp;                            AZURE_STORAGE_ENDPOINT_FOR_SNOWFLAKE,</b>
<i class="no-highlight">5692</i>&nbsp;                            azureSasToken);
<i class="no-highlight">5693</i>&nbsp;        }
<b class="nc"><i class="no-highlight">5694</i>&nbsp;    }</b>
<i class="no-highlight">5695</i>&nbsp;
<i class="no-highlight">5696</i>&nbsp;    private void buildAzureClient() {
<i class="no-highlight">5697</i>&nbsp;        if (azureSynapseAuthType.equalsIgnoreCase(AZURE_SYNAPSE_AAD_USER_AUTH)) {
<b class="nc"><i class="no-highlight">5698</i>&nbsp;            if (StringUtils.isBlank(eltDatabaseAccount.getAzureSynapseClientId()) ||</b>
<b class="nc"><i class="no-highlight">5699</i>&nbsp;                    StringUtils.isBlank(eltDatabaseAccount.getAzureSynapseClientSecret()) ||</b>
<b class="nc"><i class="no-highlight">5700</i>&nbsp;                    StringUtils.isBlank(eltDatabaseAccount.getAzureSynapseTenantId())) {</b>
<b class="nc"><i class="no-highlight">5701</i>&nbsp;                throw new ConfigurationException(ERR_BLANK_AAD_CREDS)</b>
<b class="nc"><i class="no-highlight">5702</i>&nbsp;                        .withReason(REASON_BLANK_AAD_CREDS)</b>
<b class="nc"><i class="no-highlight">5703</i>&nbsp;                        .withResolution(RES_BLANK_AAD_CREDS);</b>
<b class="nc"><i class="no-highlight">5704</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5705</i>&nbsp;            azureDataLakeClient =</b>
<i class="no-highlight">5706</i>&nbsp;                    getAzureAADClients(eltDatabaseAccount.getAzureAccountName(),
<i class="no-highlight">5707</i>&nbsp;                            eltDatabaseAccount.getAzureSynapseTenantId(),
<i class="no-highlight">5708</i>&nbsp;                            eltDatabaseAccount.getAzureSynapseClientId(),
<i class="no-highlight">5709</i>&nbsp;                            eltDatabaseAccount.getAzureSynapseClientSecret(),
<i class="no-highlight">5710</i>&nbsp;                            eltDatabaseAccount.getAzureSynapseStorageEndpoint());
<b class="nc"><i class="no-highlight">5711</i>&nbsp;        } else {</b>
<b class="nc"><i class="no-highlight">5712</i>&nbsp;            if (StringUtils.isBlank(eltDatabaseAccount.getAzureSynapseStorageKey())) {</b>
<b class="nc"><i class="no-highlight">5713</i>&nbsp;                throw new ConfigurationException(ERR_BLANK_STORAGE_KEY)</b>
<b class="nc"><i class="no-highlight">5714</i>&nbsp;                        .withReason(REASON_BLANK_STORAGE_KEY)</b>
<b class="nc"><i class="no-highlight">5715</i>&nbsp;                        .withResolution(RES_BLANK_STORAGE_KEY);</b>
<b class="nc"><i class="no-highlight">5716</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5717</i>&nbsp;            azureDataLakeClient =</b>
<b class="nc"><i class="no-highlight">5718</i>&nbsp;                    getAzureSharedKeyClients(eltDatabaseAccount.getAzureAccountName(),</b>
<i class="no-highlight">5719</i>&nbsp;                            eltDatabaseAccount.getAzureSynapseStorageEndpoint(),
<i class="no-highlight">5720</i>&nbsp;                            eltDatabaseAccount.getAzureSynapseStorageKey());
<b class="nc"><i class="no-highlight">5721</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">5722</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5723</i>&nbsp;</b>
<i class="no-highlight">5724</i>&nbsp;    private void listAzureCloudStorageFilesBasedOnPatternMatching(
<b class="nc"><i class="no-highlight">5725</i>&nbsp;            Pattern pattern, String folder, boolean addToFiles) throws Exception {</b>
<b class="nc"><i class="no-highlight">5726</i>&nbsp;        if (dataLakeFileSystemClient == null) {</b>
<b class="nc"><i class="no-highlight">5727</i>&nbsp;            DataLakeServiceClient dataLakeServiceClient =</b>
<b class="nc"><i class="no-highlight">5728</i>&nbsp;                    azureDataLakeClient.getDataLakeServiceClient();</b>
<i class="no-highlight">5729</i>&nbsp;
<b class="nc"><i class="no-highlight">5730</i>&nbsp;            dataLakeFileSystemClient =</b>
<i class="no-highlight">5731</i>&nbsp;                    dataLakeServiceClient.getFileSystemClient(azureContainer);
<b class="nc"><i class="no-highlight">5732</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">5733</i>&nbsp;</b>
<i class="no-highlight">5734</i>&nbsp;        ListPathsOptions options = new ListPathsOptions();
<b class="nc"><i class="no-highlight">5735</i>&nbsp;        options.setRecursive(true);</b>
<b class="nc"><i class="no-highlight">5736</i>&nbsp;        if (StringUtils.isNotBlank(folder)) {</b>
<b class="nc"><i class="no-highlight">5737</i>&nbsp;            options.setPath(folder + SLASH);</b>
<b class="nc"><i class="no-highlight">5738</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">5739</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5740</i>&nbsp;        for (PathItem pathItem : dataLakeFileSystemClient.listPaths(options,</b>
<i class="no-highlight">5741</i>&nbsp;                AZURE_API_TIMEOUT_SEC)) {
<i class="no-highlight">5742</i>&nbsp;            if (pathItem.isDirectory()) {
<i class="no-highlight">5743</i>&nbsp;                continue;
<i class="no-highlight">5744</i>&nbsp;            }
<b class="nc"><i class="no-highlight">5745</i>&nbsp;            addToFilesIfMatchesPattern(pathItem.getName(), folder, pattern, addToFiles);</b>
<b class="nc"><i class="no-highlight">5746</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">5747</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5748</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5749</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5750</i>&nbsp;    protected void listAzureFilesBasedOnPatternMatchingSnowflake() {</b>
<b class="nc"><i class="no-highlight">5751</i>&nbsp;        Pattern pattern = Pattern.compile(filePattern);</b>
<b class="nc"><i class="no-highlight">5752</i>&nbsp;        String folder = StringUtils.strip(azureFolder, SLASH);</b>
<i class="no-highlight">5753</i>&nbsp;
<i class="no-highlight">5754</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">5755</i>&nbsp;            boolean isADLSGen2Storage = false;</b>
<b class="nc"><i class="no-highlight">5756</i>&nbsp;            // Storage Location auth type</b>
<b class="nc"><i class="no-highlight">5757</i>&nbsp;            if (StringUtils.isNotBlank(cloudStorageLocation)) {</b>
<b class="nc"><i class="no-highlight">5758</i>&nbsp;                // This is the case for WASB or non ADLS Gen2.</b>
<b class="nc"><i class="no-highlight">5759</i>&nbsp;                if (azureExternalLocation.equalsIgnoreCase(AZURE_SYNAPSE_BLOB_STORAGE)) {</b>
<b class="nc"><i class="no-highlight">5760</i>&nbsp;                    isADLSGen2Storage = false;</b>
<b class="nc"><i class="no-highlight">5761</i>&nbsp;                } else { // his is the case for ADLS Gen2.</b>
<i class="no-highlight">5762</i>&nbsp;                    isADLSGen2Storage = true;
<b class="nc"><i class="no-highlight">5763</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">5764</i>&nbsp;            } else {    // Source Location Creditionals auth type</b>
<i class="no-highlight">5765</i>&nbsp;                String urlStr = String.format(AZURE_BLOB_SERVICE_REST_GET_ACCOUNT_INFO_URL_FORMAT,
<b class="nc"><i class="no-highlight">5766</i>&nbsp;                        azureAccountName, azureFolder, StringUtils.stripStart(azureSasToken, &quot;?&quot;));</b>
<b class="nc"><i class="no-highlight">5767</i>&nbsp;                String externalLocation =</b>
<i class="no-highlight">5768</i>&nbsp;                        AzureStorageApi.getAzureExternalLocation(urlStr, azureAccountName);
<b class="nc"><i class="no-highlight">5769</i>&nbsp;                // This is the case for WASB or non ADLS Gen2</b>
<b class="nc"><i class="no-highlight">5770</i>&nbsp;                if (externalLocation.equalsIgnoreCase(AZURE_EXTERNAL_LOCATION_NONADLSGEN2)) {</b>
<b class="nc"><i class="no-highlight">5771</i>&nbsp;                    isADLSGen2Storage = false;</b>
<i class="no-highlight">5772</i>&nbsp;                } else { // This is the case for ADLS Gen2.
<b class="nc"><i class="no-highlight">5773</i>&nbsp;                    isADLSGen2Storage = true;</b>
<b class="nc"><i class="no-highlight">5774</i>&nbsp;                }</b>
<i class="no-highlight">5775</i>&nbsp;            }
<b class="nc"><i class="no-highlight">5776</i>&nbsp;            if (isADLSGen2Storage) {</b>
<b class="nc"><i class="no-highlight">5777</i>&nbsp;                listAzureCloudStorageFilesBasedOnPatternMatching(</b>
<i class="no-highlight">5778</i>&nbsp;                        pattern, folder, false);
<b class="nc"><i class="no-highlight">5779</i>&nbsp;            } else {</b>
<b class="nc"><i class="no-highlight">5780</i>&nbsp;                listAzureCloudStorageFilesBasedOnPatternMatchingBlobStorage(</b>
<b class="nc"><i class="no-highlight">5781</i>&nbsp;                        pattern, folder, false);</b>
<b class="nc"><i class="no-highlight">5782</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5783</i>&nbsp;        } catch (Exception ex) {</b>
<b class="nc"><i class="no-highlight">5784</i>&nbsp;            throwExceptionFetchFilesFromPattern(ex);</b>
<i class="no-highlight">5785</i>&nbsp;        }
<i class="no-highlight">5786</i>&nbsp;    }
<i class="no-highlight">5787</i>&nbsp;
<b class="nc"><i class="no-highlight">5788</i>&nbsp;    private void throwExceptionFetchFilesFromPattern(Exception ex) {</b>
<b class="nc"><i class="no-highlight">5789</i>&nbsp;        throw new SnapDataException(ex, ERR_FETCH_FILES_FROM_PATTERN)</b>
<i class="no-highlight">5790</i>&nbsp;                .withReason(String.format(REASON_INCORRECT_EXTERNAL_STORAGE_ACCOUNT,
<b class="nc"><i class="no-highlight">5791</i>&nbsp;                        azureSynapseExternalStorage))</b>
<b class="nc"><i class="no-highlight">5792</i>&nbsp;                .withResolution(String.format(RESOLUTION_INCORERCT_EXTERNAL_STORAGE_ACCOUNT,</b>
<b class="nc"><i class="no-highlight">5793</i>&nbsp;                        azureSynapseExternalStorage));</b>
<b class="nc"><i class="no-highlight">5794</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5795</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5796</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">5797</i>&nbsp;    protected void listFilesBasedOnPatternMatchingAzureSynapse() {</b>
<b class="nc"><i class="no-highlight">5798</i>&nbsp;        Pattern pattern = Pattern.compile(filePattern);</b>
<i class="no-highlight">5799</i>&nbsp;        files.clear();
<i class="no-highlight">5800</i>&nbsp;        String folder = StringUtils.strip(azureFolder, SLASH);
<b class="nc"><i class="no-highlight">5801</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5802</i>&nbsp;        try {</b>
<b class="nc"><i class="no-highlight">5803</i>&nbsp;            if (azureSynapseExternalStorage.equalsIgnoreCase(AZURE_SYNAPSE_BLOB_STORAGE)) {</b>
<b class="nc"><i class="no-highlight">5804</i>&nbsp;                listAzureCloudStorageFilesBasedOnPatternMatchingBlobStorage(</b>
<i class="no-highlight">5805</i>&nbsp;                        pattern, folder, true);
<i class="no-highlight">5806</i>&nbsp;            } else {
<i class="no-highlight">5807</i>&nbsp;                listAzureCloudStorageFilesBasedOnPatternMatching(
<b class="nc"><i class="no-highlight">5808</i>&nbsp;                        pattern, folder, true);</b>
<i class="no-highlight">5809</i>&nbsp;            }
<i class="no-highlight">5810</i>&nbsp;        } catch (Exception ex) {
<b class="nc"><i class="no-highlight">5811</i>&nbsp;            throwExceptionFetchFilesFromPattern(ex);</b>
<b class="nc"><i class="no-highlight">5812</i>&nbsp;        }</b>
<i class="no-highlight">5813</i>&nbsp;    }
<b class="nc"><i class="no-highlight">5814</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5815</i>&nbsp;    private void listAzureCloudStorageFilesBasedOnPatternMatchingBlobStorage(</b>
<i class="no-highlight">5816</i>&nbsp;            Pattern pattern, String folder, boolean addToFiles) throws Exception {
<b class="nc"><i class="no-highlight">5817</i>&nbsp;        BlobServiceClient blobServiceClient = azureDataLakeClient.getBlobServiceClient();</b>
<i class="no-highlight">5818</i>&nbsp;        BlobContainerClient blobContainerClient = blobServiceClient.getBlobContainerClient(
<i class="no-highlight">5819</i>&nbsp;                azureContainer);
<i class="no-highlight">5820</i>&nbsp;
<i class="no-highlight">5821</i>&nbsp;        ListBlobsOptions blobOptions = new ListBlobsOptions();
<b class="nc"><i class="no-highlight">5822</i>&nbsp;        // Set folder name in bloboptions as prefix. Folder name should end with / for</b>
<i class="no-highlight">5823</i>&nbsp;        // listing to work correctly
<i class="no-highlight">5824</i>&nbsp;        if (StringUtils.isNotBlank(folder)) {
<i class="no-highlight">5825</i>&nbsp;            blobOptions.setPrefix(folder + SLASH);
<b class="nc"><i class="no-highlight">5826</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">5827</i>&nbsp;</b>
<i class="no-highlight">5828</i>&nbsp;        for (BlobItem blob : blobContainerClient.listBlobs(blobOptions,
<i class="no-highlight">5829</i>&nbsp;                AZURE_API_TIMEOUT_SEC)) {
<i class="no-highlight">5830</i>&nbsp;            addToFilesIfMatchesPattern(blob.getName(), folder, pattern, addToFiles);
<i class="no-highlight">5831</i>&nbsp;        }
<b class="nc"><i class="no-highlight">5832</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5833</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5834</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">5835</i>&nbsp;    protected void addToFilesIfMatchesPattern(</b>
<b class="nc"><i class="no-highlight">5836</i>&nbsp;            String filePathStr, String folder, Pattern pattern, boolean addToFiles) {</b>
<i class="no-highlight">5837</i>&nbsp;        String relativePath;
<i class="no-highlight">5838</i>&nbsp;        String absolutePath;
<b class="nc"><i class="no-highlight">5839</i>&nbsp;        List&lt;String&gt; pathList = new ArrayList&lt;&gt;();</b>
<i class="no-highlight">5840</i>&nbsp;        if (StringUtils.isNotBlank(folder) &amp;&amp; StringUtils.isNotBlank(filePathStr)) {
<i class="no-highlight">5841</i>&nbsp;            relativePath = filePathStr.substring(folder.length());
<b class="nc"><i class="no-highlight">5842</i>&nbsp;        } else {</b>
<b class="nc"><i class="no-highlight">5843</i>&nbsp;            relativePath = filePathStr;</b>
<b class="nc"><i class="no-highlight">5844</i>&nbsp;        }</b>
<i class="no-highlight">5845</i>&nbsp;        pathList.add(0, relativePath);
<b class="nc"><i class="no-highlight">5846</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5847</i>&nbsp;        if (isSnowflakeDb()) {</b>
<i class="no-highlight">5848</i>&nbsp;            formatFilePathsForAzureSynapse(pathList, azureAccountName,
<b class="nc"><i class="no-highlight">5849</i>&nbsp;                    AZURE_STORAGE_ENDPOINT_FOR_SNOWFLAKE, azureContainer, azureFolder);</b>
<b class="nc"><i class="no-highlight">5850</i>&nbsp;        } else {</b>
<i class="no-highlight">5851</i>&nbsp;            formatFilePathsForAzureSynapse(pathList, azureAccountName,
<b class="nc"><i class="no-highlight">5852</i>&nbsp;                    azureSynapseEndpoint, azureContainer, azureFolder);</b>
<b class="nc"><i class="no-highlight">5853</i>&nbsp;        }</b>
<i class="no-highlight">5854</i>&nbsp;        absolutePath = pathList.get(0);
<b class="nc"><i class="no-highlight">5855</i>&nbsp;        Matcher matcher = pattern.matcher(absolutePath);</b>
<i class="no-highlight">5856</i>&nbsp;        if (matcher.find()) {
<b class="nc"><i class="no-highlight">5857</i>&nbsp;            if (inferSchemaEnabled){</b>
<b class="nc"><i class="no-highlight">5858</i>&nbsp;                filesForSchemaInference.add(StringUtils.strip(relativePath, SLASH));</b>
<b class="nc"><i class="no-highlight">5859</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5860</i>&nbsp;</b>
<i class="no-highlight">5861</i>&nbsp;            if (addToFiles) {
<b class="nc"><i class="no-highlight">5862</i>&nbsp;                files.add(absolutePath);</b>
<b class="nc"><i class="no-highlight">5863</i>&nbsp;            }</b>
<i class="no-highlight">5864</i>&nbsp;        }
<b class="nc"><i class="no-highlight">5865</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5866</i>&nbsp;</b>
<i class="no-highlight">5867</i>&nbsp;    private String sanitizeAzureSynapseErrorMessage(Exception e) {
<i class="no-highlight">5868</i>&nbsp;        String sanitizedMessage;
<b class="nc"><i class="no-highlight">5869</i>&nbsp;        try {</b>
<b class="nc"><i class="no-highlight">5870</i>&nbsp;            sanitizedMessage = ((SnapDataException) e).getReason() != null ?</b>
<b class="nc"><i class="no-highlight">5871</i>&nbsp;                    ((SnapDataException) e).getReason() : e.getMessage();</b>
<b class="nc"><i class="no-highlight">5872</i>&nbsp;        } catch (ClassCastException cle) {</b>
<b class="nc"><i class="no-highlight">5873</i>&nbsp;            sanitizedMessage = e.toString();</b>
<b class="nc"><i class="no-highlight">5874</i>&nbsp;        }</b>
<i class="no-highlight">5875</i>&nbsp;        if (StringUtils.containsIgnoreCase(sanitizedMessage, azureSynapseCredential)) {
<b class="nc"><i class="no-highlight">5876</i>&nbsp;            sanitizedMessage = StringUtils.replace(sanitizedMessage, azureSynapseCredential,</b>
<b class="nc"><i class="no-highlight">5877</i>&nbsp;                    AZURE_SYNAPSE_CREDENTIAL_REPLACEMENT);</b>
<b class="nc"><i class="no-highlight">5878</i>&nbsp;        }</b>
<i class="no-highlight">5879</i>&nbsp;        if (StringUtils.containsIgnoreCase(sanitizedMessage, errAzureCredential)) {
<b class="nc"><i class="no-highlight">5880</i>&nbsp;            sanitizedMessage = StringUtils.replace(sanitizedMessage, errAzureCredential,</b>
<b class="nc"><i class="no-highlight">5881</i>&nbsp;                    AZURE_SYNAPSE_CREDENTIAL_REPLACEMENT);</b>
<b class="nc"><i class="no-highlight">5882</i>&nbsp;        }</b>
<i class="no-highlight">5883</i>&nbsp;        return sanitizedMessage;
<b class="nc"><i class="no-highlight">5884</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">5885</i>&nbsp;</b>
<i class="no-highlight">5886</i>&nbsp;    private void executeAzureSynapseBulkLoadWithRollback() {
<b class="nc"><i class="no-highlight">5887</i>&nbsp;        if (StringUtils.equalsIgnoreCase(loadAction, DROP_CREATE_TABLE)) {</b>
<b class="nc"><i class="no-highlight">5888</i>&nbsp;            executeDropCreateTableBulkLoadAzureSynapse();</b>
<b class="nc"><i class="no-highlight">5889</i>&nbsp;        } else if (StringUtils.equalsIgnoreCase(loadAction, ALTER_TABLE)) {</b>
<b class="nc"><i class="no-highlight">5890</i>&nbsp;            executeAlterTableBulkLoadAzureSynapse();</b>
<b class="nc"><i class="no-highlight">5891</i>&nbsp;        } else if (StringUtils.equalsIgnoreCase(loadAction, OVERWRITE_TABLE)) {</b>
<b class="nc"><i class="no-highlight">5892</i>&nbsp;            executeOverwriteTableBulkLoadAzureSynapse();</b>
<b class="nc"><i class="no-highlight">5893</i>&nbsp;        } else if (StringUtils.equals(loadAction, APPEND_ROWS_TABLE)) {</b>
<i class="no-highlight">5894</i>&nbsp;            executeAppendToTableBulkLoadAzureSynapse();
<b class="nc"><i class="no-highlight">5895</i>&nbsp;        }</b>
<i class="no-highlight">5896</i>&nbsp;    }
<i class="no-highlight">5897</i>&nbsp;
<i class="no-highlight">5898</i>&nbsp;    private void executeAppendToTableBulkLoadAzureSynapse() {
<i class="no-highlight">5899</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">5900</i>&nbsp;            if (!doesTableExist) {</b>
<b class="nc"><i class="no-highlight">5901</i>&nbsp;                throwExceptionIfNotDropAndCreateLoadAction();</b>
<b class="nc"><i class="no-highlight">5902</i>&nbsp;                sqlCreateTable = buildCreateTableSql();</b>
<b class="nc"><i class="no-highlight">5903</i>&nbsp;                executedQueries.add(sqlCreateTable);</b>
<b class="nc"><i class="no-highlight">5904</i>&nbsp;                statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">5905</i>&nbsp;                        new QueryStatisticHolderBuilder(sqlCreateTable).build());</b>
<b class="nc"><i class="no-highlight">5906</i>&nbsp;                executeSqlStmt(sqlCreateTable, bindValues, account);</b>
<b class="nc"><i class="no-highlight">5907</i>&nbsp;                doesTableExist = true;</b>
<b class="nc"><i class="no-highlight">5908</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5909</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5910</i>&nbsp;            if (!validationInProgress) {</b>
<b class="nc"><i class="no-highlight">5911</i>&nbsp;                setAutoCommitLevel(true);</b>
<b class="nc"><i class="no-highlight">5912</i>&nbsp;                shouldRollbackOrCommit = false;</b>
<b class="nc"><i class="no-highlight">5913</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5914</i>&nbsp;                executedQueries.add(sqlBulkLoad);</b>
<b class="nc"><i class="no-highlight">5915</i>&nbsp;                int numberOfInserts =</b>
<b class="nc"><i class="no-highlight">5916</i>&nbsp;                        executeStatement(sqlBulkLoad, null, account);</b>
<b class="nc"><i class="no-highlight">5917</i>&nbsp;                statistic.addNumberOfInserts(numberOfInserts);</b>
<b class="nc"><i class="no-highlight">5918</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5919</i>&nbsp;                statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">5920</i>&nbsp;                        new QueryStatisticHolderBuilder(sqlBulkLoad)</b>
<i class="no-highlight">5921</i>&nbsp;                                .setNumberOfInserts(numberOfInserts)
<i class="no-highlight">5922</i>&nbsp;                                .build());
<i class="no-highlight">5923</i>&nbsp;            }
<b class="nc"><i class="no-highlight">5924</i>&nbsp;        } catch (Exception e) {</b>
<b class="nc"><i class="no-highlight">5925</i>&nbsp;            handleFailures(ERR_BULK_LOAD);</b>
<b class="nc"><i class="no-highlight">5926</i>&nbsp;            throw new SnapDataException(e, ERR_BULK_LOAD)</b>
<b class="nc"><i class="no-highlight">5927</i>&nbsp;                    .withReason(sanitizeAzureSynapseErrorMessage(e))</b>
<b class="nc"><i class="no-highlight">5928</i>&nbsp;                    .withResolution(RESOLUTION_BULK_LOAD);</b>
<b class="nc"><i class="no-highlight">5929</i>&nbsp;        }</b>
<i class="no-highlight">5930</i>&nbsp;    }
<i class="no-highlight">5931</i>&nbsp;
<i class="no-highlight">5932</i>&nbsp;    private void executeOverwriteTableBulkLoadAzureSynapse() {
<i class="no-highlight">5933</i>&nbsp;        try {
<i class="no-highlight">5934</i>&nbsp;            if (!doesTableExist) {
<i class="no-highlight">5935</i>&nbsp;                throwExceptionIfNotDropAndCreateLoadAction();
<i class="no-highlight">5936</i>&nbsp;                sqlCreateTable = buildCreateTableSql();
<i class="no-highlight">5937</i>&nbsp;                executedQueries.add(sqlCreateTable);
<i class="no-highlight">5938</i>&nbsp;                statistic.addQueryStatistic(
<b class="nc"><i class="no-highlight">5939</i>&nbsp;                        new QueryStatisticHolderBuilder(sqlCreateTable).build());</b>
<b class="nc"><i class="no-highlight">5940</i>&nbsp;                executeSqlStmt(sqlCreateTable, bindValues, account);</b>
<b class="nc"><i class="no-highlight">5941</i>&nbsp;                doesTableExist = true;</b>
<b class="nc"><i class="no-highlight">5942</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5943</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5944</i>&nbsp;            if (!validationInProgress) {</b>
<b class="nc"><i class="no-highlight">5945</i>&nbsp;                setAutoCommitLevel(false);</b>
<b class="nc"><i class="no-highlight">5946</i>&nbsp;                shouldRollbackOrCommit = true;</b>
<i class="no-highlight">5947</i>&nbsp;                sqlDeleteTable = buildDeleteTableSql(targetTablePath);
<i class="no-highlight">5948</i>&nbsp;                executedQueries.add(sqlDeleteTable);
<i class="no-highlight">5949</i>&nbsp;                int numberOfDeletes =
<i class="no-highlight">5950</i>&nbsp;                        executeStatement(sqlDeleteTable, bindValues, account);
<b class="nc"><i class="no-highlight">5951</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5952</i>&nbsp;                statistic.addNumberOfDeletes(numberOfDeletes);</b>
<i class="no-highlight">5953</i>&nbsp;                statistic.addQueryStatistic(
<b class="nc"><i class="no-highlight">5954</i>&nbsp;                        new QueryStatisticHolderBuilder(sqlDeleteTable)</b>
<b class="nc"><i class="no-highlight">5955</i>&nbsp;                                .setNumberOfDeletes(numberOfDeletes)</b>
<i class="no-highlight">5956</i>&nbsp;                                .build());
<i class="no-highlight">5957</i>&nbsp;
<b class="nc"><i class="no-highlight">5958</i>&nbsp;                executedQueries.add(sqlBulkLoad);</b>
<b class="nc"><i class="no-highlight">5959</i>&nbsp;                int numberOfInserts =</b>
<b class="nc"><i class="no-highlight">5960</i>&nbsp;                        executeStatement(sqlBulkLoad, null, account);</b>
<b class="nc"><i class="no-highlight">5961</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5962</i>&nbsp;                statistic.addNumberOfInserts(numberOfInserts);</b>
<b class="nc"><i class="no-highlight">5963</i>&nbsp;                statistic.addQueryStatistic(</b>
<i class="no-highlight">5964</i>&nbsp;                        new QueryStatisticHolderBuilder(sqlBulkLoad)
<b class="nc"><i class="no-highlight">5965</i>&nbsp;                                .setNumberOfInserts(numberOfInserts)</b>
<b class="nc"><i class="no-highlight">5966</i>&nbsp;                                .build());</b>
<b class="nc"><i class="no-highlight">5967</i>&nbsp;            }</b>
<i class="no-highlight">5968</i>&nbsp;        } catch (Exception e) {
<b class="nc"><i class="no-highlight">5969</i>&nbsp;            handleFailures(ERR_BULK_LOAD);</b>
<b class="nc"><i class="no-highlight">5970</i>&nbsp;            throw new SnapDataException(e, ERR_BULK_LOAD)</b>
<i class="no-highlight">5971</i>&nbsp;                    .withReason(sanitizeAzureSynapseErrorMessage(e))
<b class="nc"><i class="no-highlight">5972</i>&nbsp;                    .withResolution(RESOLUTION_BULK_LOAD);</b>
<b class="nc"><i class="no-highlight">5973</i>&nbsp;        }</b>
<i class="no-highlight">5974</i>&nbsp;    }
<b class="nc"><i class="no-highlight">5975</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5976</i>&nbsp;    private void executeAlterTableBulkLoadAzureSynapse() {</b>
<b class="nc"><i class="no-highlight">5977</i>&nbsp;        boolean isBackUpTableCreated = false;</b>
<b class="nc"><i class="no-highlight">5978</i>&nbsp;        String backUpTargetTableName = getDerivedTableName();</b>
<i class="no-highlight">5979</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">5980</i>&nbsp;            if (!doesTableExist) {</b>
<i class="no-highlight">5981</i>&nbsp;                throwExceptionIfNotDropAndCreateLoadAction();
<b class="nc"><i class="no-highlight">5982</i>&nbsp;                sqlCreateTable = buildCreateTableSql();</b>
<b class="nc"><i class="no-highlight">5983</i>&nbsp;                executedQueries.add(sqlCreateTable);</b>
<b class="nc"><i class="no-highlight">5984</i>&nbsp;                statistic.addQueryStatistic(</b>
<i class="no-highlight">5985</i>&nbsp;                        new QueryStatisticHolderBuilder(sqlCreateTable).build());
<i class="no-highlight">5986</i>&nbsp;                executeSqlStmt(sqlCreateTable, bindValues, account);
<b class="nc"><i class="no-highlight">5987</i>&nbsp;                doesTableExist = true;</b>
<b class="nc"><i class="no-highlight">5988</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5989</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">5990</i>&nbsp;            if (!validationInProgress) {</b>
<b class="nc"><i class="no-highlight">5991</i>&nbsp;                setAutoCommitLevel(true);</b>
<i class="no-highlight">5992</i>&nbsp;                shouldRollbackOrCommit = false;
<b class="nc"><i class="no-highlight">5993</i>&nbsp;                if (alterColumnModifiers.contains(DROP)) {</b>
<b class="nc"><i class="no-highlight">5994</i>&nbsp;                    // Retrieve a DDL of the target table and create a backup table</b>
<b class="nc"><i class="no-highlight">5995</i>&nbsp;                    // this table will be renamed to the source table name in case of rolling back</b>
<i class="no-highlight">5996</i>&nbsp;                    // a drop column operation
<b class="nc"><i class="no-highlight">5997</i>&nbsp;                    createBackUpSql = buildCreateBackUpTableQueryBasedOnOriginalTableDdlScript(</b>
<b class="nc"><i class="no-highlight">5998</i>&nbsp;                            backUpTargetTableName);</b>
<b class="nc"><i class="no-highlight">5999</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6000</i>&nbsp;                    executeSqlStmt(createBackUpSql, bindValues, account);</b>
<b class="nc"><i class="no-highlight">6001</i>&nbsp;                    isBackUpTableCreated = true;</b>
<b class="nc"><i class="no-highlight">6002</i>&nbsp;                    // insert data from target table into backUp table</b>
<b class="nc"><i class="no-highlight">6003</i>&nbsp;                    sqlInsertIntoSelectAs =</b>
<i class="no-highlight">6004</i>&nbsp;                            String.format(INSERT_INTO_SELECT_AS_AZURE_SYNAPSE_SQL_FMT,
<b class="nc"><i class="no-highlight">6005</i>&nbsp;                                    backUpTargetTableName,  targetTablePath);</b>
<b class="nc"><i class="no-highlight">6006</i>&nbsp;                    executeSqlStmt(sqlInsertIntoSelectAs, bindValues, account);</b>
<b class="nc"><i class="no-highlight">6007</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6008</i>&nbsp;                } else {</b>
<b class="nc"><i class="no-highlight">6009</i>&nbsp;                    // build the rollback alter table sql before it is actually altered</b>
<b class="nc"><i class="no-highlight">6010</i>&nbsp;                    //in case of rolling back of an add column operation</b>
<b class="nc"><i class="no-highlight">6011</i>&nbsp;                    buildRollbackAlterTableSql();</b>
<b class="nc"><i class="no-highlight">6012</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">6013</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6014</i>&nbsp;                // alter target table based on user entry</b>
<i class="no-highlight">6015</i>&nbsp;                sqlAlterTable =
<i class="no-highlight">6016</i>&nbsp;                        buildAlterTableSql(
<i class="no-highlight">6017</i>&nbsp;                                targetColumns, targetDataTypes,
<b class="nc"><i class="no-highlight">6018</i>&nbsp;                                alterColumnModifiers, targetTablePath,</b>
<b class="nc"><i class="no-highlight">6019</i>&nbsp;                                ALTER_TABLE_MULTI_ADD_SQL_FMT,</b>
<b class="nc"><i class="no-highlight">6020</i>&nbsp;                                ALTER_TABLE_DROP_SQL_AZURESYNAPSE_FMT);</b>
<b class="nc"><i class="no-highlight">6021</i>&nbsp;                executedQueries.add(sqlAlterTable);</b>
<i class="no-highlight">6022</i>&nbsp;                statistic.addQueryStatistic(
<i class="no-highlight">6023</i>&nbsp;                        new QueryStatisticHolderBuilder(sqlAlterTable).build());
<b class="nc"><i class="no-highlight">6024</i>&nbsp;                executeSqlStmt(sqlAlterTable, bindValues, account);</b>
<b class="nc"><i class="no-highlight">6025</i>&nbsp;                hasAlterTableBeenExecuted = true;</b>
<b class="nc"><i class="no-highlight">6026</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6027</i>&nbsp;                // Complete building sqlBulkLoad, the COPY INTO SQL statement.</b>
<i class="no-highlight">6028</i>&nbsp;                buildSqlBulkLoadStringForAlterTableAfterLoadAction();
<i class="no-highlight">6029</i>&nbsp;
<i class="no-highlight">6030</i>&nbsp;                // Execute the COPY INTO SQL.
<i class="no-highlight">6031</i>&nbsp;                executedQueries.add(sqlBulkLoad);
<i class="no-highlight">6032</i>&nbsp;                int numberOfInserts =
<i class="no-highlight">6033</i>&nbsp;                        executeStatement(sqlBulkLoad, null, account);
<i class="no-highlight">6034</i>&nbsp;
<b class="nc"><i class="no-highlight">6035</i>&nbsp;                statistic.addNumberOfInserts(numberOfInserts);</b>
<b class="nc"><i class="no-highlight">6036</i>&nbsp;                statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">6037</i>&nbsp;                        new QueryStatisticHolderBuilder(sqlBulkLoad)</b>
<b class="nc"><i class="no-highlight">6038</i>&nbsp;                                .setNumberOfInserts(numberOfInserts)</b>
<b class="nc"><i class="no-highlight">6039</i>&nbsp;                                .build());</b>
<b class="nc"><i class="no-highlight">6040</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">6041</i>&nbsp;        } catch (Exception e) {</b>
<b class="nc"><i class="no-highlight">6042</i>&nbsp;            if (hasAlterTableBeenExecuted) {</b>
<i class="no-highlight">6043</i>&nbsp;                try {
<i class="no-highlight">6044</i>&nbsp;                    if (alterColumnModifiers.contains(DROP)) {
<i class="no-highlight">6045</i>&nbsp;                        // Drop original table and rename back-up
<i class="no-highlight">6046</i>&nbsp;                        sqlDropTable = buildDropTableSql(targetTablePath);
<b class="nc"><i class="no-highlight">6047</i>&nbsp;                        executeSqlStmt(sqlDropTable, bindValues, account);</b>
<i class="no-highlight">6048</i>&nbsp;                        isBackUpTableCreated = false;
<b class="nc"><i class="no-highlight">6049</i>&nbsp;                        String renameBackUpSql = String.format(AZURE_SYNAPSE_RENAME_OBJECT,</b>
<b class="nc"><i class="no-highlight">6050</i>&nbsp;                                backUpTargetTableName, tableName);</b>
<i class="no-highlight">6051</i>&nbsp;                        executeSqlStmt(renameBackUpSql, bindValues, account);
<i class="no-highlight">6052</i>&nbsp;                    } else {
<i class="no-highlight">6053</i>&nbsp;                        // drop the newly added targetColumns
<i class="no-highlight">6054</i>&nbsp;                        if (StringUtils.isNotBlank(sqlAlterTableDropColumns)) {
<i class="no-highlight">6055</i>&nbsp;                            executeSqlStmt(sqlAlterTableDropColumns, bindValues, account);
<i class="no-highlight">6056</i>&nbsp;                        }
<i class="no-highlight">6057</i>&nbsp;                    }
<i class="no-highlight">6058</i>&nbsp;                } catch (Exception exception) {
<i class="no-highlight">6059</i>&nbsp;                    handleFailures(ERR_BULK_LOAD);
<i class="no-highlight">6060</i>&nbsp;                    throw new SnapDataException(exception, ERR_ROLLBACK_AZURESYNAPSE_BULK_LOAD)
<i class="no-highlight">6061</i>&nbsp;                            .withReason(sanitizeAzureSynapseErrorMessage(exception))
<i class="no-highlight">6062</i>&nbsp;                            .withResolution(CONTACT_SUPPORT);
<i class="no-highlight">6063</i>&nbsp;                }
<i class="no-highlight">6064</i>&nbsp;            }
<b class="nc"><i class="no-highlight">6065</i>&nbsp;            handleFailures(ERR_BULK_LOAD);</b>
<b class="nc"><i class="no-highlight">6066</i>&nbsp;            if (e instanceof ConfigurationException) {</b>
<b class="nc"><i class="no-highlight">6067</i>&nbsp;                throw ((ConfigurationException) e);</b>
<b class="nc"><i class="no-highlight">6068</i>&nbsp;            }</b>
<i class="no-highlight">6069</i>&nbsp;            throw new SnapDataException(e, ERR_BULK_LOAD)
<b class="nc"><i class="no-highlight">6070</i>&nbsp;                    .withReason(sanitizeAzureSynapseErrorMessage(e))</b>
<b class="nc"><i class="no-highlight">6071</i>&nbsp;                    .withResolution(RESOLUTION_BULK_LOAD);</b>
<b class="nc"><i class="no-highlight">6072</i>&nbsp;        } finally {</b>
<b class="nc"><i class="no-highlight">6073</i>&nbsp;            if (isBackUpTableCreated) {</b>
<b class="nc"><i class="no-highlight">6074</i>&nbsp;                sqlDropTable = buildDropTableSql(backUpTargetTableName);</b>
<i class="no-highlight">6075</i>&nbsp;                try {
<i class="no-highlight">6076</i>&nbsp;                    executeSqlStmt(sqlDropTable, bindValues, account);
<i class="no-highlight">6077</i>&nbsp;                } catch (Exception ex) {
<i class="no-highlight">6078</i>&nbsp;                    handleFailures(ERR_BULK_LOAD);
<i class="no-highlight">6079</i>&nbsp;                    throw new SnapDataException(ex, ERR_ROLLBACK_AZURESYNAPSE_BULK_LOAD)
<i class="no-highlight">6080</i>&nbsp;                            .withReason(sanitizeAzureSynapseErrorMessage(ex))
<i class="no-highlight">6081</i>&nbsp;                            .withResolution(CONTACT_SUPPORT);
<i class="no-highlight">6082</i>&nbsp;                }
<i class="no-highlight">6083</i>&nbsp;            }
<i class="no-highlight">6084</i>&nbsp;        }
<b class="nc"><i class="no-highlight">6085</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">6086</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6087</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">6088</i>&nbsp;     String buildCreateBackUpTableQueryBasedOnOriginalTableDdlScript(String backUpTableName){</b>
<b class="nc"><i class="no-highlight">6089</i>&nbsp;        dbConnection = jdbcOperations.acquireConnection(account);</b>
<i class="no-highlight">6090</i>&nbsp;        final String columnsDefString =
<i class="no-highlight">6091</i>&nbsp;                AzureSynapseUtils.getColumnsDataForTableTypeAzureSynapse(databaseName,
<i class="no-highlight">6092</i>&nbsp;                schemaName, getNonQualifiedTableName(), jdbcOperations.acquireConnection(account));
<i class="no-highlight">6093</i>&nbsp;        final String distribution = &quot;DISTRIBUTION = &quot; +
<b class="nc"><i class="no-highlight">6094</i>&nbsp;                AzureSynapseUtils.getAzureSynapseDistribution(</b>
<b class="nc"><i class="no-highlight">6095</i>&nbsp;                        jdbcOperations.acquireConnection(account), targetTablePath);</b>
<i class="no-highlight">6096</i>&nbsp;        final String partition =
<i class="no-highlight">6097</i>&nbsp;                AzureSynapseUtils.getAzureSynapsePartition(
<b class="nc"><i class="no-highlight">6098</i>&nbsp;                        jdbcOperations.acquireConnection(account), targetTablePath);</b>
<b class="nc"><i class="no-highlight">6099</i>&nbsp;        final String tableStructure =</b>
<b class="nc"><i class="no-highlight">6100</i>&nbsp;                AzureSynapseUtils.getAzureSynapseTableStructure(</b>
<b class="nc"><i class="no-highlight">6101</i>&nbsp;                        jdbcOperations.acquireConnection(account), targetTablePath);</b>
<b class="nc"><i class="no-highlight">6102</i>&nbsp;        final String tableOptions =</b>
<i class="no-highlight">6103</i>&nbsp;                tableStructure.concat(COMMA_SPACE)
<i class="no-highlight">6104</i>&nbsp;                        .concat(distribution)
<b class="nc"><i class="no-highlight">6105</i>&nbsp;                        .concat(StringUtils.isNotBlank(partition) ?</b>
<i class="no-highlight">6106</i>&nbsp;                                COMMA_SPACE.concat(partition) : &quot;&quot;);
<b class="nc"><i class="no-highlight">6107</i>&nbsp;        return String.format(DDL_SCRIPT, backUpTableName, columnsDefString,</b>
<b class="nc"><i class="no-highlight">6108</i>&nbsp;                AzureSynapseUtils.getAzureSynapseTableConstraints(</b>
<b class="nc"><i class="no-highlight">6109</i>&nbsp;                        jdbcOperations.acquireConnection(account), targetTablePath), tableOptions);</b>
<i class="no-highlight">6110</i>&nbsp;    }
<b class="nc"><i class="no-highlight">6111</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6112</i>&nbsp;    private void executeDropCreateTableBulkLoadAzureSynapse() {</b>
<i class="no-highlight">6113</i>&nbsp;        boolean isRenamedTableDropped = false;
<b class="nc"><i class="no-highlight">6114</i>&nbsp;        boolean isTargetTableRenamed = false;</b>
<b class="nc"><i class="no-highlight">6115</i>&nbsp;        boolean isTargetTableCreated = false;</b>
<i class="no-highlight">6116</i>&nbsp;        String renamedTargetTableName = getDerivedTableName();
<b class="nc"><i class="no-highlight">6117</i>&nbsp;        setAutoCommitLevel(true);</b>
<i class="no-highlight">6118</i>&nbsp;        shouldRollbackOrCommit = false;
<b class="nc"><i class="no-highlight">6119</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6120</i>&nbsp;        try {</b>
<i class="no-highlight">6121</i>&nbsp;            // The sequence of operations should not be changed here:
<b class="nc"><i class="no-highlight">6122</i>&nbsp;            // Only create table if not present, in validation mode. Do nothing else.</b>
<b class="nc"><i class="no-highlight">6123</i>&nbsp;            // In execution mode, if table already exists, rename it and create a new tgt table</b>
<b class="nc"><i class="no-highlight">6124</i>&nbsp;            // 1. rename existing target table</b>
<b class="nc"><i class="no-highlight">6125</i>&nbsp;            // 2. create target table</b>
<b class="nc"><i class="no-highlight">6126</i>&nbsp;            // 3. execute load</b>
<b class="nc"><i class="no-highlight">6127</i>&nbsp;            // 4. drop renamed table if all the above succeed</b>
<b class="nc"><i class="no-highlight">6128</i>&nbsp;            if (validationInProgress) {</b>
<i class="no-highlight">6129</i>&nbsp;                if (!doesTableExist) {
<i class="no-highlight">6130</i>&nbsp;                    sqlCreateTable = buildCreateTableSql();
<i class="no-highlight">6131</i>&nbsp;                    executedQueries.add(sqlCreateTable);
<b class="nc"><i class="no-highlight">6132</i>&nbsp;                    statistic.addQueryStatistic(</b>
<i class="no-highlight">6133</i>&nbsp;                            new QueryStatisticHolderBuilder(sqlCreateTable).build());
<b class="nc"><i class="no-highlight">6134</i>&nbsp;                    executeSqlStmt(sqlCreateTable, bindValues, account);</b>
<i class="no-highlight">6135</i>&nbsp;                    doesTableExist = true;
<b class="nc"><i class="no-highlight">6136</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">6137</i>&nbsp;                return;</b>
<b class="nc"><i class="no-highlight">6138</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">6139</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6140</i>&nbsp;            if (doesTableExist) {</b>
<b class="nc"><i class="no-highlight">6141</i>&nbsp;                sqlRenameTable = buildAzureSynapseRenameTableSql(targetTablePath,</b>
<b class="nc"><i class="no-highlight">6142</i>&nbsp;                        renamedTargetTableName);</b>
<b class="nc"><i class="no-highlight">6143</i>&nbsp;                executeSqlStmt(sqlRenameTable, bindValues, account);</b>
<i class="no-highlight">6144</i>&nbsp;                isTargetTableRenamed = true;
<i class="no-highlight">6145</i>&nbsp;            }
<b class="nc"><i class="no-highlight">6146</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6147</i>&nbsp;            sqlCreateTable = buildCreateTableSql();</b>
<b class="nc"><i class="no-highlight">6148</i>&nbsp;            executedQueries.add(sqlCreateTable);</b>
<b class="nc"><i class="no-highlight">6149</i>&nbsp;            statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">6150</i>&nbsp;                    new QueryStatisticHolderBuilder(sqlCreateTable).build());</b>
<i class="no-highlight">6151</i>&nbsp;            executeSqlStmt(sqlCreateTable, bindValues, account);
<i class="no-highlight">6152</i>&nbsp;            isTargetTableCreated = true;
<b class="nc"><i class="no-highlight">6153</i>&nbsp;</b>
<i class="no-highlight">6154</i>&nbsp;            executedQueries.add(sqlBulkLoad);
<b class="nc"><i class="no-highlight">6155</i>&nbsp;            int numberOfInserts =</b>
<b class="nc"><i class="no-highlight">6156</i>&nbsp;                    executeStatement(sqlBulkLoad, null, account);</b>
<i class="no-highlight">6157</i>&nbsp;
<b class="nc"><i class="no-highlight">6158</i>&nbsp;            statistic.addNumberOfInserts(numberOfInserts);</b>
<i class="no-highlight">6159</i>&nbsp;            statistic.addQueryStatistic(
<i class="no-highlight">6160</i>&nbsp;                    new QueryStatisticHolderBuilder(sqlBulkLoad)
<i class="no-highlight">6161</i>&nbsp;                            .setNumberOfInserts(numberOfInserts)
<i class="no-highlight">6162</i>&nbsp;                            .build());
<i class="no-highlight">6163</i>&nbsp;
<i class="no-highlight">6164</i>&nbsp;            if (isTargetTableRenamed) {
<i class="no-highlight">6165</i>&nbsp;                sqlDropTable = buildDropTableSql(renamedTargetTableName);
<i class="no-highlight">6166</i>&nbsp;                executeSqlStmt(sqlDropTable, bindValues, account);
<i class="no-highlight">6167</i>&nbsp;                isRenamedTableDropped = true;
<i class="no-highlight">6168</i>&nbsp;            }
<i class="no-highlight">6169</i>&nbsp;        } catch (Exception e) {
<i class="no-highlight">6170</i>&nbsp;            try {
<i class="no-highlight">6171</i>&nbsp;                if (isTargetTableCreated) {
<i class="no-highlight">6172</i>&nbsp;                    sqlDropTable = buildDropTableSql(targetTablePath);
<i class="no-highlight">6173</i>&nbsp;                    executeSqlStmt(sqlDropTable, bindValues, account);
<i class="no-highlight">6174</i>&nbsp;                }
<i class="no-highlight">6175</i>&nbsp;
<i class="no-highlight">6176</i>&nbsp;                if (isTargetTableRenamed) {
<b class="nc"><i class="no-highlight">6177</i>&nbsp;                    sqlRenameTable = buildAzureSynapseRenameTableSql(renamedTargetTableName,</b>
<b class="nc"><i class="no-highlight">6178</i>&nbsp;                            getNonQualifiedTableName());</b>
<b class="nc"><i class="no-highlight">6179</i>&nbsp;                    executeSqlStmt(sqlRenameTable, bindValues, account);</b>
<b class="nc"><i class="no-highlight">6180</i>&nbsp;                    isRenamedTableDropped = true;</b>
<i class="no-highlight">6181</i>&nbsp;                }
<b class="nc"><i class="no-highlight">6182</i>&nbsp;            } catch (Exception ex) {</b>
<b class="nc"><i class="no-highlight">6183</i>&nbsp;                if (!isRenamedTableDropped) {</b>
<b class="nc"><i class="no-highlight">6184</i>&nbsp;                    sqlDropTable = buildDropTableSql(renamedTargetTableName);</b>
<b class="nc"><i class="no-highlight">6185</i>&nbsp;                    try {</b>
<b class="nc"><i class="no-highlight">6186</i>&nbsp;                        executeSqlStmt(sqlDropTable, bindValues, account);</b>
<i class="no-highlight">6187</i>&nbsp;                    } catch (Exception ex1) {
<i class="no-highlight">6188</i>&nbsp;                        handleFailures(ERR_BULK_LOAD);
<i class="no-highlight">6189</i>&nbsp;                        throw new SnapDataException(ex1, ERR_ROLLBACK_AZURESYNAPSE_BULK_LOAD)
<i class="no-highlight">6190</i>&nbsp;                                .withReason(sanitizeAzureSynapseErrorMessage(ex1))
<i class="no-highlight">6191</i>&nbsp;                                .withResolution(CONTACT_SUPPORT);
<b class="nc"><i class="no-highlight">6192</i>&nbsp;                    }</b>
<i class="no-highlight">6193</i>&nbsp;                }
<i class="no-highlight">6194</i>&nbsp;                handleFailures(ERR_BULK_LOAD);
<i class="no-highlight">6195</i>&nbsp;                throw new SnapDataException(ex, ERR_ROLLBACK_AZURESYNAPSE_BULK_LOAD)
<i class="no-highlight">6196</i>&nbsp;                        .withReason(sanitizeAzureSynapseErrorMessage(ex))
<i class="no-highlight">6197</i>&nbsp;                        .withResolution(CONTACT_SUPPORT);
<i class="no-highlight">6198</i>&nbsp;            }
<i class="no-highlight">6199</i>&nbsp;            handleFailures(ERR_BULK_LOAD);
<i class="no-highlight">6200</i>&nbsp;            throw new SnapDataException(e, ERR_BULK_LOAD)
<i class="no-highlight">6201</i>&nbsp;                    .withReason(sanitizeAzureSynapseErrorMessage(e))
<i class="no-highlight">6202</i>&nbsp;                    .withResolution(RESOLUTION_BULK_LOAD);
<i class="no-highlight">6203</i>&nbsp;        }
<i class="no-highlight">6204</i>&nbsp;    }
<b class="nc"><i class="no-highlight">6205</i>&nbsp;</b>
<i class="no-highlight">6206</i>&nbsp;    private void buildRollbackAlterTableSql() {
<i class="no-highlight">6207</i>&nbsp;        List&lt;String&gt; dropColumnsList = new ArrayList&lt;&gt;();
<i class="no-highlight">6208</i>&nbsp;        for (int indx = 0; indx &lt; alterColumnModifiers.size(); indx++) {
<i class="no-highlight">6209</i>&nbsp;            if (StringUtils.equals(alterColumnModifiers.get(indx), ADD)) {
<i class="no-highlight">6210</i>&nbsp;                dropColumnsList.add(targetColumns.get(indx));
<b class="nc"><i class="no-highlight">6211</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">6212</i>&nbsp;        }</b>
<i class="no-highlight">6213</i>&nbsp;        if (CollectionUtils.isNotEmpty(dropColumnsList)) {
<i class="no-highlight">6214</i>&nbsp;            sqlAlterTableDropColumns =
<b class="nc"><i class="no-highlight">6215</i>&nbsp;                    String.format(ALTER_TABLE_DROP_SQL_AZURESYNAPSE_FMT, targetTablePath,</b>
<i class="no-highlight">6216</i>&nbsp;                            StringUtils.join(dropColumnsList, COMMA_SPACE));
<b class="nc"><i class="no-highlight">6217</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">6218</i>&nbsp;</b>
<i class="no-highlight">6219</i>&nbsp;    }
<i class="no-highlight">6220</i>&nbsp;
<i class="no-highlight">6221</i>&nbsp;    //********** DLP METHODS *************//
<b class="nc"><i class="no-highlight">6222</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6223</i>&nbsp;    private void executeDLPBulkLoadWithRollback() {</b>
<i class="no-highlight">6224</i>&nbsp;        if (StringUtils.equalsIgnoreCase(loadAction, DROP_CREATE_TABLE)) {
<b class="nc"><i class="no-highlight">6225</i>&nbsp;            executeDropCreateTableBulkLoadDLP();</b>
<b class="nc"><i class="no-highlight">6226</i>&nbsp;        } else if (StringUtils.equalsIgnoreCase(loadAction, ALTER_TABLE)) {</b>
<b class="nc"><i class="no-highlight">6227</i>&nbsp;            executeAlterTableBulkLoadDLP();</b>
<b class="nc"><i class="no-highlight">6228</i>&nbsp;        } else if (StringUtils.equalsIgnoreCase(loadAction, OVERWRITE_TABLE)) {</b>
<b class="nc"><i class="no-highlight">6229</i>&nbsp;            executeOverwriteTableBulkLoadDLP();</b>
<i class="no-highlight">6230</i>&nbsp;        } else if (StringUtils.equals(loadAction, APPEND_ROWS_TABLE)) {
<b class="nc"><i class="no-highlight">6231</i>&nbsp;            executeAppendToTableBulkLoadDLP();</b>
<b class="nc"><i class="no-highlight">6232</i>&nbsp;        }</b>
<i class="no-highlight">6233</i>&nbsp;    }
<i class="no-highlight">6234</i>&nbsp;
<b class="nc"><i class="no-highlight">6235</i>&nbsp;    private void executeDropCreateTableBulkLoadDLP() {</b>
<b class="nc"><i class="no-highlight">6236</i>&nbsp;        validateCsvFileColumNames(toUpperCase(targetColumns));</b>
<i class="no-highlight">6237</i>&nbsp;
<b class="nc"><i class="no-highlight">6238</i>&nbsp;        String backupTargetTableName = StringUtils.EMPTY;</b>
<i class="no-highlight">6239</i>&nbsp;        boolean isTargetTableRenamed = false;
<b class="nc"><i class="no-highlight">6240</i>&nbsp;        try {</b>
<i class="no-highlight">6241</i>&nbsp;            // The sequence of operations should not be changed here:
<i class="no-highlight">6242</i>&nbsp;            // In validation mode,
<b class="nc"><i class="no-highlight">6243</i>&nbsp;            //  - if target table not present then create it</b>
<b class="nc"><i class="no-highlight">6244</i>&nbsp;            //  - return</b>
<b class="nc"><i class="no-highlight">6245</i>&nbsp;            // In execution mode,</b>
<b class="nc"><i class="no-highlight">6246</i>&nbsp;            //  - if table already exists, then rename/backup it and</b>
<i class="no-highlight">6247</i>&nbsp;            //  - create a new tgt table
<b class="nc"><i class="no-highlight">6248</i>&nbsp;            //  - load (copy into) operation</b>
<b class="nc"><i class="no-highlight">6249</i>&nbsp;            //  - drop renamed table if all the above succeed else rollback</b>
<i class="no-highlight">6250</i>&nbsp;
<b class="nc"><i class="no-highlight">6251</i>&nbsp;            //=========================</b>
<b class="nc"><i class="no-highlight">6252</i>&nbsp;            // Validation/Preview mode</b>
<i class="no-highlight">6253</i>&nbsp;            //=========================
<b class="nc"><i class="no-highlight">6254</i>&nbsp;            if (validationInProgress) {</b>
<i class="no-highlight">6255</i>&nbsp;                if (!doesTableExist) {
<i class="no-highlight">6256</i>&nbsp;                    sqlCreateTable = buildDLPCreateOrReplaceTableSql(targetTablePath,
<b class="nc"><i class="no-highlight">6257</i>&nbsp;                            buildColumnWithDataTypeCreateTable(targetColumns, targetDataTypes),</b>
<i class="no-highlight">6258</i>&nbsp;                            eltDatabaseAccount, tableOptions);
<i class="no-highlight">6259</i>&nbsp;                    executedQueries.add(sqlCreateTable);
<i class="no-highlight">6260</i>&nbsp;                    statistic.addQueryStatistic(
<i class="no-highlight">6261</i>&nbsp;                            new QueryStatisticHolderBuilder(sqlCreateTable).build());
<i class="no-highlight">6262</i>&nbsp;                    executeSqlStmt(sqlCreateTable, bindValues, account);
<i class="no-highlight">6263</i>&nbsp;                    doesTableExist = true;
<i class="no-highlight">6264</i>&nbsp;                }
<b class="nc"><i class="no-highlight">6265</i>&nbsp;                return;</b>
<b class="nc"><i class="no-highlight">6266</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">6267</i>&nbsp;</b>
<i class="no-highlight">6268</i>&nbsp;            //====================
<i class="no-highlight">6269</i>&nbsp;            // Execution mode
<b class="nc"><i class="no-highlight">6270</i>&nbsp;            //====================</b>
<b class="nc"><i class="no-highlight">6271</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6272</i>&nbsp;            // 1) DROP table operation : if table exists - instead of drop table, rename/backup it</b>
<b class="nc"><i class="no-highlight">6273</i>&nbsp;            // in case we have to do manual rollback</b>
<b class="nc"><i class="no-highlight">6274</i>&nbsp;            if (doesTableExist) {</b>
<b class="nc"><i class="no-highlight">6275</i>&nbsp;                backupTargetTableName = getTempTableName();</b>
<i class="no-highlight">6276</i>&nbsp;                sqlRenameTable = buildDLPRenameTableSql(targetTablePath, backupTargetTableName);
<i class="no-highlight">6277</i>&nbsp;                executeSqlStmt(sqlRenameTable, bindValues, account);
<i class="no-highlight">6278</i>&nbsp;                isTargetTableRenamed = true;
<b class="nc"><i class="no-highlight">6279</i>&nbsp;            }</b>
<i class="no-highlight">6280</i>&nbsp;
<b class="nc"><i class="no-highlight">6281</i>&nbsp;            // 2) CREATE table operation : If existed it is renamed above already, now</b>
<b class="nc"><i class="no-highlight">6282</i>&nbsp;            // create the table with newly specified schema</b>
<b class="nc"><i class="no-highlight">6283</i>&nbsp;            sqlCreateTable = buildDLPCreateOrReplaceTableSql(targetTablePath,</b>
<b class="nc"><i class="no-highlight">6284</i>&nbsp;                    buildColumnWithDataTypeCreateTable(</b>
<b class="nc"><i class="no-highlight">6285</i>&nbsp;                            targetColumnsWithBacktick, targetDataTypes),</b>
<b class="nc"><i class="no-highlight">6286</i>&nbsp;                    eltDatabaseAccount, tableOptions);</b>
<i class="no-highlight">6287</i>&nbsp;            executedQueries.add(sqlCreateTable);
<i class="no-highlight">6288</i>&nbsp;            statistic.addQueryStatistic(
<b class="nc"><i class="no-highlight">6289</i>&nbsp;                    new QueryStatisticHolderBuilder(sqlCreateTable).build());</b>
<b class="nc"><i class="no-highlight">6290</i>&nbsp;            executeSqlStmt(sqlCreateTable, bindValues, account);</b>
<b class="nc"><i class="no-highlight">6291</i>&nbsp;            isCreateTargetTable = true;</b>
<b class="nc"><i class="no-highlight">6292</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6293</i>&nbsp;            // 3) LOAD table (COPY INTO) operation</b>
<b class="nc"><i class="no-highlight">6294</i>&nbsp;            replaceColumnDefinitionsForSqlBulkLoadQuery();</b>
<i class="no-highlight">6295</i>&nbsp;//            executeSqlStmt(sqlBulkLoad, null, account);
<i class="no-highlight">6296</i>&nbsp;            executedQueries.add(sqlBulkLoad);
<i class="no-highlight">6297</i>&nbsp;            int numberOfInserts =
<b class="nc"><i class="no-highlight">6298</i>&nbsp;                    executeStatement(sqlBulkLoad, null, account);</b>
<i class="no-highlight">6299</i>&nbsp;
<i class="no-highlight">6300</i>&nbsp;            statistic.addNumberOfInserts(numberOfInserts);
<i class="no-highlight">6301</i>&nbsp;            statistic.addQueryStatistic(
<i class="no-highlight">6302</i>&nbsp;                    new QueryStatisticHolderBuilder(sqlBulkLoad)
<i class="no-highlight">6303</i>&nbsp;                            .setNumberOfInserts(numberOfInserts)
<i class="no-highlight">6304</i>&nbsp;                            .build());
<b class="nc"><i class="no-highlight">6305</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6306</i>&nbsp;        } catch (Exception e) {</b>
<b class="nc"><i class="no-highlight">6307</i>&nbsp;            // Rollback CREATE table operation</b>
<b class="nc"><i class="no-highlight">6308</i>&nbsp;            if (isCreateTargetTable) {</b>
<b class="nc"><i class="no-highlight">6309</i>&nbsp;                sqlDropTable = buildDropTableSql(targetTablePath);</b>
<b class="nc"><i class="no-highlight">6310</i>&nbsp;                try {</b>
<b class="nc"><i class="no-highlight">6311</i>&nbsp;                    executeSqlStmt(sqlDropTable, bindValues, account);</b>
<i class="no-highlight">6312</i>&nbsp;                } catch (Exception ex) {
<i class="no-highlight">6313</i>&nbsp;                    handleFailures(ERR_ROLLBACK_BULK_LOAD_TABLE);
<b class="nc"><i class="no-highlight">6314</i>&nbsp;                    throw new SnapDataException(ex, ERR_ROLLBACK_BULK_LOAD_TABLE)</b>
<i class="no-highlight">6315</i>&nbsp;                            .withReason(ex.getMessage())
<i class="no-highlight">6316</i>&nbsp;                            .withResolution(CONTACT_SUPPORT);
<i class="no-highlight">6317</i>&nbsp;                }
<i class="no-highlight">6318</i>&nbsp;            }
<b class="nc"><i class="no-highlight">6319</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6320</i>&nbsp;            // Rollback RENAME table operation</b>
<i class="no-highlight">6321</i>&nbsp;            if (isTargetTableRenamed) {
<i class="no-highlight">6322</i>&nbsp;                // rename backup table to target table name
<b class="nc"><i class="no-highlight">6323</i>&nbsp;                sqlRenameTable = buildDLPRenameTableSql(backupTargetTableName, targetTablePath);</b>
<b class="nc"><i class="no-highlight">6324</i>&nbsp;                try {</b>
<b class="nc"><i class="no-highlight">6325</i>&nbsp;                    executeSqlStmt(sqlRenameTable, bindValues, account);</b>
<b class="nc"><i class="no-highlight">6326</i>&nbsp;                    isTargetTableRenamed = false; // setting false as no more renaming needed</b>
<i class="no-highlight">6327</i>&nbsp;                } catch (SQLException sqle) {
<b class="nc"><i class="no-highlight">6328</i>&nbsp;                    handleFailures(ERR_ROLLBACK_BULK_LOAD_TABLE);</b>
<b class="nc"><i class="no-highlight">6329</i>&nbsp;                    throw new SnapDataException(sqle, ERR_ROLLBACK_BULK_LOAD_TABLE)</b>
<i class="no-highlight">6330</i>&nbsp;                            .withReason(e.getMessage())
<i class="no-highlight">6331</i>&nbsp;                            .withResolution(CONTACT_SUPPORT);
<i class="no-highlight">6332</i>&nbsp;                }
<i class="no-highlight">6333</i>&nbsp;            }
<i class="no-highlight">6334</i>&nbsp;
<i class="no-highlight">6335</i>&nbsp;            handleFailures(ERR_BULK_LOAD);
<i class="no-highlight">6336</i>&nbsp;            String error = StringUtils.isNotBlank(e.toString()) ? e.toString() : ERR_BULK_LOAD;
<i class="no-highlight">6337</i>&nbsp;            throw new SnapDataException(e, error)
<i class="no-highlight">6338</i>&nbsp;                    .withReason(getErrorReason(e, ERR_BULK_LOAD))
<i class="no-highlight">6339</i>&nbsp;                    .withResolution(getErrorResolution(e, CONTACT_SUPPORT));
<i class="no-highlight">6340</i>&nbsp;        } finally {
<i class="no-highlight">6341</i>&nbsp;            // finally if table was renamed/backedup, it needs to be dropped as part of cleanup
<i class="no-highlight">6342</i>&nbsp;            if (isTargetTableRenamed) {
<i class="no-highlight">6343</i>&nbsp;                try {
<i class="no-highlight">6344</i>&nbsp;                    dropTable(backupTargetTableName, bindValues);
<b class="nc"><i class="no-highlight">6345</i>&nbsp;                } catch (Exception e) {}</b>
<i class="no-highlight">6346</i>&nbsp;            }
<i class="no-highlight">6347</i>&nbsp;        }
<i class="no-highlight">6348</i>&nbsp;    }
<b class="nc"><i class="no-highlight">6349</i>&nbsp;</b>
<i class="no-highlight">6350</i>&nbsp;    private void executeAlterTableBulkLoadDLP() {
<i class="no-highlight">6351</i>&nbsp;        try {
<i class="no-highlight">6352</i>&nbsp;            // The sequence of operations should not be changed here:
<b class="nc"><i class="no-highlight">6353</i>&nbsp;            // In validation/preview or execution mode</b>
<i class="no-highlight">6354</i>&nbsp;            //  - if target table not present then throw exception
<b class="nc"><i class="no-highlight">6355</i>&nbsp;            // In validation mode,</b>
<b class="nc"><i class="no-highlight">6356</i>&nbsp;            //  - no op</b>
<i class="no-highlight">6357</i>&nbsp;            //  - return
<i class="no-highlight">6358</i>&nbsp;            // In execution mode,
<i class="no-highlight">6359</i>&nbsp;            //  - here table already exists
<b class="nc"><i class="no-highlight">6360</i>&nbsp;            //  - retrieve max version from delta table, in case we need to rollback</b>
<b class="nc"><i class="no-highlight">6361</i>&nbsp;            //    the alter table operation</b>
<i class="no-highlight">6362</i>&nbsp;            //  - perform alter table operation
<i class="no-highlight">6363</i>&nbsp;            //  - load (copy into) operation
<i class="no-highlight">6364</i>&nbsp;
<i class="no-highlight">6365</i>&nbsp;            // Assert that table exists
<b class="nc"><i class="no-highlight">6366</i>&nbsp;            if (!doesTableExist) {</b>
<b class="nc"><i class="no-highlight">6367</i>&nbsp;                throwExceptionIfNotDropAndCreateLoadAction();</b>
<b class="nc"><i class="no-highlight">6368</i>&nbsp;                sqlCreateTable = buildDLPCreateOrReplaceTableSql(targetTablePath,</b>
<b class="nc"><i class="no-highlight">6369</i>&nbsp;                        buildColumnWithDataTypeCreateTable(targetColumns, targetDataTypes),</b>
<b class="nc"><i class="no-highlight">6370</i>&nbsp;                        eltDatabaseAccount, tableOptions);</b>
<b class="nc"><i class="no-highlight">6371</i>&nbsp;                executedQueries.add(sqlCreateTable);</b>
<b class="nc"><i class="no-highlight">6372</i>&nbsp;                statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">6373</i>&nbsp;                        new QueryStatisticHolderBuilder(sqlCreateTable).build());</b>
<i class="no-highlight">6374</i>&nbsp;                executeSqlStmt(sqlCreateTable, bindValues, account);
<i class="no-highlight">6375</i>&nbsp;                doesTableExist = true;
<i class="no-highlight">6376</i>&nbsp;            }
<b class="nc"><i class="no-highlight">6377</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6378</i>&nbsp;            //=========================</b>
<b class="nc"><i class="no-highlight">6379</i>&nbsp;            // Validation/Preview mode</b>
<i class="no-highlight">6380</i>&nbsp;            //=========================
<b class="nc"><i class="no-highlight">6381</i>&nbsp;            if (validationInProgress) {</b>
<b class="nc"><i class="no-highlight">6382</i>&nbsp;                // no op</b>
<b class="nc"><i class="no-highlight">6383</i>&nbsp;                return;</b>
<b class="nc"><i class="no-highlight">6384</i>&nbsp;            }</b>
<i class="no-highlight">6385</i>&nbsp;
<b class="nc"><i class="no-highlight">6386</i>&nbsp;            //====================</b>
<b class="nc"><i class="no-highlight">6387</i>&nbsp;            // Execution mode</b>
<i class="no-highlight">6388</i>&nbsp;            //====================
<b class="nc"><i class="no-highlight">6389</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6390</i>&nbsp;            // 1) Capture the latest version of the table before doing the</b>
<i class="no-highlight">6391</i>&nbsp;            //    delete of all rows in the table in the unlikely event that
<i class="no-highlight">6392</i>&nbsp;            //    we need to rollback the rows in the target table. We would
<b class="nc"><i class="no-highlight">6393</i>&nbsp;            //    use the version number to put back the deleted rows.</b>
<b class="nc"><i class="no-highlight">6394</i>&nbsp;            versionNumber = getDLPLatestTargetTableVersionNumber(targetTablePath,</b>
<b class="nc"><i class="no-highlight">6395</i>&nbsp;                    ERR_BULK_LOAD, ELT_LOAD_TITLE);</b>
<i class="no-highlight">6396</i>&nbsp;
<b class="nc"><i class="no-highlight">6397</i>&nbsp;            // 2) ALTER table operation</b>
<i class="no-highlight">6398</i>&nbsp;            // if drop col present do the following, recreate table without the drop col.
<b class="nc"><i class="no-highlight">6399</i>&nbsp;            // if any cols to be added, add after the above step</b>
<i class="no-highlight">6400</i>&nbsp;            if (isColumnToBeDropped) {
<i class="no-highlight">6401</i>&nbsp;                handleDLPDropColumn(
<b class="nc"><i class="no-highlight">6402</i>&nbsp;                        alterColumnModifiers, targetColumns, targetDataTypes, bindValues,</b>
<b class="nc"><i class="no-highlight">6403</i>&nbsp;                        targetTablePath);</b>
<i class="no-highlight">6404</i>&nbsp;                isTableAltered = true;
<b class="nc"><i class="no-highlight">6405</i>&nbsp;            } else {</b>
<i class="no-highlight">6406</i>&nbsp;                sqlDLPAlterTableList =
<i class="no-highlight">6407</i>&nbsp;                        buildDLPAlterTableSqls(targetColumnsWithBacktick,
<i class="no-highlight">6408</i>&nbsp;                                targetDataTypes, alterColumnModifiers,
<i class="no-highlight">6409</i>&nbsp;                                               targetTablePath,
<b class="nc"><i class="no-highlight">6410</i>&nbsp;                                               ALTER_TABLE_ADD_COLUMNS_SQL_DLP_FMT);</b>
<b class="nc"><i class="no-highlight">6411</i>&nbsp;                executedQueries.add(collectionToString(sqlDLPAlterTableList));</b>
<b class="nc"><i class="no-highlight">6412</i>&nbsp;                statistic.addQueryStatistic(</b>
<i class="no-highlight">6413</i>&nbsp;                        new QueryStatisticHolderBuilder(
<b class="nc"><i class="no-highlight">6414</i>&nbsp;                                collectionToString(sqlDLPAlterTableList)).build());</b>
<i class="no-highlight">6415</i>&nbsp;                for (String dlpAlterSql : sqlDLPAlterTableList) {
<i class="no-highlight">6416</i>&nbsp;                    executeSqlStmt(dlpAlterSql, bindValues, account);
<b class="nc"><i class="no-highlight">6417</i>&nbsp;                    isTableAltered = true;</b>
<b class="nc"><i class="no-highlight">6418</i>&nbsp;                }</b>
<i class="no-highlight">6419</i>&nbsp;            }
<b class="nc"><i class="no-highlight">6420</i>&nbsp;            if (!isDLPTableDeltaFormat(targetTablePath)) {</b>
<i class="no-highlight">6421</i>&nbsp;                throwInvalidTableFormat(ELT_LOAD_TITLE);
<i class="no-highlight">6422</i>&nbsp;            }
<i class="no-highlight">6423</i>&nbsp;
<i class="no-highlight">6424</i>&nbsp;            validateCsvFileColumNames(toUpperCase(
<b class="nc"><i class="no-highlight">6425</i>&nbsp;                    getTableColumnNameDataTypeMap(targetTablePath).keySet()));</b>
<b class="nc"><i class="no-highlight">6426</i>&nbsp;</b>
<i class="no-highlight">6427</i>&nbsp;            hasAlterTableBeenExecuted = true;
<i class="no-highlight">6428</i>&nbsp;            // 3) Complete building COPY INTO SQL statement
<i class="no-highlight">6429</i>&nbsp;            buildSqlBulkLoadStringForAlterTableAfterLoadAction();
<i class="no-highlight">6430</i>&nbsp;
<i class="no-highlight">6431</i>&nbsp;            // 4) LOAD Table (COPY INTO) operation
<b class="nc"><i class="no-highlight">6432</i>&nbsp;            replaceColumnDefinitionsForSqlBulkLoadQuery();</b>
<b class="nc"><i class="no-highlight">6433</i>&nbsp;            executedQueries.add(sqlBulkLoad);</b>
<b class="nc"><i class="no-highlight">6434</i>&nbsp;            int numberOfInserts =</b>
<b class="nc"><i class="no-highlight">6435</i>&nbsp;                    executeStatement(sqlBulkLoad, null, account);</b>
<b class="nc"><i class="no-highlight">6436</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6437</i>&nbsp;            statistic.addNumberOfInserts(numberOfInserts);</b>
<i class="no-highlight">6438</i>&nbsp;            statistic.addQueryStatistic(
<b class="nc"><i class="no-highlight">6439</i>&nbsp;                    new QueryStatisticHolderBuilder(sqlBulkLoad)</b>
<i class="no-highlight">6440</i>&nbsp;                            .setNumberOfInserts(numberOfInserts)
<i class="no-highlight">6441</i>&nbsp;                            .build());
<i class="no-highlight">6442</i>&nbsp;
<i class="no-highlight">6443</i>&nbsp;        } catch (Exception e) {
<i class="no-highlight">6444</i>&nbsp;            // in case of any failure, restore target table to version before we performed an
<i class="no-highlight">6445</i>&nbsp;            // alter operation
<i class="no-highlight">6446</i>&nbsp;            if (isTableAltered) {
<i class="no-highlight">6447</i>&nbsp;                try {
<i class="no-highlight">6448</i>&nbsp;                    //if drop column was done, then the original target table does not exist anymore
<i class="no-highlight">6449</i>&nbsp;                    //. A new table with the same name and the column dropped is created, so
<i class="no-highlight">6450</i>&nbsp;                    // restoring to a previous version will not work in this case.
<i class="no-highlight">6451</i>&nbsp;                    // So in case of a drop column operation, we take a backup of target table (by
<i class="no-highlight">6452</i>&nbsp;                    // renaming) in BaseElt::handleDLPDropColumn() and use the backup for restoring
<i class="no-highlight">6453</i>&nbsp;                    // to pre failure state.
<i class="no-highlight">6454</i>&nbsp;                    if (isColumnToBeDropped &amp;&amp; isTargetRenamedToBackup) {
<i class="no-highlight">6455</i>&nbsp;                        dropTable(targetTablePath, bindValues);
<i class="no-highlight">6456</i>&nbsp;                        dlpRenameBackupToTargetSql = buildDLPRenameTableSql(backupTargetTableName,
<i class="no-highlight">6457</i>&nbsp;                                                                            targetTablePath);
<i class="no-highlight">6458</i>&nbsp;                        try {
<i class="no-highlight">6459</i>&nbsp;                            executeSqlStmt(dlpRenameBackupToTargetSql, bindValues, account);
<b class="nc"><i class="no-highlight">6460</i>&nbsp;                            isTargetRenamedToBackup = false;</b>
<b class="nc"><i class="no-highlight">6461</i>&nbsp;                        } catch (Exception ex) {</b>
<b class="nc"><i class="no-highlight">6462</i>&nbsp;                            handleFailures(ERR_SCD2);</b>
<i class="no-highlight">6463</i>&nbsp;                            throw new SnapDataException(ex.toString());
<b class="nc"><i class="no-highlight">6464</i>&nbsp;                        }</b>
<b class="nc"><i class="no-highlight">6465</i>&nbsp;                    } else {</b>
<b class="nc"><i class="no-highlight">6466</i>&nbsp;                        //in the non-drop column case, we can use the restore</b>
<b class="nc"><i class="no-highlight">6467</i>&nbsp;                        // to version for rollback</b>
<b class="nc"><i class="no-highlight">6468</i>&nbsp;                        restoreDLPTargetTableToVersion(versionNumber, targetTablePath, bindValues);</b>
<i class="no-highlight">6469</i>&nbsp;                    }
<i class="no-highlight">6470</i>&nbsp;                } catch (Exception ex) {
<b class="nc"><i class="no-highlight">6471</i>&nbsp;                    handleFailures(ERR_ROLLBACK_BULK_LOAD_TABLE);</b>
<b class="nc"><i class="no-highlight">6472</i>&nbsp;                    throw new SnapDataException(ex, ERR_ROLLBACK_BULK_LOAD_TABLE)</b>
<i class="no-highlight">6473</i>&nbsp;                            .withReason(ex.getMessage())
<i class="no-highlight">6474</i>&nbsp;                            .withResolution(CONTACT_SUPPORT);
<i class="no-highlight">6475</i>&nbsp;                }
<i class="no-highlight">6476</i>&nbsp;            }
<b class="nc"><i class="no-highlight">6477</i>&nbsp;</b>
<i class="no-highlight">6478</i>&nbsp;            handleFailures(ERR_BULK_LOAD);
<i class="no-highlight">6479</i>&nbsp;            String error = StringUtils.isNotBlank(e.toString()) ? e.toString() : ERR_BULK_LOAD;
<i class="no-highlight">6480</i>&nbsp;            throw new SnapDataException(e, error)
<i class="no-highlight">6481</i>&nbsp;                    .withReason(getErrorReason(e, ERR_BULK_LOAD))
<i class="no-highlight">6482</i>&nbsp;                    .withResolution(getErrorResolution(e, CONTACT_SUPPORT));
<i class="no-highlight">6483</i>&nbsp;        }
<i class="no-highlight">6484</i>&nbsp;    }
<i class="no-highlight">6485</i>&nbsp;
<i class="no-highlight">6486</i>&nbsp;    private void replaceColumnDefinitionsForSqlBulkLoadQuery() {
<i class="no-highlight">6487</i>&nbsp;        if (isAlterTableAndNonEmptyTargetColumns || OVERWRITE_TABLE.equals(loadAction)) {
<i class="no-highlight">6488</i>&nbsp;            // CAST For type is already done for this case
<i class="no-highlight">6489</i>&nbsp;            // at appendStageFileWithNonEmptyColumnsForAlterTableDLP().
<b class="nc"><i class="no-highlight">6490</i>&nbsp;            // So returns.</b>
<i class="no-highlight">6491</i>&nbsp;            return;
<i class="no-highlight">6492</i>&nbsp;        }
<i class="no-highlight">6493</i>&nbsp;
<b class="nc"><i class="no-highlight">6494</i>&nbsp;        if (!isSourceFileColumnListSizeDifferentFromTarget &amp;&amp;</b>
<b class="nc"><i class="no-highlight">6495</i>&nbsp;                MapUtils.isEmpty(this.columnMappingMap)) {</b>
<i class="no-highlight">6496</i>&nbsp;            sqlBulkLoad =
<b class="nc"><i class="no-highlight">6497</i>&nbsp;                    sqlBulkLoad.replace(</b>
<b class="nc"><i class="no-highlight">6498</i>&nbsp;                            targetColumns.isEmpty() || isSelectClauseAsterisk(sqlBulkLoad) ? &quot;*&quot; :</b>
<i class="no-highlight">6499</i>&nbsp;                                    StringUtils.join(targetColumnsWithBacktick, COMMA),
<b class="nc"><i class="no-highlight">6500</i>&nbsp;                            getColumnsDefinitionsWithCastForType(</b>
<b class="nc"><i class="no-highlight">6501</i>&nbsp;                                    targetTablePath, null));</b>
<b class="nc"><i class="no-highlight">6502</i>&nbsp;        } else {</b>
<b class="nc"><i class="no-highlight">6503</i>&nbsp;            replaceColumnDefinitionsForSqlBulkLoadQueryWhenSourceIsSubset();</b>
<i class="no-highlight">6504</i>&nbsp;        }
<i class="no-highlight">6505</i>&nbsp;    }
<i class="no-highlight">6506</i>&nbsp;
<i class="no-highlight">6507</i>&nbsp;    private boolean isSelectClauseAsterisk(String sqlBulkLoadSqlString) {
<i class="no-highlight">6508</i>&nbsp;        if (StringUtils.isEmpty(sqlBulkLoadSqlString)) {
<i class="no-highlight">6509</i>&nbsp;            return false;
<b class="nc"><i class="no-highlight">6510</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">6511</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6512</i>&nbsp;        int begin = sqlBulkLoadSqlString.indexOf(SELECT_STATEMENT) + SELECT_STATEMENT.length();</b>
<b class="nc"><i class="no-highlight">6513</i>&nbsp;        int end = sqlBulkLoadSqlString.indexOf(FROM_STRING, begin + 1);</b>
<i class="no-highlight">6514</i>&nbsp;        if (begin &lt; 0 || end &lt; 0) {
<b class="nc"><i class="no-highlight">6515</i>&nbsp;            return false;</b>
<b class="nc"><i class="no-highlight">6516</i>&nbsp;        }</b>
<i class="no-highlight">6517</i>&nbsp;        String between = sqlBulkLoadSqlString.substring(begin + 1, end).trim();
<b class="nc"><i class="no-highlight">6518</i>&nbsp;        return between.length() == 1 &amp;&amp; StringUtils.equals(between, &quot;*&quot;);</b>
<b class="nc"><i class="no-highlight">6519</i>&nbsp;    }</b>
<i class="no-highlight">6520</i>&nbsp;
<b class="nc"><i class="no-highlight">6521</i>&nbsp;    /**</b>
<b class="nc"><i class="no-highlight">6522</i>&nbsp;     * This method replaces DATE or BINARY type column with CAST substring</b>
<b class="nc"><i class="no-highlight">6523</i>&nbsp;     * to cover the cases when the number of the source table columns is less than</b>
<i class="no-highlight">6524</i>&nbsp;     * that of the target table columns.
<b class="nc"><i class="no-highlight">6525</i>&nbsp;     *</b>
<i class="no-highlight">6526</i>&nbsp;     * New unit tests are created to cover CSV and JSON format cases and
<i class="no-highlight">6527</i>&nbsp;     * the case where binary type column is an extra column from the target table:
<b class="nc"><i class="no-highlight">6528</i>&nbsp;     * Please look at the unit tests (and the comments) below:</b>
<i class="no-highlight">6529</i>&nbsp;     * testBulkLoadDropCreateTableLessJsonSourceFileFieldsBinaryDLP
<i class="no-highlight">6530</i>&nbsp;     * testBulkLoadDropCreateTableLessCsvSourceFileFieldsBinaryDLP
<b class="nc"><i class="no-highlight">6531</i>&nbsp;     * testBulkLoadDropCreateTableLessCsvSourceFileFieldsNoBinaryDLP</b>
<b class="nc"><i class="no-highlight">6532</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">6533</i>&nbsp;    private void replaceColumnDefinitionsForSqlBulkLoadQueryWhenSourceIsSubset() {</b>
<b class="nc"><i class="no-highlight">6534</i>&nbsp;        Map&lt;String, String&gt; toChangeColumnMap = getColumnMapWithCastForType(</b>
<b class="nc"><i class="no-highlight">6535</i>&nbsp;                targetTablePath, new HashSet&lt;&gt;(this.targetColumns));</b>
<b class="nc"><i class="no-highlight">6536</i>&nbsp;</b>
<i class="no-highlight">6537</i>&nbsp;        // If nothing to replace, just return.
<i class="no-highlight">6538</i>&nbsp;        if (MapUtils.isEmpty(toChangeColumnMap)) {
<i class="no-highlight">6539</i>&nbsp;            return;
<i class="no-highlight">6540</i>&nbsp;        }
<i class="no-highlight">6541</i>&nbsp;
<b class="nc"><i class="no-highlight">6542</i>&nbsp;        StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i class="no-highlight">6543</i>&nbsp;        // Assume column ordering equivalence betewen source and target tables.</b>
<b class="nc"><i class="no-highlight">6544</i>&nbsp;        int beginSubStr = sqlBulkLoad.indexOf(SELECT_STRING);</b>
<i class="no-highlight">6545</i>&nbsp;        if (beginSubStr &lt; 0) {
<b class="nc"><i class="no-highlight">6546</i>&nbsp;            // if &quot;SELECT&quot; is not in the sqlBulkLoad, just return.</b>
<b class="nc"><i class="no-highlight">6547</i>&nbsp;            return;</b>
<b class="nc"><i class="no-highlight">6548</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">6549</i>&nbsp;        beginSubStr += SELECT_STRING.length();</b>
<b class="nc"><i class="no-highlight">6550</i>&nbsp;        beginSubStr = sqlBulkLoad.indexOf(this.targetColumns.get(0), beginSubStr);</b>
<i class="no-highlight">6551</i>&nbsp;        // When &quot;columnMappingMap&quot; is used,
<i class="no-highlight">6552</i>&nbsp;        // first column from &quot;sqlBulkLoad&quot; can be either first target column name or
<b class="nc"><i class="no-highlight">6553</i>&nbsp;        // its corresponding source column name as in &quot;sourceColName AS targetColName&quot;.</b>
<b class="nc"><i class="no-highlight">6554</i>&nbsp;        // Thus find earlier one.</b>
<i class="no-highlight">6555</i>&nbsp;        if (MapUtils.isNotEmpty(columnMappingMap)) {
<i class="no-highlight">6556</i>&nbsp;            String sourceColName = columnMappingMap.get(this.targetColumns.get(0));
<i class="no-highlight">6557</i>&nbsp;            if (StringUtils.isNotBlank(sourceColName)) {
<i class="no-highlight">6558</i>&nbsp;                int tmpBegin =
<b class="nc"><i class="no-highlight">6559</i>&nbsp;                        sqlBulkLoad.indexOf(</b>
<i class="no-highlight">6560</i>&nbsp;                                sourceColName, beginSubStr - SELECT_STRING.length());
<i class="no-highlight">6561</i>&nbsp;                if (tmpBegin &gt; -1) {
<i class="no-highlight">6562</i>&nbsp;                    beginSubStr = tmpBegin;
<i class="no-highlight">6563</i>&nbsp;                }
<i class="no-highlight">6564</i>&nbsp;            }
<i class="no-highlight">6565</i>&nbsp;        }
<i class="no-highlight">6566</i>&nbsp;        int endSubStr = sqlBulkLoad.indexOf(FROM_STRING, beginSubStr);
<i class="no-highlight">6567</i>&nbsp;        String columnSubStr = sqlBulkLoad.substring(beginSubStr, endSubStr);
<b class="nc"><i class="no-highlight">6568</i>&nbsp;        sb.append(sqlBulkLoad.substring(0, beginSubStr));</b>
<b class="nc"><i class="no-highlight">6569</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6570</i>&nbsp;        int begin = 0;</b>
<b class="nc"><i class="no-highlight">6571</i>&nbsp;        int end = 0;</b>
<i class="no-highlight">6572</i>&nbsp;        String colName = EMPTY_STRING;
<b class="nc"><i class="no-highlight">6573</i>&nbsp;        boolean firstField = true;</b>
<b class="nc"><i class="no-highlight">6574</i>&nbsp;        // One typical example case is &quot;col1, col2, null as col3&quot;.</b>
<i class="no-highlight">6575</i>&nbsp;        while (end &lt; columnSubStr.length()) {
<b class="nc"><i class="no-highlight">6576</i>&nbsp;            if (columnSubStr.charAt(end) == &#39;,&#39;) {</b>
<b class="nc"><i class="no-highlight">6577</i>&nbsp;                // Move end pointer for blanks</b>
<b class="nc"><i class="no-highlight">6578</i>&nbsp;                while (columnSubStr.charAt(end + 1) == &#39; &#39;) {</b>
<b class="nc"><i class="no-highlight">6579</i>&nbsp;                    end++;</b>
<b class="nc"><i class="no-highlight">6580</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">6581</i>&nbsp;                // Check and process</b>
<b class="nc"><i class="no-highlight">6582</i>&nbsp;                colName = columnSubStr.substring(begin, end).trim();</b>
<b class="nc"><i class="no-highlight">6583</i>&nbsp;                if (firstField) {</b>
<b class="nc"><i class="no-highlight">6584</i>&nbsp;                    firstField = false;</b>
<i class="no-highlight">6585</i>&nbsp;                } else {
<i class="no-highlight">6586</i>&nbsp;                    sb.append(COMMA);
<i class="no-highlight">6587</i>&nbsp;                }
<i class="no-highlight">6588</i>&nbsp;                appendColumnName(sb, toChangeColumnMap, colName);
<i class="no-highlight">6589</i>&nbsp;
<b class="nc"><i class="no-highlight">6590</i>&nbsp;                // Move indices</b>
<b class="nc"><i class="no-highlight">6591</i>&nbsp;                begin = end + 1;</b>
<b class="nc"><i class="no-highlight">6592</i>&nbsp;                end = begin;</b>
<b class="nc"><i class="no-highlight">6593</i>&nbsp;            } else {</b>
<b class="nc"><i class="no-highlight">6594</i>&nbsp;                end++;</b>
<b class="nc"><i class="no-highlight">6595</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">6596</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6597</i>&nbsp;        }</b>
<i class="no-highlight">6598</i>&nbsp;        // Process last colName
<i class="no-highlight">6599</i>&nbsp;        colName = columnSubStr.substring(begin, end).trim();
<i class="no-highlight">6600</i>&nbsp;        if (!firstField) {
<i class="no-highlight">6601</i>&nbsp;            sb.append(COMMA);
<i class="no-highlight">6602</i>&nbsp;        }
<i class="no-highlight">6603</i>&nbsp;        appendColumnName(sb, toChangeColumnMap, colName);
<i class="no-highlight">6604</i>&nbsp;
<i class="no-highlight">6605</i>&nbsp;        // Append the rest of the string
<i class="no-highlight">6606</i>&nbsp;        sb.append(SPACE);
<i class="no-highlight">6607</i>&nbsp;        sb.append(sqlBulkLoad.substring(endSubStr));
<i class="no-highlight">6608</i>&nbsp;        // Replace
<i class="no-highlight">6609</i>&nbsp;        sqlBulkLoad = sb.toString();
<i class="no-highlight">6610</i>&nbsp;    }
<i class="no-highlight">6611</i>&nbsp;
<i class="no-highlight">6612</i>&nbsp;    private void appendColumnName(
<i class="no-highlight">6613</i>&nbsp;            StringBuilder sb, Map&lt;String, String&gt; map, String colName) {
<i class="no-highlight">6614</i>&nbsp;        if (map.containsKey(colName.toLowerCase())) {
<i class="no-highlight">6615</i>&nbsp;            sb.append(map.get(colName));
<i class="no-highlight">6616</i>&nbsp;        } else {
<i class="no-highlight">6617</i>&nbsp;            // Cover the case when colName is of format
<i class="no-highlight">6618</i>&nbsp;            // &quot;sourceColName AS targetColName&quot;, or &quot;NULL AS targetColName&quot;.
<b class="nc"><i class="no-highlight">6619</i>&nbsp;            // For the former case, we replace with the CAST AS if exists</b>
<b class="nc"><i class="no-highlight">6620</i>&nbsp;            // but for the latter case, we should not replace.</b>
<b class="nc"><i class="no-highlight">6621</i>&nbsp;            String[] strs = colName.split(&quot;[ ]&quot;);</b>
<i class="no-highlight">6622</i>&nbsp;            if (strs.length == 3 &amp;&amp;
<b class="nc"><i class="no-highlight">6623</i>&nbsp;                    !strs[0].equalsIgnoreCase(NULL_STRING) &amp;&amp;</b>
<i class="no-highlight">6624</i>&nbsp;                    strs[1].equalsIgnoreCase(&quot;AS&quot;) &amp;&amp;
<i class="no-highlight">6625</i>&nbsp;                    map.containsKey(strs[2].toLowerCase())) {
<i class="no-highlight">6626</i>&nbsp;                sb.append(map.get(strs[2].toLowerCase()));
<i class="no-highlight">6627</i>&nbsp;            } else {
<i class="no-highlight">6628</i>&nbsp;                sb.append(colName);
<b class="nc"><i class="no-highlight">6629</i>&nbsp;            }</b>
<i class="no-highlight">6630</i>&nbsp;        }
<i class="no-highlight">6631</i>&nbsp;    }
<i class="no-highlight">6632</i>&nbsp;
<b class="nc"><i class="no-highlight">6633</i>&nbsp;    private void executeOverwriteTableBulkLoadDLP() {</b>
<b class="nc"><i class="no-highlight">6634</i>&nbsp;        try {</b>
<i class="no-highlight">6635</i>&nbsp;            // The sequence of operations should not be changed here:
<b class="nc"><i class="no-highlight">6636</i>&nbsp;            // In validation/preview or execution mode</b>
<b class="nc"><i class="no-highlight">6637</i>&nbsp;            //  - if target table not present then throw exception</b>
<b class="nc"><i class="no-highlight">6638</i>&nbsp;            // In validation mode,</b>
<b class="nc"><i class="no-highlight">6639</i>&nbsp;            //  - no op</b>
<i class="no-highlight">6640</i>&nbsp;            //  - return
<i class="no-highlight">6641</i>&nbsp;            // In execution mode,
<b class="nc"><i class="no-highlight">6642</i>&nbsp;            //  - here table already exists</b>
<b class="nc"><i class="no-highlight">6643</i>&nbsp;            //  - retrieve max version from delta table, in case we need to rollback</b>
<i class="no-highlight">6644</i>&nbsp;            //      the delete rows operation
<i class="no-highlight">6645</i>&nbsp;            //  - delete rows
<b class="nc"><i class="no-highlight">6646</i>&nbsp;            //  - load (copy into) operation</b>
<b class="nc"><i class="no-highlight">6647</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6648</i>&nbsp;            // Assert that table exists</b>
<b class="nc"><i class="no-highlight">6649</i>&nbsp;            if (!doesTableExist) {</b>
<b class="nc"><i class="no-highlight">6650</i>&nbsp;                sqlCreateTable = buildDLPCreateOrReplaceTableSql(targetTablePath,</b>
<b class="nc"><i class="no-highlight">6651</i>&nbsp;                        buildColumnWithDataTypeCreateTable(targetColumns, targetDataTypes),</b>
<b class="nc"><i class="no-highlight">6652</i>&nbsp;                        eltDatabaseAccount, tableOptions);</b>
<b class="nc"><i class="no-highlight">6653</i>&nbsp;                executedQueries.add(sqlCreateTable);</b>
<b class="nc"><i class="no-highlight">6654</i>&nbsp;                statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">6655</i>&nbsp;                        new QueryStatisticHolderBuilder(sqlCreateTable).build());</b>
<i class="no-highlight">6656</i>&nbsp;                executeSqlStmt(sqlCreateTable, bindValues, account);
<b class="nc"><i class="no-highlight">6657</i>&nbsp;                doesTableExist = true;</b>
<b class="nc"><i class="no-highlight">6658</i>&nbsp;            }</b>
<i class="no-highlight">6659</i>&nbsp;
<b class="nc"><i class="no-highlight">6660</i>&nbsp;            validateCsvFileColumNames(toUpperCase(</b>
<b class="nc"><i class="no-highlight">6661</i>&nbsp;                    getTableColumnNameDataTypeMap(targetTablePath).keySet()));</b>
<i class="no-highlight">6662</i>&nbsp;
<b class="nc"><i class="no-highlight">6663</i>&nbsp;            //=========================</b>
<b class="nc"><i class="no-highlight">6664</i>&nbsp;            // Validation/Preview mode</b>
<i class="no-highlight">6665</i>&nbsp;            //=========================
<b class="nc"><i class="no-highlight">6666</i>&nbsp;            if (validationInProgress) {</b>
<b class="nc"><i class="no-highlight">6667</i>&nbsp;                // no op</b>
<i class="no-highlight">6668</i>&nbsp;                return;
<i class="no-highlight">6669</i>&nbsp;            }
<i class="no-highlight">6670</i>&nbsp;
<i class="no-highlight">6671</i>&nbsp;            //====================
<b class="nc"><i class="no-highlight">6672</i>&nbsp;            // Execution mode</b>
<b class="nc"><i class="no-highlight">6673</i>&nbsp;            //====================</b>
<b class="nc"><i class="no-highlight">6674</i>&nbsp;</b>
<i class="no-highlight">6675</i>&nbsp;            // 1) Capture the latest version of the table before doing the
<i class="no-highlight">6676</i>&nbsp;            //    delete of all rows in the table in the unlikely event that
<b class="nc"><i class="no-highlight">6677</i>&nbsp;            //    we need to rollback the rows in the target table. We would</b>
<i class="no-highlight">6678</i>&nbsp;            //    use the version number to put back the deleted rows.
<i class="no-highlight">6679</i>&nbsp;            versionNumber = getDLPLatestTargetTableVersionNumber(targetTablePath,
<b class="nc"><i class="no-highlight">6680</i>&nbsp;                        ERR_BULK_LOAD, ELT_LOAD_TITLE);</b>
<i class="no-highlight">6681</i>&nbsp;
<i class="no-highlight">6682</i>&nbsp;            // 2) DELETE rows from table operation
<b class="nc"><i class="no-highlight">6683</i>&nbsp;            sqlDeleteTable = buildDeleteTableSql(targetTablePath);</b>
<b class="nc"><i class="no-highlight">6684</i>&nbsp;            int numberOfDeletes = executeStatement(sqlDeleteTable, bindValues, account);</b>
<b class="nc"><i class="no-highlight">6685</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6686</i>&nbsp;            statistic.addNumberOfDeletes(numberOfDeletes);</b>
<b class="nc"><i class="no-highlight">6687</i>&nbsp;            statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">6688</i>&nbsp;                    new QueryStatisticHolderBuilder(sqlDeleteTable)</b>
<b class="nc"><i class="no-highlight">6689</i>&nbsp;                            .setNumberOfDeletes(numberOfDeletes)</b>
<b class="nc"><i class="no-highlight">6690</i>&nbsp;                            .build());</b>
<b class="nc"><i class="no-highlight">6691</i>&nbsp;            executedQueries.add(sqlDeleteTable);</b>
<i class="no-highlight">6692</i>&nbsp;            tableRowsDeleted = true;
<i class="no-highlight">6693</i>&nbsp;
<i class="no-highlight">6694</i>&nbsp;            // 3) LOAD Table (COPY INTO) operation
<i class="no-highlight">6695</i>&nbsp;            // Since table rows are deleted, it is very important that we
<i class="no-highlight">6696</i>&nbsp;            // need to set &#39;force&#39; = &#39;true&#39; file format option for DLP COPY INTO command,
<i class="no-highlight">6697</i>&nbsp;            // else we cannot load data from given file if that file was used earlier for
<i class="no-highlight">6698</i>&nbsp;            // loading data to a given table. And then recreate sqlBulkLoad command also.
<i class="no-highlight">6699</i>&nbsp;            modifyCopyOption(COPY_OPTION_FORCE_TRUE_DLP, COPY_OPTION_FORCE_DLP, true);
<i class="no-highlight">6700</i>&nbsp;            sqlBulkLoad = queryBuilder.toString().trim();
<i class="no-highlight">6701</i>&nbsp;            replaceColumnDefinitionsForSqlBulkLoadQuery();
<i class="no-highlight">6702</i>&nbsp;            executedQueries.add(sqlBulkLoad);
<i class="no-highlight">6703</i>&nbsp;
<i class="no-highlight">6704</i>&nbsp;            int numberOfInserts =
<i class="no-highlight">6705</i>&nbsp;                    executeStatement(sqlBulkLoad, null, account);
<i class="no-highlight">6706</i>&nbsp;
<i class="no-highlight">6707</i>&nbsp;            statistic.addNumberOfInserts(numberOfInserts);
<i class="no-highlight">6708</i>&nbsp;            statistic.addQueryStatistic(
<b class="nc"><i class="no-highlight">6709</i>&nbsp;                    new QueryStatisticHolderBuilder(sqlBulkLoad)</b>
<b class="nc"><i class="no-highlight">6710</i>&nbsp;                            .setNumberOfInserts(numberOfInserts)</b>
<b class="nc"><i class="no-highlight">6711</i>&nbsp;                            .build());</b>
<i class="no-highlight">6712</i>&nbsp;        } catch (Exception e) {
<i class="no-highlight">6713</i>&nbsp;            // Rollback DELETE rows from table operation
<b class="nc"><i class="no-highlight">6714</i>&nbsp;            if (tableRowsDeleted) {</b>
<i class="no-highlight">6715</i>&nbsp;                // Put back the rows that were deleted,
<b class="nc"><i class="no-highlight">6716</i>&nbsp;                // since we are doing a rollback.</b>
<i class="no-highlight">6717</i>&nbsp;                rollbackDeletedTableRows(targetTablePath);
<b class="nc"><i class="no-highlight">6718</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">6719</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6720</i>&nbsp;            handleFailures(ERR_BULK_LOAD);</b>
<b class="nc"><i class="no-highlight">6721</i>&nbsp;            String error = StringUtils.isNotBlank(e.toString()) ? e.toString() : ERR_BULK_LOAD;</b>
<b class="nc"><i class="no-highlight">6722</i>&nbsp;            throw new SnapDataException(e, error)</b>
<b class="nc"><i class="no-highlight">6723</i>&nbsp;                    .withReason(getErrorReason(e, ERR_BULK_LOAD))</b>
<i class="no-highlight">6724</i>&nbsp;                    .withResolution(getErrorResolution(e, CONTACT_SUPPORT));
<b class="nc"><i class="no-highlight">6725</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">6726</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">6727</i>&nbsp;</b>
<i class="no-highlight">6728</i>&nbsp;    private void executeAppendToTableBulkLoadDLP() {
<b class="nc"><i class="no-highlight">6729</i>&nbsp;        try {</b>
<i class="no-highlight">6730</i>&nbsp;            // Assert that table exists
<i class="no-highlight">6731</i>&nbsp;            if (!doesTableExist) {
<i class="no-highlight">6732</i>&nbsp;                sqlCreateTable = buildDLPCreateOrReplaceTableSql(targetTablePath,
<i class="no-highlight">6733</i>&nbsp;                        buildColumnWithDataTypeCreateTable(targetColumns, targetDataTypes),
<b class="nc"><i class="no-highlight">6734</i>&nbsp;                        eltDatabaseAccount, tableOptions);</b>
<i class="no-highlight">6735</i>&nbsp;                executedQueries.add(sqlCreateTable);
<b class="nc"><i class="no-highlight">6736</i>&nbsp;                statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">6737</i>&nbsp;                        new QueryStatisticHolderBuilder(sqlCreateTable).build());</b>
<b class="nc"><i class="no-highlight">6738</i>&nbsp;                executeSqlStmt(sqlCreateTable, bindValues, account);</b>
<b class="nc"><i class="no-highlight">6739</i>&nbsp;                doesTableExist = true;</b>
<b class="nc"><i class="no-highlight">6740</i>&nbsp;            }</b>
<i class="no-highlight">6741</i>&nbsp;
<i class="no-highlight">6742</i>&nbsp;            validateCsvFileColumNames(toUpperCase(
<i class="no-highlight">6743</i>&nbsp;                    getTableColumnNameDataTypeMap(targetTablePath).keySet()));
<b class="nc"><i class="no-highlight">6744</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6745</i>&nbsp;            //=========================</b>
<b class="nc"><i class="no-highlight">6746</i>&nbsp;            // Validation/Preview mode</b>
<b class="nc"><i class="no-highlight">6747</i>&nbsp;            //=========================</b>
<b class="nc"><i class="no-highlight">6748</i>&nbsp;            if (validationInProgress) {</b>
<b class="nc"><i class="no-highlight">6749</i>&nbsp;                // no op</b>
<b class="nc"><i class="no-highlight">6750</i>&nbsp;                return;</b>
<b class="nc"><i class="no-highlight">6751</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">6752</i>&nbsp;</b>
<i class="no-highlight">6753</i>&nbsp;            //====================
<i class="no-highlight">6754</i>&nbsp;            // Execution mode
<b class="nc"><i class="no-highlight">6755</i>&nbsp;            //====================</b>
<b class="nc"><i class="no-highlight">6756</i>&nbsp;</b>
<i class="no-highlight">6757</i>&nbsp;            replaceColumnDefinitionsForSqlBulkLoadQuery();
<b class="nc"><i class="no-highlight">6758</i>&nbsp;            executedQueries.add(sqlBulkLoad);</b>
<b class="nc"><i class="no-highlight">6759</i>&nbsp;            int numberOfInserts =</b>
<i class="no-highlight">6760</i>&nbsp;                    executeStatement(sqlBulkLoad, null, account);
<b class="nc"><i class="no-highlight">6761</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6762</i>&nbsp;            statistic.addNumberOfInserts(numberOfInserts);</b>
<i class="no-highlight">6763</i>&nbsp;            statistic.addQueryStatistic(
<i class="no-highlight">6764</i>&nbsp;                    new QueryStatisticHolderBuilder(sqlBulkLoad)
<b class="nc"><i class="no-highlight">6765</i>&nbsp;                            .setNumberOfInserts(numberOfInserts)</b>
<i class="no-highlight">6766</i>&nbsp;                            .build());
<i class="no-highlight">6767</i>&nbsp;        } catch (Exception e) {
<b class="nc"><i class="no-highlight">6768</i>&nbsp;            handleFailures(ERR_BULK_LOAD);</b>
<i class="no-highlight">6769</i>&nbsp;            String error = StringUtils.isNotBlank(e.toString()) ? e.toString() : ERR_BULK_LOAD;
<i class="no-highlight">6770</i>&nbsp;            throw new SnapDataException(e, error)
<i class="no-highlight">6771</i>&nbsp;                    .withReason(getErrorReason(e, ERR_BULK_LOAD))
<i class="no-highlight">6772</i>&nbsp;                    .withResolution(getErrorResolution(e, CONTACT_SUPPORT));
<i class="no-highlight">6773</i>&nbsp;        }
<i class="no-highlight">6774</i>&nbsp;    }
<b class="nc"><i class="no-highlight">6775</i>&nbsp;</b>
<i class="no-highlight">6776</i>&nbsp;    //********** BIGQUERY METHODS *************//
<b class="nc"><i class="no-highlight">6777</i>&nbsp;</b>
<i class="no-highlight">6778</i>&nbsp;    private void executeBigQueryBulkLoadWithRollback() {
<b class="nc"><i class="no-highlight">6779</i>&nbsp;        if (StringUtils.equalsIgnoreCase(loadAction, DROP_CREATE_TABLE)) {</b>
<i class="no-highlight">6780</i>&nbsp;            executeDropCreateTableBulkLoadBigQuery();
<i class="no-highlight">6781</i>&nbsp;        } else if (StringUtils.equalsIgnoreCase(loadAction, ALTER_TABLE)) {
<b class="nc"><i class="no-highlight">6782</i>&nbsp;            executeAlterTableBulkLoadBigQuery();</b>
<i class="no-highlight">6783</i>&nbsp;        } else if (StringUtils.equalsIgnoreCase(loadAction, OVERWRITE_TABLE)) {
<b class="nc"><i class="no-highlight">6784</i>&nbsp;            executeOverwriteTableBulkLoadBigQuery();</b>
<b class="nc"><i class="no-highlight">6785</i>&nbsp;        } else if (StringUtils.equals(loadAction, APPEND_ROWS_TABLE)) {</b>
<b class="nc"><i class="no-highlight">6786</i>&nbsp;            executeAppendToTableBulkLoadBigQuery();</b>
<i class="no-highlight">6787</i>&nbsp;        }
<i class="no-highlight">6788</i>&nbsp;    }
<b class="nc"><i class="no-highlight">6789</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6790</i>&nbsp;    /**</b>
<b class="nc"><i class="no-highlight">6791</i>&nbsp;     * This function creates a table with the given &quot;destinationTableName&quot; as its name</b>
<b class="nc"><i class="no-highlight">6792</i>&nbsp;     * and, using BigQuery&#39;s auto schema-detection, the schema of the source file(s)</b>
<b class="nc"><i class="no-highlight">6793</i>&nbsp;     * from &quot;gcsSourceURIs&quot;, and load the source data into the table.</b>
<b class="nc"><i class="no-highlight">6794</i>&nbsp;     *</b>
<i class="no-highlight">6795</i>&nbsp;     * This uses Google Cloud BigQuery Client for Java at
<i class="no-highlight">6796</i>&nbsp;     * https://github.com/googleapis/java-bigquery and uses Gcs Autodetect for
<i class="no-highlight">6797</i>&nbsp;     * schema auto-detection from the source files.
<i class="no-highlight">6798</i>&nbsp;     *
<i class="no-highlight">6799</i>&nbsp;     * Note that we don&#39;t need to create a table with the name &quot;destinationTableName&quot;
<i class="no-highlight">6800</i>&nbsp;     * before calling this function.
<i class="no-highlight">6801</i>&nbsp;     *
<b class="nc"><i class="no-highlight">6802</i>&nbsp;     * @param destinationTableName</b>
<b class="nc"><i class="no-highlight">6803</i>&nbsp;     * @throws Exception</b>
<i class="no-highlight">6804</i>&nbsp;     */
<i class="no-highlight">6805</i>&nbsp;    private void doBigQueryBulkLoad(
<b class="nc"><i class="no-highlight">6806</i>&nbsp;            String destinationTableName) throws Exception {</b>
<b class="nc"><i class="no-highlight">6807</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6808</i>&nbsp;        String projectName = getDatabaseName();</b>
<b class="nc"><i class="no-highlight">6809</i>&nbsp;        TableId tableId = getTableIdBigQuery(</b>
<b class="nc"><i class="no-highlight">6810</i>&nbsp;                projectName, getSchemaName(), destinationTableName);</b>
<b class="nc"><i class="no-highlight">6811</i>&nbsp;</b>
<i class="no-highlight">6812</i>&nbsp;        if (gcsSourceURIs.isEmpty()) {
<b class="nc"><i class="no-highlight">6813</i>&nbsp;            return;</b>
<b class="nc"><i class="no-highlight">6814</i>&nbsp;        }</b>
<i class="no-highlight">6815</i>&nbsp;
<i class="no-highlight">6816</i>&nbsp;        // Get credentials from BQ acct for specified auth type (Service Acct, OAuth2 Access
<b class="nc"><i class="no-highlight">6817</i>&nbsp;        // token and OAuth2 refresh token). This is required to instantiate BQ Client</b>
<i class="no-highlight">6818</i>&nbsp;        Credentials bqCredentials = getCredentialsFromBQAcct(eltDatabaseAccount);
<b class="nc"><i class="no-highlight">6819</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6820</i>&nbsp;        // Instantiate BigQuery client that will be used to send requests to backend</b>
<i class="no-highlight">6821</i>&nbsp;        BigQuery bigQueryClient = BigQueryOptions
<b class="nc"><i class="no-highlight">6822</i>&nbsp;                .newBuilder()</b>
<i class="no-highlight">6823</i>&nbsp;                .setHeaderProvider(() -&gt; ImmutableMap.of(
<b class="nc"><i class="no-highlight">6824</i>&nbsp;                        BIGQUERY_USER_AGENT_HEADER_KEY, BIGQUERY_SNAPLOGIC_USER_AGENT))</b>
<b class="nc"><i class="no-highlight">6825</i>&nbsp;                .setProjectId(projectName)</b>
<b class="nc"><i class="no-highlight">6826</i>&nbsp;                .setCredentials(bqCredentials)</b>
<i class="no-highlight">6827</i>&nbsp;                .build()
<b class="nc"><i class="no-highlight">6828</i>&nbsp;                .getService();</b>
<b class="nc"><i class="no-highlight">6829</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6830</i>&nbsp;        // Set the file format options depending on source file(s) format type</b>
<b class="nc"><i class="no-highlight">6831</i>&nbsp;        FormatOptions formatOptions = null;</b>
<b class="nc"><i class="no-highlight">6832</i>&nbsp;        switch (fileFormatType) {</b>
<i class="no-highlight">6833</i>&nbsp;            case CSV:
<b class="nc"><i class="no-highlight">6834</i>&nbsp;                formatOptions = CsvOptions</b>
<i class="no-highlight">6835</i>&nbsp;                        .newBuilder()
<i class="no-highlight">6836</i>&nbsp;                        .setAllowJaggedRows(bigQueryLoadOptionsConfig.isAllowJaggedRows())
<i class="no-highlight">6837</i>&nbsp;                        .setAllowQuotedNewLines(
<i class="no-highlight">6838</i>&nbsp;                                bigQueryLoadOptionsConfig.isAllowQuotedNewLines())
<i class="no-highlight">6839</i>&nbsp;                        .setEncoding(bigQueryLoadOptionsConfig.getEncoding())
<b class="nc"><i class="no-highlight">6840</i>&nbsp;                        .setFieldDelimiter(bigQueryLoadOptionsConfig.getFieldDelimiter())</b>
<b class="nc"><i class="no-highlight">6841</i>&nbsp;                        .setQuote(bigQueryLoadOptionsConfig.getQuote())</b>
<b class="nc"><i class="no-highlight">6842</i>&nbsp;                        .setSkipLeadingRows(bigQueryLoadOptionsConfig.getSkipLeadingRows())</b>
<b class="nc"><i class="no-highlight">6843</i>&nbsp;                        .build();</b>
<i class="no-highlight">6844</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">6845</i>&nbsp;            case JSON:</b>
<b class="nc"><i class="no-highlight">6846</i>&nbsp;                formatOptions = FormatOptions.json();</b>
<b class="nc"><i class="no-highlight">6847</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">6848</i>&nbsp;            case PARQUET:</b>
<i class="no-highlight">6849</i>&nbsp;                formatOptions = FormatOptions.parquet();
<b class="nc"><i class="no-highlight">6850</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">6851</i>&nbsp;            case ORC:</b>
<i class="no-highlight">6852</i>&nbsp;                formatOptions = FormatOptions.orc();
<b class="nc"><i class="no-highlight">6853</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">6854</i>&nbsp;            case AVRO:</b>
<b class="nc"><i class="no-highlight">6855</i>&nbsp;                formatOptions = FormatOptions.avro();</b>
<i class="no-highlight">6856</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">6857</i>&nbsp;            default:</b>
<b class="nc"><i class="no-highlight">6858</i>&nbsp;        }</b>
<i class="no-highlight">6859</i>&nbsp;
<i class="no-highlight">6860</i>&nbsp;        // Build config for load job
<b class="nc"><i class="no-highlight">6861</i>&nbsp;        LoadJobConfiguration.Builder loadConfigBuilder = LoadJobConfiguration</b>
<i class="no-highlight">6862</i>&nbsp;                .newBuilder(tableId, gcsSourceURIs, formatOptions)
<b class="nc"><i class="no-highlight">6863</i>&nbsp;                .setWriteDisposition(JobInfo.WriteDisposition.WRITE_APPEND);</b>
<b class="nc"><i class="no-highlight">6864</i>&nbsp;</b>
<i class="no-highlight">6865</i>&nbsp;        // Create load job
<b class="nc"><i class="no-highlight">6866</i>&nbsp;        Job job = bigQueryClient.create(JobInfo.of(loadConfigBuilder.build()));</b>
<i class="no-highlight">6867</i>&nbsp;
<b class="nc"><i class="no-highlight">6868</i>&nbsp;        // Execute load job (blocks until execution finishes - it fails or succeed)</b>
<b class="nc"><i class="no-highlight">6869</i>&nbsp;        job = job.waitFor();</b>
<b class="nc"><i class="no-highlight">6870</i>&nbsp;</b>
<i class="no-highlight">6871</i>&nbsp;        // Check load job status
<b class="nc"><i class="no-highlight">6872</i>&nbsp;        if (job.getStatus().getError() != null) {</b>
<b class="nc"><i class="no-highlight">6873</i>&nbsp;            String reasons = StringUtils.EMPTY;</b>
<b class="nc"><i class="no-highlight">6874</i>&nbsp;            for (BigQueryError error : job.getStatus().getExecutionErrors()) {</b>
<b class="nc"><i class="no-highlight">6875</i>&nbsp;                reasons = reasons + error.getMessage() + &quot;;&quot;;</b>
<b class="nc"><i class="no-highlight">6876</i>&nbsp;            }</b>
<i class="no-highlight">6877</i>&nbsp;            reasons = StringUtils.removeEnd(reasons, &quot;;&quot;);
<b class="nc"><i class="no-highlight">6878</i>&nbsp;            throw new SnapDataException(gcsSourceURIs.toString())</b>
<i class="no-highlight">6879</i>&nbsp;                    .withReason(reasons)
<i class="no-highlight">6880</i>&nbsp;                    .withResolution(CONTACT_SUPPORT);
<i class="no-highlight">6881</i>&nbsp;        }
<i class="no-highlight">6882</i>&nbsp;    }
<i class="no-highlight">6883</i>&nbsp;
<i class="no-highlight">6884</i>&nbsp;    /**
<b class="nc"><i class="no-highlight">6885</i>&nbsp;     * This function loads the source data into the given table with</b>
<b class="nc"><i class="no-highlight">6886</i>&nbsp;     * &quot;destinationTableName&quot; as its name.</b>
<i class="no-highlight">6887</i>&nbsp;     *
<b class="nc"><i class="no-highlight">6888</i>&nbsp;     * This uses BigQuery Data Transfer Service at</b>
<i class="no-highlight">6889</i>&nbsp;     * &lt;a href=&quot;https://github.com/googleapis/java-bigquerydatatransfer&quot;&gt;link&lt;/a&gt;. But this
<b class="nc"><i class="no-highlight">6890</i>&nbsp;     * does not seem to support auto schema-detection as Google Cloud BigQuery</b>
<b class="nc"><i class="no-highlight">6891</i>&nbsp;     * Client for Java.</b>
<i class="no-highlight">6892</i>&nbsp;     *
<b class="nc"><i class="no-highlight">6893</i>&nbsp;     * @param destinationTableName</b>
<i class="no-highlight">6894</i>&nbsp;     * @throws Exception
<b class="nc"><i class="no-highlight">6895</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">6896</i>&nbsp;    private void doBigQueryTransferLoad(String destinationTableName)</b>
<b class="nc"><i class="no-highlight">6897</i>&nbsp;            throws InterruptedException, IOException {</b>
<i class="no-highlight">6898</i>&nbsp;        String projectName = getDatabaseName();
<b class="nc"><i class="no-highlight">6899</i>&nbsp;        String datasetName = getSchemaName();</b>
<b class="nc"><i class="no-highlight">6900</i>&nbsp;        List&lt;Map&lt;String, Value&gt;&gt; paramsList = new ArrayList&lt;&gt;();</b>
<b class="nc"><i class="no-highlight">6901</i>&nbsp;        String dataSourceId;</b>
<b class="nc"><i class="no-highlight">6902</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6903</i>&nbsp;        String sourceLocation = eltDatabaseAccount.getSourceLocation();</b>
<i class="no-highlight">6904</i>&nbsp;
<b class="nc"><i class="no-highlight">6905</i>&nbsp;        switch (sourceLocation) {</b>
<i class="no-highlight">6906</i>&nbsp;            case AMAZON_S3:
<i class="no-highlight">6907</i>&nbsp;                dataSourceId = &quot;amazon_s3&quot;;
<i class="no-highlight">6908</i>&nbsp;                buildS3SourceURIs().stream()
<i class="no-highlight">6909</i>&nbsp;                        .map(sourceUri -&gt;
<i class="no-highlight">6910</i>&nbsp;                                getParametersForS3Transfer(destinationTableName, sourceUri))
<i class="no-highlight">6911</i>&nbsp;                        .forEach(paramsList::add);
<b class="nc"><i class="no-highlight">6912</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">6913</i>&nbsp;            case AMAZON_REDSHIFT:</b>
<i class="no-highlight">6914</i>&nbsp;                dataSourceId = &quot;redshift&quot;;
<b class="nc"><i class="no-highlight">6915</i>&nbsp;                paramsList.add(getParametersForRSTransfer());</b>
<i class="no-highlight">6916</i>&nbsp;                break;
<b class="nc"><i class="no-highlight">6917</i>&nbsp;            default:</b>
<i class="no-highlight">6918</i>&nbsp;                throw new ConfigurationException(&quot;This source location is not supported.&quot;);
<i class="no-highlight">6919</i>&nbsp;        }
<b class="nc"><i class="no-highlight">6920</i>&nbsp;</b>
<i class="no-highlight">6921</i>&nbsp;        // Get credentials from BQ acct for specified auth type (Service Acct, OAuth2 Access
<b class="nc"><i class="no-highlight">6922</i>&nbsp;        // token and OAuth2 refresh token). This is required to instantiate BQ Client</b>
<b class="nc"><i class="no-highlight">6923</i>&nbsp;        Credentials bqCredentials = getCredentialsFromBQAcct(eltDatabaseAccount);</b>
<i class="no-highlight">6924</i>&nbsp;
<i class="no-highlight">6925</i>&nbsp;        for (Map&lt;String, Value&gt; params : paramsList) {
<i class="no-highlight">6926</i>&nbsp;            String s3SourceURI = EMPTY_STRING;
<i class="no-highlight">6927</i>&nbsp;            if (StringUtils.equals(sourceLocation, AMAZON_S3)) {
<b class="nc"><i class="no-highlight">6928</i>&nbsp;                s3SourceURI = Optional.of(params.get(&quot;data_path&quot;).getStringValue())</b>
<i class="no-highlight">6929</i>&nbsp;                        .orElse(EMPTY_STRING);
<b class="nc"><i class="no-highlight">6930</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">6931</i>&nbsp;            // Setup Transfer Config with on-demand schedule</b>
<b class="nc"><i class="no-highlight">6932</i>&nbsp;            TransferConfig transferConfig =</b>
<b class="nc"><i class="no-highlight">6933</i>&nbsp;                    TransferConfig.newBuilder()</b>
<i class="no-highlight">6934</i>&nbsp;                            .setDestinationDatasetId(datasetName)
<i class="no-highlight">6935</i>&nbsp;                            .setDisplayName(bqTransferDisplayName)
<b class="nc"><i class="no-highlight">6936</i>&nbsp;                            .setDataSourceId(dataSourceId)</b>
<i class="no-highlight">6937</i>&nbsp;                            .setParams(Struct.newBuilder().putAllFields(params).build())
<b class="nc"><i class="no-highlight">6938</i>&nbsp;                            .setScheduleOptions(ScheduleOptions</b>
<i class="no-highlight">6939</i>&nbsp;                                    .newBuilder()
<i class="no-highlight">6940</i>&nbsp;                                    .setDisableAutoScheduling(true))
<i class="no-highlight">6941</i>&nbsp;                            .build();
<i class="no-highlight">6942</i>&nbsp;
<i class="no-highlight">6943</i>&nbsp;            DataTransferServiceSettings dataTransferServiceSettings =
<i class="no-highlight">6944</i>&nbsp;                    DataTransferServiceSettings.newBuilder()
<i class="no-highlight">6945</i>&nbsp;                            .setHeaderProvider(() -&gt; Map.of(BIGQUERY_USER_AGENT_HEADER_KEY,
<b class="nc"><i class="no-highlight">6946</i>&nbsp;                                    BIGQUERY_SNAPLOGIC_USER_AGENT))</b>
<i class="no-highlight">6947</i>&nbsp;                            .setCredentialsProvider(FixedCredentialsProvider.create(bqCredentials))
<b class="nc"><i class="no-highlight">6948</i>&nbsp;                            .build();</b>
<b class="nc"><i class="no-highlight">6949</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6950</i>&nbsp;            try (DataTransferServiceClient client =</b>
<b class="nc"><i class="no-highlight">6951</i>&nbsp;                         DataTransferServiceClient.create(dataTransferServiceSettings)) {</b>
<b class="nc"><i class="no-highlight">6952</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6953</i>&nbsp;                // Initiate request to create Transfer Config object with on-demand schedule</b>
<b class="nc"><i class="no-highlight">6954</i>&nbsp;                String transferConfigName = initializeTransferConfig(client, projectName,</b>
<b class="nc"><i class="no-highlight">6955</i>&nbsp;                        transferConfig, sourceLocation, s3SourceURI);</b>
<i class="no-highlight">6956</i>&nbsp;
<i class="no-highlight">6957</i>&nbsp;                String transferRunName = startManualTransfer(client, transferConfigName,
<b class="nc"><i class="no-highlight">6958</i>&nbsp;                        sourceLocation, s3SourceURI);</b>
<b class="nc"><i class="no-highlight">6959</i>&nbsp;</b>
<i class="no-highlight">6960</i>&nbsp;                // Transfer Run for an on-demand Transfer Config initiated above. Since it is
<i class="no-highlight">6961</i>&nbsp;                // long-running operation, check the state and poll every minute till state
<b class="nc"><i class="no-highlight">6962</i>&nbsp;                // changes to SUCCEEDED or FAILED</b>
<b class="nc"><i class="no-highlight">6963</i>&nbsp;</b>
<i class="no-highlight">6964</i>&nbsp;                boolean shouldContinue = true;
<i class="no-highlight">6965</i>&nbsp;
<b class="nc"><i class="no-highlight">6966</i>&nbsp;                while (shouldContinue) {</b>
<b class="nc"><i class="no-highlight">6967</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">6968</i>&nbsp;                    TransferState transferState = getTransferRunState(</b>
<i class="no-highlight">6969</i>&nbsp;                            client, transferRunName, sourceLocation, s3SourceURI);
<i class="no-highlight">6970</i>&nbsp;
<b class="nc"><i class="no-highlight">6971</i>&nbsp;                    shouldContinue = checkTransferState(transferState, transferConfigName,</b>
<b class="nc"><i class="no-highlight">6972</i>&nbsp;                            transferRunName, sourceLocation, s3SourceURI);</b>
<i class="no-highlight">6973</i>&nbsp;                }
<i class="no-highlight">6974</i>&nbsp;            }  catch (ApiException ex) {
<b class="nc"><i class="no-highlight">6975</i>&nbsp;                String reason = String.format(</b>
<b class="nc"><i class="no-highlight">6976</i>&nbsp;                        &quot;Failed to start/initiate or retrieve state of %s transfer run. %s&quot;,</b>
<i class="no-highlight">6977</i>&nbsp;                        sourceLocation, ex);
<i class="no-highlight">6978</i>&nbsp;                LOGGER.error(reason);
<b class="nc"><i class="no-highlight">6979</i>&nbsp;                throw new SnapDataException(s3SourceURI)</b>
<b class="nc"><i class="no-highlight">6980</i>&nbsp;                        .withReason(reason)</b>
<i class="no-highlight">6981</i>&nbsp;                        .withResolution(CONTACT_SUPPORT);
<b class="nc"><i class="no-highlight">6982</i>&nbsp;            }</b>
<i class="no-highlight">6983</i>&nbsp;        }
<i class="no-highlight">6984</i>&nbsp;    }
<i class="no-highlight">6985</i>&nbsp;
<i class="no-highlight">6986</i>&nbsp;    private String initializeTransferConfig(DataTransferServiceClient client, String projectName,
<i class="no-highlight">6987</i>&nbsp;                                            TransferConfig transferConfig, String sourceLocation,
<i class="no-highlight">6988</i>&nbsp;                                            String s3SourceURI)
<i class="no-highlight">6989</i>&nbsp;            throws InterruptedException {
<b class="nc"><i class="no-highlight">6990</i>&nbsp;        // Initiate request to create Transfer Config object with on-demand schedule</b>
<i class="no-highlight">6991</i>&nbsp;        String transferConfigName = EMPTY_STRING;
<i class="no-highlight">6992</i>&nbsp;        for (int i = 0; i &lt;= BQ_MAX_RETRIES; ++i) {
<b class="nc"><i class="no-highlight">6993</i>&nbsp;            try {</b>
<b class="nc"><i class="no-highlight">6994</i>&nbsp;                CreateTransferConfigRequest request =</b>
<b class="nc"><i class="no-highlight">6995</i>&nbsp;                        CreateTransferConfigRequest.newBuilder()</b>
<b class="nc"><i class="no-highlight">6996</i>&nbsp;                                .setParent(ProjectName.of(projectName).toString())</b>
<b class="nc"><i class="no-highlight">6997</i>&nbsp;                                .setTransferConfig(transferConfig)</b>
<b class="nc"><i class="no-highlight">6998</i>&nbsp;                                .build();</b>
<i class="no-highlight">6999</i>&nbsp;                TransferConfig config = client.createTransferConfig(request);
<i class="no-highlight">7000</i>&nbsp;                transferConfigName = config.getName();
<b class="nc"><i class="no-highlight">7001</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7002</i>&nbsp;                if (StringUtils.isBlank(transferConfigName)) {</b>
<b class="nc"><i class="no-highlight">7003</i>&nbsp;                    throw new ConfigurationException(&quot;Cannot create transfer config&quot;);</b>
<b class="nc"><i class="no-highlight">7004</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">7005</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7006</i>&nbsp;                LOGGER.info(&quot;{} transfer config created successfully : {}&quot;, sourceLocation,</b>
<i class="no-highlight">7007</i>&nbsp;                        transferConfigName);
<i class="no-highlight">7008</i>&nbsp;                break; // success, so no need to retry anymore
<b class="nc"><i class="no-highlight">7009</i>&nbsp;            } catch (DeadlineExceededException | UnavailableException ex) {</b>
<b class="nc"><i class="no-highlight">7010</i>&nbsp;                // these are retryable exception</b>
<b class="nc"><i class="no-highlight">7011</i>&nbsp;                String reason = String.format(&quot;Failed to create %s transfer config. %s&quot;,</b>
<b class="nc"><i class="no-highlight">7012</i>&nbsp;                        sourceLocation, ex);</b>
<i class="no-highlight">7013</i>&nbsp;                handleRetryableApiException(reason, i, s3SourceURI);
<b class="nc"><i class="no-highlight">7014</i>&nbsp;            } catch (ApiException ex) {</b>
<i class="no-highlight">7015</i>&nbsp;                String reason = String.format(&quot;Failed to create %s transfer config. %s&quot;,
<i class="no-highlight">7016</i>&nbsp;                        sourceLocation, ex);
<i class="no-highlight">7017</i>&nbsp;                LOGGER.error(reason);
<i class="no-highlight">7018</i>&nbsp;                throw new SnapDataException(s3SourceURI)
<i class="no-highlight">7019</i>&nbsp;                        .withReason(reason)
<b class="nc"><i class="no-highlight">7020</i>&nbsp;                        .withResolution(CONTACT_SUPPORT);</b>
<b class="nc"><i class="no-highlight">7021</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">7022</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">7023</i>&nbsp;        return transferConfigName;</b>
<b class="nc"><i class="no-highlight">7024</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">7025</i>&nbsp;</b>
<i class="no-highlight">7026</i>&nbsp;    private String startManualTransfer(DataTransferServiceClient client, String transferConfigName,
<i class="no-highlight">7027</i>&nbsp;                                       String sourceLocation, String s3SourceURI)
<b class="nc"><i class="no-highlight">7028</i>&nbsp;            throws InterruptedException {</b>
<b class="nc"><i class="no-highlight">7029</i>&nbsp;        Instant now = Instant.now();</b>
<b class="nc"><i class="no-highlight">7030</i>&nbsp;        Timestamp timestamp = Timestamp.newBuilder()</b>
<b class="nc"><i class="no-highlight">7031</i>&nbsp;                .setSeconds(now.getEpochSecond()).setNanos(now.getNano())</b>
<i class="no-highlight">7032</i>&nbsp;                .build();
<i class="no-highlight">7033</i>&nbsp;        StartManualTransferRunsRequest request =
<i class="no-highlight">7034</i>&nbsp;                StartManualTransferRunsRequest.newBuilder()
<i class="no-highlight">7035</i>&nbsp;                        .setParent(transferConfigName)
<i class="no-highlight">7036</i>&nbsp;                        .setRequestedRunTime(timestamp)
<i class="no-highlight">7037</i>&nbsp;                        .build();
<i class="no-highlight">7038</i>&nbsp;
<i class="no-highlight">7039</i>&nbsp;        String transferRunName = EMPTY_STRING;
<i class="no-highlight">7040</i>&nbsp;        for (int i = 0; i &lt;= BQ_MAX_RETRIES; ++i) {
<i class="no-highlight">7041</i>&nbsp;            try {
<i class="no-highlight">7042</i>&nbsp;                StartManualTransferRunsResponse response =
<i class="no-highlight">7043</i>&nbsp;                        client.startManualTransferRuns(request);
<i class="no-highlight">7044</i>&nbsp;                transferRunName = response.getRuns(0).getName();
<i class="no-highlight">7045</i>&nbsp;
<i class="no-highlight">7046</i>&nbsp;                if (StringUtils.isBlank(transferRunName)) {
<i class="no-highlight">7047</i>&nbsp;                    throw new ConfigurationException(&quot;Cannot start manual transfer run&quot;);
<i class="no-highlight">7048</i>&nbsp;                }
<i class="no-highlight">7049</i>&nbsp;
<i class="no-highlight">7050</i>&nbsp;                LOGGER.info(&quot;{} transfer run started successfully : {}&quot;,
<i class="no-highlight">7051</i>&nbsp;                        sourceLocation, transferRunName);
<b class="nc"><i class="no-highlight">7052</i>&nbsp;                break; // success, so no need to retry anymore</b>
<b class="nc"><i class="no-highlight">7053</i>&nbsp;            } catch (DeadlineExceededException | UnavailableException ex) {</b>
<i class="no-highlight">7054</i>&nbsp;                // these are retryable exception
<i class="no-highlight">7055</i>&nbsp;                String reason = String.format(&quot;Failed to start/initiate %s transfer run. %s&quot;,
<i class="no-highlight">7056</i>&nbsp;                        sourceLocation, ex);
<i class="no-highlight">7057</i>&nbsp;                handleRetryableApiException(reason, i, s3SourceURI);
<i class="no-highlight">7058</i>&nbsp;            } catch (ApiException ex) {
<i class="no-highlight">7059</i>&nbsp;                String reason = String.format(&quot;Failed to start/initiate %s transfer run. %s&quot;,
<b class="nc"><i class="no-highlight">7060</i>&nbsp;                        sourceLocation, ex);</b>
<i class="no-highlight">7061</i>&nbsp;                LOGGER.error(reason);
<i class="no-highlight">7062</i>&nbsp;                throw new SnapDataException(s3SourceURI)
<i class="no-highlight">7063</i>&nbsp;                        .withReason(reason)
<i class="no-highlight">7064</i>&nbsp;                        .withResolution(CONTACT_SUPPORT);
<i class="no-highlight">7065</i>&nbsp;            }
<i class="no-highlight">7066</i>&nbsp;        }
<i class="no-highlight">7067</i>&nbsp;        return transferRunName;
<b class="nc"><i class="no-highlight">7068</i>&nbsp;    }</b>
<i class="no-highlight">7069</i>&nbsp;
<i class="no-highlight">7070</i>&nbsp;    private TransferState getTransferRunState(DataTransferServiceClient client,
<i class="no-highlight">7071</i>&nbsp;                                              String transferRunName, String sourceLocation,
<b class="nc"><i class="no-highlight">7072</i>&nbsp;                                              String s3SourceURI)</b>
<b class="nc"><i class="no-highlight">7073</i>&nbsp;            throws InterruptedException {</b>
<b class="nc"><i class="no-highlight">7074</i>&nbsp;        TransferState transferState = null;</b>
<i class="no-highlight">7075</i>&nbsp;        for (int i = 0; i &lt;= BQ_MAX_RETRIES; ++i) {
<b class="nc"><i class="no-highlight">7076</i>&nbsp;            try {</b>
<i class="no-highlight">7077</i>&nbsp;                transferState = client.getTransferRun(transferRunName).getState();
<b class="nc"><i class="no-highlight">7078</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7079</i>&nbsp;                break; // success, so no need to retry anymore</b>
<b class="nc"><i class="no-highlight">7080</i>&nbsp;            } catch (DeadlineExceededException | UnavailableException ex) {</b>
<b class="nc"><i class="no-highlight">7081</i>&nbsp;                // these are retryable exception</b>
<b class="nc"><i class="no-highlight">7082</i>&nbsp;                String reason = String.format(&quot;Failed to retrieve state of %s transfer run. %s&quot;,</b>
<b class="nc"><i class="no-highlight">7083</i>&nbsp;                        sourceLocation, ex);</b>
<i class="no-highlight">7084</i>&nbsp;                handleRetryableApiException(reason, i, s3SourceURI);
<b class="nc"><i class="no-highlight">7085</i>&nbsp;            } catch (ApiException ex) {</b>
<b class="nc"><i class="no-highlight">7086</i>&nbsp;                String reason = String.format(&quot;Failed to retrieve state of %s transfer run. %s&quot;,</b>
<b class="nc"><i class="no-highlight">7087</i>&nbsp;                        sourceLocation, ex);</b>
<b class="nc"><i class="no-highlight">7088</i>&nbsp;                LOGGER.error(reason);</b>
<i class="no-highlight">7089</i>&nbsp;                throw new SnapDataException(s3SourceURI)
<b class="nc"><i class="no-highlight">7090</i>&nbsp;                        .withReason(reason)</b>
<b class="nc"><i class="no-highlight">7091</i>&nbsp;                        .withResolution(CONTACT_SUPPORT);</b>
<b class="nc"><i class="no-highlight">7092</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">7093</i>&nbsp;        }</b>
<i class="no-highlight">7094</i>&nbsp;        return transferState;
<i class="no-highlight">7095</i>&nbsp;    }
<i class="no-highlight">7096</i>&nbsp;
<i class="no-highlight">7097</i>&nbsp;    private boolean checkTransferState(TransferState transferState, String transferConfigName,
<b class="nc"><i class="no-highlight">7098</i>&nbsp;                                       String transferRunName, String sourceLocation,</b>
<b class="nc"><i class="no-highlight">7099</i>&nbsp;                                       String s3SourceURI)</b>
<b class="nc"><i class="no-highlight">7100</i>&nbsp;            throws InterruptedException {</b>
<b class="nc"><i class="no-highlight">7101</i>&nbsp;        if (transferState != null) {</b>
<b class="nc"><i class="no-highlight">7102</i>&nbsp;            switch (transferState) {</b>
<b class="nc"><i class="no-highlight">7103</i>&nbsp;                case SUCCEEDED:</b>
<i class="no-highlight">7104</i>&nbsp;                    LOGGER.info(BQ_TRANSFER_RUN_SUCCEEDED,
<b class="nc"><i class="no-highlight">7105</i>&nbsp;                            sourceLocation, transferRunName, transferConfigName);</b>
<i class="no-highlight">7106</i>&nbsp;                    return false;
<i class="no-highlight">7107</i>&nbsp;                case RUNNING:
<i class="no-highlight">7108</i>&nbsp;                case PENDING:
<i class="no-highlight">7109</i>&nbsp;                    LOGGER.info(BQ_TRANSFER_RUN_PENDING_OR_RUNNING,
<b class="nc"><i class="no-highlight">7110</i>&nbsp;                            sourceLocation, transferRunName, transferConfigName);</b>
<b class="nc"><i class="no-highlight">7111</i>&nbsp;                    TimeUnit.MINUTES.sleep(1);</b>
<i class="no-highlight">7112</i>&nbsp;                    break;
<i class="no-highlight">7113</i>&nbsp;                case FAILED:
<b class="nc"><i class="no-highlight">7114</i>&nbsp;                case CANCELLED:</b>
<b class="nc"><i class="no-highlight">7115</i>&nbsp;                case UNRECOGNIZED:</b>
<i class="no-highlight">7116</i>&nbsp;                default:
<b class="nc"><i class="no-highlight">7117</i>&nbsp;                    String reason = String.format(BQ_TRANSFER_RUN_FAILED,</b>
<i class="no-highlight">7118</i>&nbsp;                            sourceLocation, transferRunName, transferConfigName);
<i class="no-highlight">7119</i>&nbsp;                    LOGGER.error(reason);
<i class="no-highlight">7120</i>&nbsp;                    throw new SnapDataException(s3SourceURI)
<i class="no-highlight">7121</i>&nbsp;                            .withReason(reason)
<i class="no-highlight">7122</i>&nbsp;                            .withResolution(CONTACT_SUPPORT);
<i class="no-highlight">7123</i>&nbsp;            }
<i class="no-highlight">7124</i>&nbsp;        } else {
<i class="no-highlight">7125</i>&nbsp;            throw new ConfigurationException(&quot;Cannot get transfer state&quot;);
<i class="no-highlight">7126</i>&nbsp;        }
<i class="no-highlight">7127</i>&nbsp;        return true;
<i class="no-highlight">7128</i>&nbsp;    }
<i class="no-highlight">7129</i>&nbsp;
<i class="no-highlight">7130</i>&nbsp;    /**
<i class="no-highlight">7131</i>&nbsp;     * Refer : &lt;a href=&quot;https://cloud.google.com/bigquery-transfer/docs/s3-transfer&quot;&gt;Doc link&lt;/a&gt;
<i class="no-highlight">7132</i>&nbsp;     */
<i class="no-highlight">7133</i>&nbsp;    private Map&lt;String, Value&gt; getParametersForS3Transfer(String destinationTableName,
<i class="no-highlight">7134</i>&nbsp;                                                          String sourceURI) {
<i class="no-highlight">7135</i>&nbsp;        Map&lt;String, Value&gt; params = new HashMap&lt;&gt;();
<i class="no-highlight">7136</i>&nbsp;
<i class="no-highlight">7137</i>&nbsp;        params.put(&quot;destination_table_name_template&quot;, Value.newBuilder()
<i class="no-highlight">7138</i>&nbsp;                .setStringValue(destinationTableName).build());
<b class="nc"><i class="no-highlight">7139</i>&nbsp;        params.put(&quot;data_path&quot;, Value.newBuilder()</b>
<b class="nc"><i class="no-highlight">7140</i>&nbsp;                .setStringValue(sourceURI).build());</b>
<i class="no-highlight">7141</i>&nbsp;        params.put(&quot;access_key_id&quot;, Value.newBuilder()
<i class="no-highlight">7142</i>&nbsp;                .setStringValue(awsAccessKey).build());
<i class="no-highlight">7143</i>&nbsp;        params.put(&quot;secret_access_key&quot;, Value.newBuilder()
<i class="no-highlight">7144</i>&nbsp;                .setStringValue(awsSecretKey).build());
<i class="no-highlight">7145</i>&nbsp;
<i class="no-highlight">7146</i>&nbsp;        // e.g &quot;CSV&quot; or &quot;JSON&quot; etc
<b class="nc"><i class="no-highlight">7147</i>&nbsp;        params.put(&quot;file_format&quot;, Value.newBuilder()</b>
<i class="no-highlight">7148</i>&nbsp;                .setStringValue(fileFormatType).build());
<i class="no-highlight">7149</i>&nbsp;
<i class="no-highlight">7150</i>&nbsp;        // e.g &quot;,&quot; or &quot;|&quot;
<i class="no-highlight">7151</i>&nbsp;        params.put(&quot;field_delimiter&quot;, Value.newBuilder()
<i class="no-highlight">7152</i>&nbsp;                .setStringValue(bigQueryLoadOptionsConfig.getFieldDelimiter()).build());
<i class="no-highlight">7153</i>&nbsp;
<i class="no-highlight">7154</i>&nbsp;        // e.g &quot;1&quot;
<b class="nc"><i class="no-highlight">7155</i>&nbsp;        params.put(&quot;skip_leading_rows&quot;, Value.newBuilder()</b>
<i class="no-highlight">7156</i>&nbsp;                .setStringValue(Long.toString(bigQueryLoadOptionsConfig.getSkipLeadingRows()))
<i class="no-highlight">7157</i>&nbsp;                .build());
<i class="no-highlight">7158</i>&nbsp;
<i class="no-highlight">7159</i>&nbsp;        // e.g &quot;false&quot; or &quot;true&quot;
<i class="no-highlight">7160</i>&nbsp;        params.put(&quot;ignore_unknown_values&quot;, Value.newBuilder()
<b class="nc"><i class="no-highlight">7161</i>&nbsp;                .setStringValue(bigQueryLoadOptionsConfig.getIgnoreUnknownValues()).build());</b>
<i class="no-highlight">7162</i>&nbsp;
<i class="no-highlight">7163</i>&nbsp;        // e.g &quot;10&quot;
<b class="nc"><i class="no-highlight">7164</i>&nbsp;        params.put(&quot;max_bad_records&quot;, Value.newBuilder()</b>
<b class="nc"><i class="no-highlight">7165</i>&nbsp;                .setStringValue(bigQueryLoadOptionsConfig.getMaxBadRecords()).build());</b>
<b class="nc"><i class="no-highlight">7166</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7167</i>&nbsp;        // e.g &quot;NUMERIC&quot;</b>
<i class="no-highlight">7168</i>&nbsp;        params.put(&quot;decimal_target_types&quot;, Value.newBuilder()
<b class="nc"><i class="no-highlight">7169</i>&nbsp;                .setStringValue(bigQueryLoadOptionsConfig.getDecimalTargetTypes()).build());</b>
<b class="nc"><i class="no-highlight">7170</i>&nbsp;</b>
<i class="no-highlight">7171</i>&nbsp;        return params;
<b class="nc"><i class="no-highlight">7172</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">7173</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7174</i>&nbsp;    /**</b>
<i class="no-highlight">7175</i>&nbsp;     * Refer : &lt;a href=&quot;https://cloud.google.com/bigquery-transfer/docs/redshift-migration&quot;&gt;
<i class="no-highlight">7176</i>&nbsp;     *     Doc Link&lt;/a&gt;
<b class="nc"><i class="no-highlight">7177</i>&nbsp;     */</b>
<b class="nc"><i class="no-highlight">7178</i>&nbsp;    private Map&lt;String, Value&gt; getParametersForRSTransfer() {</b>
<b class="nc"><i class="no-highlight">7179</i>&nbsp;        Map&lt;String, Value&gt; params = new HashMap&lt;&gt;();</b>
<i class="no-highlight">7180</i>&nbsp;
<b class="nc"><i class="no-highlight">7181</i>&nbsp;        // params to connect Redshift cluster</b>
<i class="no-highlight">7182</i>&nbsp;        params.put(&quot;jdbc_url&quot;, Value.newBuilder()
<b class="nc"><i class="no-highlight">7183</i>&nbsp;                .setStringValue(bqRedshiftJdbcUrl).build());</b>
<i class="no-highlight">7184</i>&nbsp;        params.put(&quot;database_username&quot;, Value.newBuilder()
<i class="no-highlight">7185</i>&nbsp;                .setStringValue(bqRedshiftDbUserName).build());
<b class="nc"><i class="no-highlight">7186</i>&nbsp;        params.put(&quot;database_password&quot;, Value.newBuilder()</b>
<i class="no-highlight">7187</i>&nbsp;                .setStringValue(bqRedshiftDbPassword).build());
<b class="nc"><i class="no-highlight">7188</i>&nbsp;</b>
<i class="no-highlight">7189</i>&nbsp;        // params to unload/stage Redshift source table data into s3
<b class="nc"><i class="no-highlight">7190</i>&nbsp;        params.put(&quot;access_key_id&quot;, Value.newBuilder()</b>
<b class="nc"><i class="no-highlight">7191</i>&nbsp;                .setStringValue(awsAccessKey).build());</b>
<b class="nc"><i class="no-highlight">7192</i>&nbsp;        params.put(&quot;secret_access_key&quot;, Value.newBuilder()</b>
<b class="nc"><i class="no-highlight">7193</i>&nbsp;                .setStringValue(awsSecretKey).build());</b>
<b class="nc"><i class="no-highlight">7194</i>&nbsp;        params.put(&quot;s3_bucket&quot;, Value.newBuilder()</b>
<b class="nc"><i class="no-highlight">7195</i>&nbsp;                .setStringValue(s3StagingFolderURI).build());</b>
<b class="nc"><i class="no-highlight">7196</i>&nbsp;</b>
<i class="no-highlight">7197</i>&nbsp;        // params to reach Redshift source schema and table
<i class="no-highlight">7198</i>&nbsp;        params.put(&quot;redshift_schema&quot;, Value.newBuilder()
<b class="nc"><i class="no-highlight">7199</i>&nbsp;                .setStringValue(bqRedshiftSchemaName).build());</b>
<b class="nc"><i class="no-highlight">7200</i>&nbsp;        params.put(&quot;table_name_patterns&quot;, Value.newBuilder()</b>
<b class="nc"><i class="no-highlight">7201</i>&nbsp;                .setStringValue(bqRedshiftTableName).build());</b>
<b class="nc"><i class="no-highlight">7202</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7203</i>&nbsp;        return params;</b>
<i class="no-highlight">7204</i>&nbsp;    }
<b class="nc"><i class="no-highlight">7205</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7206</i>&nbsp;    private void handleRetryableApiException(String reason, int i, String s3SourceURI)</b>
<b class="nc"><i class="no-highlight">7207</i>&nbsp;            throws InterruptedException {</b>
<b class="nc"><i class="no-highlight">7208</i>&nbsp;        // throw exception if reached max retries limit</b>
<i class="no-highlight">7209</i>&nbsp;        if (i == BQ_MAX_RETRIES) {
<b class="nc"><i class="no-highlight">7210</i>&nbsp;            reason += &quot;. Retried &quot; + i + &quot; times. Now giving up.&quot;;</b>
<b class="nc"><i class="no-highlight">7211</i>&nbsp;            LOGGER.error(reason);</b>
<b class="nc"><i class="no-highlight">7212</i>&nbsp;            throw new SnapDataException(s3SourceURI)</b>
<b class="nc"><i class="no-highlight">7213</i>&nbsp;                    .withReason(reason)</b>
<i class="no-highlight">7214</i>&nbsp;                    .withResolution(CONTACT_SUPPORT);
<i class="no-highlight">7215</i>&nbsp;        } else {
<i class="no-highlight">7216</i>&nbsp;            // delay with progressively incremental backoff before each retrying
<i class="no-highlight">7217</i>&nbsp;            long retryInterval = BQ_DELAY_MS + (long)(BQ_BACKOFF_MS * Math.pow(2, i));
<i class="no-highlight">7218</i>&nbsp;            reason += &quot;. Retrying after &quot; + retryInterval + &quot; msec.&quot;;
<i class="no-highlight">7219</i>&nbsp;            LOGGER.error(reason);
<i class="no-highlight">7220</i>&nbsp;            Thread.sleep(retryInterval);
<i class="no-highlight">7221</i>&nbsp;        }
<i class="no-highlight">7222</i>&nbsp;    }
<i class="no-highlight">7223</i>&nbsp;
<i class="no-highlight">7224</i>&nbsp;    private void executeAppendToTableBulkLoadBigQuery() {
<i class="no-highlight">7225</i>&nbsp;        // The sequence of operations should not be changed here:
<i class="no-highlight">7226</i>&nbsp;        // In validation/preview or execution mode
<i class="no-highlight">7227</i>&nbsp;        //  - if target table not present then throw exception
<i class="no-highlight">7228</i>&nbsp;        // In validation mode,
<i class="no-highlight">7229</i>&nbsp;        //  - no op
<i class="no-highlight">7230</i>&nbsp;        //  - return
<b class="nc"><i class="no-highlight">7231</i>&nbsp;        // In execution mode,</b>
<b class="nc"><i class="no-highlight">7232</i>&nbsp;        //  - here table already exists</b>
<b class="nc"><i class="no-highlight">7233</i>&nbsp;        //  - build BigQuery load job</b>
<b class="nc"><i class="no-highlight">7234</i>&nbsp;        //  - perform load job operation</b>
<i class="no-highlight">7235</i>&nbsp;        //  - action is atomic and only occurs if BigQuery is able to complete
<i class="no-highlight">7236</i>&nbsp;        //    the job successfully
<i class="no-highlight">7237</i>&nbsp;        //  - i.e. append actions occur as one atomic update upon job completion
<i class="no-highlight">7238</i>&nbsp;        //  - so no explicit rollback is required upon failure
<i class="no-highlight">7239</i>&nbsp;
<i class="no-highlight">7240</i>&nbsp;        // Assert that table exists
<b class="nc"><i class="no-highlight">7241</i>&nbsp;        if (!doesTableExist) {</b>
<b class="nc"><i class="no-highlight">7242</i>&nbsp;            throwTableDoesNotExistException(targetTablePath);</b>
<b class="nc"><i class="no-highlight">7243</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">7244</i>&nbsp;</b>
<i class="no-highlight">7245</i>&nbsp;        //=========================
<b class="nc"><i class="no-highlight">7246</i>&nbsp;        // Validation/Preview mode</b>
<b class="nc"><i class="no-highlight">7247</i>&nbsp;        //=========================</b>
<b class="nc"><i class="no-highlight">7248</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7249</i>&nbsp;        if (validationInProgress) {</b>
<i class="no-highlight">7250</i>&nbsp;            // no op
<i class="no-highlight">7251</i>&nbsp;            return;
<i class="no-highlight">7252</i>&nbsp;        }
<i class="no-highlight">7253</i>&nbsp;
<i class="no-highlight">7254</i>&nbsp;        //====================
<i class="no-highlight">7255</i>&nbsp;        // Execution mode
<i class="no-highlight">7256</i>&nbsp;        //====================
<i class="no-highlight">7257</i>&nbsp;        String intermediateTableName = StringUtils.EMPTY;
<i class="no-highlight">7258</i>&nbsp;
<i class="no-highlight">7259</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">7260</i>&nbsp;            // LOAD Table (equivalent of COPY INTO) operation</b>
<b class="nc"><i class="no-highlight">7261</i>&nbsp;            if (MapUtils.isNotEmpty(this.columnMappingMap)) {</b>
<b class="nc"><i class="no-highlight">7262</i>&nbsp;                intermediateTableName = getTempTableName(false);</b>
<b class="nc"><i class="no-highlight">7263</i>&nbsp;                doBigQueryBulkLoadWithMap(intermediateTableName);</b>
<i class="no-highlight">7264</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">7265</i>&nbsp;                doBigQueryBulkLoadWrapper(getTableName());</b>
<i class="no-highlight">7266</i>&nbsp;            }
<b class="nc"><i class="no-highlight">7267</i>&nbsp;        } catch (Exception e) {</b>
<b class="nc"><i class="no-highlight">7268</i>&nbsp;            handleFailures(ERR_BULK_LOAD);</b>
<i class="no-highlight">7269</i>&nbsp;            String error = StringUtils.isNotBlank(e.toString()) ? e.toString() : ERR_BULK_LOAD;
<i class="no-highlight">7270</i>&nbsp;            throw new SnapDataException(e, error)
<i class="no-highlight">7271</i>&nbsp;                    .withReason(getErrorReason(e, ERR_BULK_LOAD))
<i class="no-highlight">7272</i>&nbsp;                    .withResolution(getErrorResolution(e, CONTACT_SUPPORT));
<b class="nc"><i class="no-highlight">7273</i>&nbsp;        } finally {</b>
<b class="nc"><i class="no-highlight">7274</i>&nbsp;            if (isIntermediateTableCreated) {</b>
<i class="no-highlight">7275</i>&nbsp;                String intermediateTableFullyQualifiedName =
<b class="nc"><i class="no-highlight">7276</i>&nbsp;                        getFullyQualifiedTableName(</b>
<b class="nc"><i class="no-highlight">7277</i>&nbsp;                                intermediateTableName, getDatabaseName());</b>
<b class="nc"><i class="no-highlight">7278</i>&nbsp;                try {</b>
<b class="nc"><i class="no-highlight">7279</i>&nbsp;                    dropTable(intermediateTableFullyQualifiedName, bindValues);</b>
<b class="nc"><i class="no-highlight">7280</i>&nbsp;                } catch (Exception e) {}</b>
<i class="no-highlight">7281</i>&nbsp;            }
<i class="no-highlight">7282</i>&nbsp;        }
<b class="nc"><i class="no-highlight">7283</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">7284</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7285</i>&nbsp;    private void doBigQueryBulkLoadWithMap(</b>
<i class="no-highlight">7286</i>&nbsp;            String intermediateTableName) throws Exception {
<b class="nc"><i class="no-highlight">7287</i>&nbsp;        doBigQueryBulkLoadWrapper(intermediateTableName);</b>
<i class="no-highlight">7288</i>&nbsp;        isIntermediateTableCreated = true;
<b class="nc"><i class="no-highlight">7289</i>&nbsp;        String intermediateTableFullyQualifiedName =</b>
<i class="no-highlight">7290</i>&nbsp;                getFullyQualifiedTableName(
<b class="nc"><i class="no-highlight">7291</i>&nbsp;                        intermediateTableName, getDatabaseName());</b>
<b class="nc"><i class="no-highlight">7292</i>&nbsp;        copyIntoTargetTableBigQuery(</b>
<i class="no-highlight">7293</i>&nbsp;                intermediateTableFullyQualifiedName,
<b class="nc"><i class="no-highlight">7294</i>&nbsp;                getFullyQualifiedTableName(getTableName(), getDatabaseName()));</b>
<b class="nc"><i class="no-highlight">7295</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">7296</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7297</i>&nbsp;    @VisibleForTesting</b>
<b class="nc"><i class="no-highlight">7298</i>&nbsp;    void doBigQueryBulkLoadWrapper(String targetTableName) throws Exception {</b>
<b class="nc"><i class="no-highlight">7299</i>&nbsp;        String sourceLocation = eltDatabaseAccount.getSourceLocation();</b>
<b class="nc"><i class="no-highlight">7300</i>&nbsp;        switch (sourceLocation) {</b>
<i class="no-highlight">7301</i>&nbsp;            case AMAZON_S3:
<i class="no-highlight">7302</i>&nbsp;            case AMAZON_REDSHIFT:
<i class="no-highlight">7303</i>&nbsp;                doBigQueryTransferLoad(targetTableName);
<b class="nc"><i class="no-highlight">7304</i>&nbsp;                break;</b>
<i class="no-highlight">7305</i>&nbsp;            case GOOGLE_CLOUD_STORAGE:
<b class="nc"><i class="no-highlight">7306</i>&nbsp;                doBigQueryBulkLoad(targetTableName);</b>
<b class="nc"><i class="no-highlight">7307</i>&nbsp;                break;</b>
<i class="no-highlight">7308</i>&nbsp;        }
<b class="nc"><i class="no-highlight">7309</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">7310</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7311</i>&nbsp;    private void executeOverwriteTableBulkLoadBigQuery() {</b>
<b class="nc"><i class="no-highlight">7312</i>&nbsp;        // The sequence of operations should not be changed here:</b>
<b class="nc"><i class="no-highlight">7313</i>&nbsp;        // In validation/preview or execution mode</b>
<b class="nc"><i class="no-highlight">7314</i>&nbsp;        //  - if target table not present then throw exception</b>
<b class="nc"><i class="no-highlight">7315</i>&nbsp;        // In validation mode,</b>
<b class="nc"><i class="no-highlight">7316</i>&nbsp;        //  - no op</b>
<i class="no-highlight">7317</i>&nbsp;        //  - return
<i class="no-highlight">7318</i>&nbsp;        // In execution mode,
<b class="nc"><i class="no-highlight">7319</i>&nbsp;        //  - here table already exists</b>
<b class="nc"><i class="no-highlight">7320</i>&nbsp;        //  - record CURRENT_TIMESTAMP as SNAPSHOT TIME from BigQuery, in case we need to rollback</b>
<b class="nc"><i class="no-highlight">7321</i>&nbsp;        //    the delete rows operation</b>
<b class="nc"><i class="no-highlight">7322</i>&nbsp;        //  - perform DELETE rows operation</b>
<b class="nc"><i class="no-highlight">7323</i>&nbsp;        //  - build BigQuery load job</b>
<i class="no-highlight">7324</i>&nbsp;        //  - perform load job operation
<b class="nc"><i class="no-highlight">7325</i>&nbsp;        //  - if load job fails, rollback to snapshot of table AS OF recorded SNAPSHOT TIME</b>
<b class="nc"><i class="no-highlight">7326</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7327</i>&nbsp;        // Assert that table exists</b>
<b class="nc"><i class="no-highlight">7328</i>&nbsp;        if (!doesTableExist) {</b>
<i class="no-highlight">7329</i>&nbsp;            throwTableDoesNotExistException(targetTablePath);
<b class="nc"><i class="no-highlight">7330</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">7331</i>&nbsp;</b>
<i class="no-highlight">7332</i>&nbsp;        //=========================
<i class="no-highlight">7333</i>&nbsp;        // Validation/Preview mode
<b class="nc"><i class="no-highlight">7334</i>&nbsp;        //=========================</b>
<i class="no-highlight">7335</i>&nbsp;
<b class="nc"><i class="no-highlight">7336</i>&nbsp;        if (validationInProgress) {</b>
<b class="nc"><i class="no-highlight">7337</i>&nbsp;            // no op</b>
<i class="no-highlight">7338</i>&nbsp;            return;
<b class="nc"><i class="no-highlight">7339</i>&nbsp;        }</b>
<i class="no-highlight">7340</i>&nbsp;
<i class="no-highlight">7341</i>&nbsp;        //====================
<i class="no-highlight">7342</i>&nbsp;        // Execution mode
<i class="no-highlight">7343</i>&nbsp;        //====================
<i class="no-highlight">7344</i>&nbsp;        String intermediateTableName = StringUtils.EMPTY;
<b class="nc"><i class="no-highlight">7345</i>&nbsp;</b>
<i class="no-highlight">7346</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">7347</i>&nbsp;            // 1) Record the BigQuery CURRENT TIMESTAMP as SNAPSHOT TIME</b>
<b class="nc"><i class="no-highlight">7348</i>&nbsp;            // This will be used to rollback the table to a original state</b>
<i class="no-highlight">7349</i>&nbsp;            // in the unlikely event of failure.
<b class="nc"><i class="no-highlight">7350</i>&nbsp;            bigQueryRestoreToTimestamp = getBigQueryCurrentTimestamp();</b>
<b class="nc"><i class="no-highlight">7351</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7352</i>&nbsp;            // 2) DELETE rows from table operation</b>
<b class="nc"><i class="no-highlight">7353</i>&nbsp;            executedQueries.add(sqlDeleteTable);</b>
<b class="nc"><i class="no-highlight">7354</i>&nbsp;            sqlDeleteTable = buildDeleteTableSql(targetTablePath);</b>
<b class="nc"><i class="no-highlight">7355</i>&nbsp;            int numberOfDeletes =</b>
<b class="nc"><i class="no-highlight">7356</i>&nbsp;                    executeStatement(sqlDeleteTable, bindValues, account);</b>
<i class="no-highlight">7357</i>&nbsp;
<i class="no-highlight">7358</i>&nbsp;            statistic.addNumberOfDeletes(numberOfDeletes);
<b class="nc"><i class="no-highlight">7359</i>&nbsp;            statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">7360</i>&nbsp;                    new QueryStatisticHolderBuilder(sqlDeleteTable)</b>
<b class="nc"><i class="no-highlight">7361</i>&nbsp;                            .setNumberOfDeletes(numberOfDeletes)</b>
<i class="no-highlight">7362</i>&nbsp;                            .build());
<b class="nc"><i class="no-highlight">7363</i>&nbsp;            tableRowsDeleted = true;</b>
<i class="no-highlight">7364</i>&nbsp;
<b class="nc"><i class="no-highlight">7365</i>&nbsp;            // 3) LOAD Table (equivalent of COPY INTO) operation</b>
<i class="no-highlight">7366</i>&nbsp;            if (MapUtils.isNotEmpty(this.columnMappingMap)) {
<b class="nc"><i class="no-highlight">7367</i>&nbsp;                intermediateTableName = getTempTableName(false);</b>
<b class="nc"><i class="no-highlight">7368</i>&nbsp;                doBigQueryBulkLoadWithMap(intermediateTableName);</b>
<i class="no-highlight">7369</i>&nbsp;            } else {
<i class="no-highlight">7370</i>&nbsp;                doBigQueryBulkLoadWrapper(getTableName());
<i class="no-highlight">7371</i>&nbsp;            }
<i class="no-highlight">7372</i>&nbsp;        } catch (Exception e) {
<b class="nc"><i class="no-highlight">7373</i>&nbsp;            // in case of any failure, restore target table to version before we performed an</b>
<b class="nc"><i class="no-highlight">7374</i>&nbsp;            // alter operation</b>
<b class="nc"><i class="no-highlight">7375</i>&nbsp;            if (tableRowsDeleted) {</b>
<b class="nc"><i class="no-highlight">7376</i>&nbsp;                try {</b>
<i class="no-highlight">7377</i>&nbsp;                    String sqlUndoDelete = buildBigQueryRestoreTargetTableToStartTimestampSql(
<b class="nc"><i class="no-highlight">7378</i>&nbsp;                            targetTablePath, bigQueryRestoreToTimestamp);</b>
<i class="no-highlight">7379</i>&nbsp;                    executeSqlStmt(sqlUndoDelete, bindValues, account);
<b class="nc"><i class="no-highlight">7380</i>&nbsp;                } catch (Exception ex) {</b>
<i class="no-highlight">7381</i>&nbsp;                    handleFailures(ERR_ROLLBACK_BULK_LOAD_TABLE);
<b class="nc"><i class="no-highlight">7382</i>&nbsp;                    throw new SnapDataException(ex, ERR_ROLLBACK_BULK_LOAD_TABLE)</b>
<i class="no-highlight">7383</i>&nbsp;                            .withReason(ex.getMessage())
<i class="no-highlight">7384</i>&nbsp;                            .withResolution(CONTACT_SUPPORT);
<b class="nc"><i class="no-highlight">7385</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">7386</i>&nbsp;            }</b>
<i class="no-highlight">7387</i>&nbsp;
<b class="nc"><i class="no-highlight">7388</i>&nbsp;            handleFailures(ERR_BULK_LOAD);</b>
<b class="nc"><i class="no-highlight">7389</i>&nbsp;            String error = StringUtils.isNotBlank(e.toString()) ? e.toString() : ERR_BULK_LOAD;</b>
<i class="no-highlight">7390</i>&nbsp;            throw new SnapDataException(e, error)
<i class="no-highlight">7391</i>&nbsp;                    .withReason(getErrorReason(e, ERR_BULK_LOAD))
<b class="nc"><i class="no-highlight">7392</i>&nbsp;                    .withResolution(getErrorResolution(e, CONTACT_SUPPORT));</b>
<b class="nc"><i class="no-highlight">7393</i>&nbsp;        } finally {</b>
<i class="no-highlight">7394</i>&nbsp;            if (isIntermediateTableCreated) {
<i class="no-highlight">7395</i>&nbsp;                String intermediateTableFullyQualifiedName =
<b class="nc"><i class="no-highlight">7396</i>&nbsp;                        getFullyQualifiedTableName(</b>
<b class="nc"><i class="no-highlight">7397</i>&nbsp;                                intermediateTableName, getDatabaseName());</b>
<b class="nc"><i class="no-highlight">7398</i>&nbsp;                try {</b>
<i class="no-highlight">7399</i>&nbsp;                dropTable(intermediateTableFullyQualifiedName, bindValues);
<b class="nc"><i class="no-highlight">7400</i>&nbsp;                } catch (Exception e) {}</b>
<b class="nc"><i class="no-highlight">7401</i>&nbsp;            }</b>
<i class="no-highlight">7402</i>&nbsp;        }
<b class="nc"><i class="no-highlight">7403</i>&nbsp;    }</b>
<b class="nc"><i class="no-highlight">7404</i>&nbsp;</b>
<i class="no-highlight">7405</i>&nbsp;    private void executeDropCreateTableBulkLoadBigQuery() {
<i class="no-highlight">7406</i>&nbsp;        // The sequence of operations should not be changed here:
<i class="no-highlight">7407</i>&nbsp;        // In validation mode,
<i class="no-highlight">7408</i>&nbsp;        //  - if target table not present then create it
<i class="no-highlight">7409</i>&nbsp;        //  - return
<i class="no-highlight">7410</i>&nbsp;        // In execution mode,
<i class="no-highlight">7411</i>&nbsp;        //  - here table may or may not exists
<i class="no-highlight">7412</i>&nbsp;        //  - if table already exists, then rename/backup it
<i class="no-highlight">7413</i>&nbsp;        //  - create a new tgt table in any case
<i class="no-highlight">7414</i>&nbsp;        //  - build BigQuery load job
<i class="no-highlight">7415</i>&nbsp;        //  - perform load job operation
<i class="no-highlight">7416</i>&nbsp;        //  - if above succeed
<i class="no-highlight">7417</i>&nbsp;        //    - then drop renamed table
<i class="no-highlight">7418</i>&nbsp;        //    - else rollback (create table and rename table operations performed above)
<i class="no-highlight">7419</i>&nbsp;
<i class="no-highlight">7420</i>&nbsp;        String backupTargetTableName = StringUtils.EMPTY;
<i class="no-highlight">7421</i>&nbsp;        String fqBackupTargetTableName = StringUtils.EMPTY;
<i class="no-highlight">7422</i>&nbsp;        boolean isTargetTableRenamed = false;
<i class="no-highlight">7423</i>&nbsp;        String intermediateTableName = StringUtils.EMPTY;
<b class="nc"><i class="no-highlight">7424</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7425</i>&nbsp;        try {</b>
<i class="no-highlight">7426</i>&nbsp;            //=========================
<i class="no-highlight">7427</i>&nbsp;            // Validation/Preview mode
<i class="no-highlight">7428</i>&nbsp;            //=========================
<i class="no-highlight">7429</i>&nbsp;
<i class="no-highlight">7430</i>&nbsp;            if (validationInProgress) {
<i class="no-highlight">7431</i>&nbsp;                if (!doesTableExist) {
<b class="nc"><i class="no-highlight">7432</i>&nbsp;                    sqlCreateTable = buildBigQueryCreateOrReplaceTableSql(targetTablePath,</b>
<i class="no-highlight">7433</i>&nbsp;                            buildColumnWithDataTypeCreateTable(targetColumns, targetDataTypes),
<i class="no-highlight">7434</i>&nbsp;                            tableOptions);
<i class="no-highlight">7435</i>&nbsp;                    executedQueries.add(sqlCreateTable);
<i class="no-highlight">7436</i>&nbsp;                    statistic.addQueryStatistic(
<i class="no-highlight">7437</i>&nbsp;                            new QueryStatisticHolderBuilder(sqlCreateTable).build());
<i class="no-highlight">7438</i>&nbsp;                    executeSqlStmt(sqlCreateTable, bindValues, account);
<i class="no-highlight">7439</i>&nbsp;                }
<i class="no-highlight">7440</i>&nbsp;                return;
<i class="no-highlight">7441</i>&nbsp;            }
<i class="no-highlight">7442</i>&nbsp;
<i class="no-highlight">7443</i>&nbsp;            //====================
<i class="no-highlight">7444</i>&nbsp;            // Execution mode
<b class="nc"><i class="no-highlight">7445</i>&nbsp;            //====================</b>
<i class="no-highlight">7446</i>&nbsp;
<i class="no-highlight">7447</i>&nbsp;            // 1) DROP table operation : if table exists - instead of drop table, rename/backup it
<b class="nc"><i class="no-highlight">7448</i>&nbsp;            // in case we have to do manual rollback</b>
<i class="no-highlight">7449</i>&nbsp;            if (doesTableExist) {
<i class="no-highlight">7450</i>&nbsp;                backupTargetTableName = getDerivedTableName();
<b class="nc"><i class="no-highlight">7451</i>&nbsp;                fqBackupTargetTableName = String.format(BIGQUERY_FQ_TABLE_NAME_FMT,</b>
<b class="nc"><i class="no-highlight">7452</i>&nbsp;                        getDatabaseName(), getSchemaName(), backupTargetTableName);</b>
<b class="nc"><i class="no-highlight">7453</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7454</i>&nbsp;                sqlRenameTable = buildBigQueryRenameTableSql(</b>
<b class="nc"><i class="no-highlight">7455</i>&nbsp;                        targetTablePath, backupTargetTableName);</b>
<i class="no-highlight">7456</i>&nbsp;                executeSqlStmt(sqlRenameTable, bindValues, account);
<i class="no-highlight">7457</i>&nbsp;                isTargetTableRenamed = true;
<b class="nc"><i class="no-highlight">7458</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">7459</i>&nbsp;</b>
<i class="no-highlight">7460</i>&nbsp;            // 2) CREATE table operation : If existed it is renamed above already, now
<i class="no-highlight">7461</i>&nbsp;            // create the table with newly specified schema
<b class="nc"><i class="no-highlight">7462</i>&nbsp;            sqlCreateTable = buildBigQueryCreateOrReplaceTableSql(targetTablePath,</b>
<i class="no-highlight">7463</i>&nbsp;                    buildColumnWithDataTypeCreateTable(targetColumns, targetDataTypes),
<b class="nc"><i class="no-highlight">7464</i>&nbsp;                    tableOptions);</b>
<i class="no-highlight">7465</i>&nbsp;            executedQueries.add(sqlCreateTable);
<b class="nc"><i class="no-highlight">7466</i>&nbsp;            statistic.addQueryStatistic(</b>
<b class="nc"><i class="no-highlight">7467</i>&nbsp;                    new QueryStatisticHolderBuilder(sqlCreateTable).build());</b>
<b class="nc"><i class="no-highlight">7468</i>&nbsp;            executeSqlStmt(sqlCreateTable, bindValues, account);</b>
<b class="nc"><i class="no-highlight">7469</i>&nbsp;            isCreateTargetTable = true;</b>
<b class="nc"><i class="no-highlight">7470</i>&nbsp;</b>
<b class="nc"><i class="no-highlight">7471</i>&nbsp;            // 3) LOAD Table (equivalent of COPY INTO) operation</b>
<b class="nc"><i class="no-highlight">7472</i>&nbsp;            if (MapUtils.isNotEmpty(this.columnMappingMap)) {</b>
<i class="no-highlight">7473</i>&nbsp;                intermediateTableName = getTempTableName(false);
<i class="no-highlight">7474</i>&nbsp;                doBigQueryBulkLoadWithMap(intermediateTableName);
<b class="nc"><i class="no-highlight">7475</i>&nbsp;            } else {</b>
<b class="nc"><i class="no-highlight">7476</i>&nbsp;                doBigQueryBulkLoadWrapper(getTableName());</b>
<b class="nc"><i class="no-highlight">7477</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">7478</i>&nbsp;        } catch (Exception e) {</b>
<b class="nc"><i class="no-highlight">7479</i>&nbsp;            // Rollback CREATE table operation</b>
<b class="nc"><i class="no-highlight">7480</i>&nbsp;            if (isCreateTargetTable) {</b>
<i class="no-highlight">7481</i>&nbsp;                sqlDropTable = buildDropTableSql(targetTablePath);
<i class="no-highlight">7482</i>&nbsp;                try {
<i class="no-highlight">7483</i>&nbsp;                    executeSqlStmt(sqlDropTable, bindValues, account);
<i class="no-highlight">7484</i>&nbsp;                } catch (Exception ex) {
<b class="nc"><i class="no-highlight">7485</i>&nbsp;                    handleFailures(ERR_ROLLBACK_BULK_LOAD_TABLE);</b>
<i class="no-highlight">7486</i>&nbsp;                    throw new SnapDataException(ex, ERR_ROLLBACK_BULK_LOAD_TABLE)
<i class="no-highlight">7487</i>&nbsp;                            .withReason(ex.getMessage())
<i class="no-highlight">7488</i>&nbsp;                            .withResolution(CONTACT_SUPPORT);
<i class="no-highlight">7489</i>&nbsp;                }
<b class="nc"><i class="no-highlight">7490</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">7491</i>&nbsp;</b>
<i class="no-highlight">7492</i>&nbsp;            // Rollback RENAME table operation
<i class="no-highlight">7493</i>&nbsp;            if (isTargetTableRenamed) {
<i class="no-highlight">7494</i>&nbsp;                // rename backup table to target table name
<i class="no-highlight">7495</i>&nbsp;                sqlRenameTable = buildBigQueryRenameTableSql(
<i class="no-highlight">7496</i>&nbsp;                        fqBackupTargetTableName, getTableName());
<i class="no-highlight">7497</i>&nbsp;                try {
<i class="no-highlight">7498</i>&nbsp;                    executeSqlStmt(sqlRenameTable, bindValues, account);
<i class="no-highlight">7499</i>&nbsp;                    isTargetTableRenamed = false; // setting false as no more renaming needed
<i class="no-highlight">7500</i>&nbsp;                } catch (SQLException sqle) {
<i class="no-highlight">7501</i>&nbsp;                    handleFailures(ERR_ROLLBACK_BULK_LOAD_TABLE);
<i class="no-highlight">7502</i>&nbsp;                    throw new SnapDataException(sqle, ERR_ROLLBACK_BULK_LOAD_TABLE)
<i class="no-highlight">7503</i>&nbsp;                            .withReason(e.getMessage())
<i class="no-highlight">7504</i>&nbsp;                            .withResolution(CONTACT_SUPPORT);
<i class="no-highlight">7505</i>&nbsp;                }
<i class="no-highlight">7506</i>&nbsp;            }
<i class="no-highlight">7507</i>&nbsp;
<i class="no-highlight">7508</i>&nbsp;            handleFailures(ERR_BULK_LOAD);
<i class="no-highlight">7509</i>&nbsp;            String error = StringUtils.isNotBlank(e.toString()) ? e.toString() : ERR_BULK_LOAD;
<i class="no-highlight">7510</i>&nbsp;            throw new SnapDataException(e, error)
<i class="no-highlight">7511</i>&nbsp;                    .withReason(getErrorReason(e, ERR_BULK_LOAD))
<i class="no-highlight">7512</i>&nbsp;                    .withResolution(getErrorResolution(e, CONTACT_SUPPORT));
<i class="no-highlight">7513</i>&nbsp;        } finally {
<i class="no-highlight">7514</i>&nbsp;            if (isIntermediateTableCreated) {
<i class="no-highlight">7515</i>&nbsp;                String intermediateTableFullyQualifiedName =
<i class="no-highlight">7516</i>&nbsp;                        getFullyQualifiedTableName(
<i class="no-highlight">7517</i>&nbsp;                                intermediateTableName, getDatabaseName());
<i class="no-highlight">7518</i>&nbsp;                try {
<i class="no-highlight">7519</i>&nbsp;                    dropTable(intermediateTableFullyQualifiedName, bindValues);
<i class="no-highlight">7520</i>&nbsp;                } catch (Exception e) {}
<i class="no-highlight">7521</i>&nbsp;            }
<i class="no-highlight">7522</i>&nbsp;            // finally if table was renamed/backedup, it needs to be dropped as part of cleanup
<i class="no-highlight">7523</i>&nbsp;            if (isTargetTableRenamed) {
<i class="no-highlight">7524</i>&nbsp;                try {
<i class="no-highlight">7525</i>&nbsp;                dropTable(fqBackupTargetTableName, bindValues);
<i class="no-highlight">7526</i>&nbsp;                } catch (Exception e) {}
<i class="no-highlight">7527</i>&nbsp;            }
<i class="no-highlight">7528</i>&nbsp;        }
<i class="no-highlight">7529</i>&nbsp;    }
<i class="no-highlight">7530</i>&nbsp;
<i class="no-highlight">7531</i>&nbsp;    private void copyIntoTargetTableBigQuery(
<i class="no-highlight">7532</i>&nbsp;            String intermediateTableFullyQualifiedName,
<i class="no-highlight">7533</i>&nbsp;            String finalTargetTableFullyQualifieName) throws Exception {
<i class="no-highlight">7534</i>&nbsp;        trimListEntries(targetColumns);
<i class="no-highlight">7535</i>&nbsp;
<i class="no-highlight">7536</i>&nbsp;        Set&lt;String&gt; sourceTableColumns =
<i class="no-highlight">7537</i>&nbsp;                findTableColumns(intermediateTableFullyQualifiedName);
<i class="no-highlight">7538</i>&nbsp;
<i class="no-highlight">7539</i>&nbsp;        StringBuilder headerColumnsBuilder = new StringBuilder();
<i class="no-highlight">7540</i>&nbsp;        boolean firstEntry = true;
<i class="no-highlight">7541</i>&nbsp;        List&lt;String&gt; targetColumnNameListToScan = this.targetColumns;
<i class="no-highlight">7542</i>&nbsp;        if (StringUtils.equals(loadAction, OVERWRITE_TABLE) ||
<i class="no-highlight">7543</i>&nbsp;                StringUtils.equals(loadAction, APPEND_ROWS_TABLE)) {
<i class="no-highlight">7544</i>&nbsp;            targetColumnNameListToScan =
<i class="no-highlight">7545</i>&nbsp;                    new ArrayList&lt;String&gt;(findTableColumns(this.targetTableName));
<i class="no-highlight">7546</i>&nbsp;        }
<i class="no-highlight">7547</i>&nbsp;
<i class="no-highlight">7548</i>&nbsp;        for (String targetColumnName : targetColumnNameListToScan) {
<i class="no-highlight">7549</i>&nbsp;            if (firstEntry) {
<i class="no-highlight">7550</i>&nbsp;                firstEntry = false;
<i class="no-highlight">7551</i>&nbsp;            } else {
<i class="no-highlight">7552</i>&nbsp;                headerColumnsBuilder.append(COMMA);
<i class="no-highlight">7553</i>&nbsp;            }
<i class="no-highlight">7554</i>&nbsp;            if (sourceTableColumns.contains(targetColumnName)) {
<i class="no-highlight">7555</i>&nbsp;                // if targetColumnName is in sourceTableColumns, just add.
<i class="no-highlight">7556</i>&nbsp;                headerColumnsBuilder.append(targetColumnName);
<i class="no-highlight">7557</i>&nbsp;            } else if (this.columnMappingMap.containsKey(targetColumnName)){
<i class="no-highlight">7558</i>&nbsp;                // if targetColumnName is not in sourceTableColumns but in
<i class="no-highlight">7559</i>&nbsp;                // the map key set, then grep its map value. Then verify that
<i class="no-highlight">7560</i>&nbsp;                // it is in the sourceTableColumns, and append
<i class="no-highlight">7561</i>&nbsp;                // &quot;sourceColumnName AS targetColumnName&quot;
<i class="no-highlight">7562</i>&nbsp;                String sourceColumnName = this.columnMappingMap.get(targetColumnName);
<i class="no-highlight">7563</i>&nbsp;                if (!sourceTableColumns.contains(sourceColumnName)) {
<i class="no-highlight">7564</i>&nbsp;                    throw new ConfigurationException(ERR_INVALID_SOURCE_COLUMN_NAMES_FOUND)
<i class="no-highlight">7565</i>&nbsp;                            .withReason(String.format(
<i class="no-highlight">7566</i>&nbsp;                                    REASON_SOURCE_COLUMN_NAMES_NOT_FOUND, sourceColumnName))
<i class="no-highlight">7567</i>&nbsp;                            .withResolution(RESOLUTION_SOURCE_COLUMN_NAMES_NOT_FOUND);
<i class="no-highlight">7568</i>&nbsp;                }
<i class="no-highlight">7569</i>&nbsp;                headerColumnsBuilder.append(String.format(SOURCE_COLUMNL_AS_TARGET_COLUMN,
<i class="no-highlight">7570</i>&nbsp;                        sourceColumnName, targetColumnName));
<i class="no-highlight">7571</i>&nbsp;            } else {
<i class="no-highlight">7572</i>&nbsp;                // if not in sourceTableColumns, nor in the map, then
<i class="no-highlight">7573</i>&nbsp;                // append &quot;NULL AS targetColumnName&quot;
<i class="no-highlight">7574</i>&nbsp;                headerColumnsBuilder
<i class="no-highlight">7575</i>&nbsp;                        .append(String.format(NULL_AS_COLUMN, targetColumnName));
<i class="no-highlight">7576</i>&nbsp;            }
<i class="no-highlight">7577</i>&nbsp;        }
<i class="no-highlight">7578</i>&nbsp;        this.insertSelectSql = String.format(
<i class="no-highlight">7579</i>&nbsp;                INSERT_INTO_TARGET_SELECT_FROM_INTERMEDIATE_BIGQUERY_REDSHIFT,
<i class="no-highlight">7580</i>&nbsp;                finalTargetTableFullyQualifieName,
<i class="no-highlight">7581</i>&nbsp;                String.join(COMMA_SPACE, targetColumnNameListToScan),
<i class="no-highlight">7582</i>&nbsp;                headerColumnsBuilder.toString(),
<i class="no-highlight">7583</i>&nbsp;                intermediateTableFullyQualifiedName);
<i class="no-highlight">7584</i>&nbsp;
<i class="no-highlight">7585</i>&nbsp;        executedQueries.add(insertSelectSql);
<i class="no-highlight">7586</i>&nbsp;        int numberOfInserts =
<i class="no-highlight">7587</i>&nbsp;                executeStatement(this.insertSelectSql, bindValues, account);
<i class="no-highlight">7588</i>&nbsp;
<i class="no-highlight">7589</i>&nbsp;        statistic.addNumberOfInserts(numberOfInserts);
<i class="no-highlight">7590</i>&nbsp;        statistic.addQueryStatistic(
<i class="no-highlight">7591</i>&nbsp;                new QueryStatisticHolderBuilder(this.insertSelectSql)
<i class="no-highlight">7592</i>&nbsp;                        .setNumberOfInserts(numberOfInserts)
<i class="no-highlight">7593</i>&nbsp;                        .build());
<i class="no-highlight">7594</i>&nbsp;    }
<i class="no-highlight">7595</i>&nbsp;
<i class="no-highlight">7596</i>&nbsp;    private void executeAlterTableBulkLoadBigQuery() {
<i class="no-highlight">7597</i>&nbsp;        // The sequence of operations should not be changed here:
<i class="no-highlight">7598</i>&nbsp;        // In validation/preview or execution mode
<i class="no-highlight">7599</i>&nbsp;        //  - if target table not present then throw exception
<i class="no-highlight">7600</i>&nbsp;        // In validation mode,
<i class="no-highlight">7601</i>&nbsp;        //  - no op
<i class="no-highlight">7602</i>&nbsp;        //  - return
<i class="no-highlight">7603</i>&nbsp;        // In execution mode,
<i class="no-highlight">7604</i>&nbsp;        //  - here table already exists
<i class="no-highlight">7605</i>&nbsp;        //  - record CURRENT_TIMESTAMP as SNAPSHOT TIME from BigQuery, in case we need to rollback
<i class="no-highlight">7606</i>&nbsp;        //    the alter table (add/drop columns) operation
<i class="no-highlight">7607</i>&nbsp;        //  - perform alter table operation
<i class="no-highlight">7608</i>&nbsp;        //  - build BigQuery load job
<i class="no-highlight">7609</i>&nbsp;        //  - perform load job operation
<i class="no-highlight">7610</i>&nbsp;        //  - if load job fails, rollback to snapshot of table AS OF recorded SNAPSHOT TIME
<i class="no-highlight">7611</i>&nbsp;
<i class="no-highlight">7612</i>&nbsp;        // Assert that table exists
<i class="no-highlight">7613</i>&nbsp;        if (!doesTableExist) {
<i class="no-highlight">7614</i>&nbsp;            throwTableDoesNotExistException(targetTablePath);
<i class="no-highlight">7615</i>&nbsp;        }
<i class="no-highlight">7616</i>&nbsp;
<i class="no-highlight">7617</i>&nbsp;        //=========================
<i class="no-highlight">7618</i>&nbsp;        // Validation/Preview mode
<i class="no-highlight">7619</i>&nbsp;        //=========================
<i class="no-highlight">7620</i>&nbsp;
<i class="no-highlight">7621</i>&nbsp;        if (validationInProgress) {
<i class="no-highlight">7622</i>&nbsp;            // no op
<i class="no-highlight">7623</i>&nbsp;            return;
<i class="no-highlight">7624</i>&nbsp;        }
<i class="no-highlight">7625</i>&nbsp;
<i class="no-highlight">7626</i>&nbsp;        //====================
<i class="no-highlight">7627</i>&nbsp;        // Execution mode
<i class="no-highlight">7628</i>&nbsp;        //====================
<i class="no-highlight">7629</i>&nbsp;
<i class="no-highlight">7630</i>&nbsp;        try {
<i class="no-highlight">7631</i>&nbsp;            // 1) Record the BigQuery CURRENT TIMESTAMP as SNAPSHOT TIME
<i class="no-highlight">7632</i>&nbsp;            // This will be used to rollback the table to a original state
<i class="no-highlight">7633</i>&nbsp;            // in the unlikely event of failure.
<i class="no-highlight">7634</i>&nbsp;            bigQueryRestoreToTimestamp = getBigQueryCurrentTimestamp();
<i class="no-highlight">7635</i>&nbsp;
<i class="no-highlight">7636</i>&nbsp;            // 2) ALTER table operation
<i class="no-highlight">7637</i>&nbsp;            bigQueryAlterTableAddDropColumnsSqls = buildBigQueryAlterTableAddDropColumnsSqls(
<i class="no-highlight">7638</i>&nbsp;                    targetColumns, targetDataTypes, alterColumnModifiers, targetTablePath);
<i class="no-highlight">7639</i>&nbsp;
<i class="no-highlight">7640</i>&nbsp;            for (String alterTableSql : bigQueryAlterTableAddDropColumnsSqls) {
<i class="no-highlight">7641</i>&nbsp;                executeSqlStmt(alterTableSql, bindValues, account);
<i class="no-highlight">7642</i>&nbsp;                isTableAltered = true;
<i class="no-highlight">7643</i>&nbsp;                sqlAlterTable = alterTableSql;
<i class="no-highlight">7644</i>&nbsp;            }
<i class="no-highlight">7645</i>&nbsp;
<i class="no-highlight">7646</i>&nbsp;            // 3) LOAD Table (equivalent of COPY INTO) operation
<i class="no-highlight">7647</i>&nbsp;            doBigQueryBulkLoadWrapper(getTableName());
<i class="no-highlight">7648</i>&nbsp;        } catch (Exception e) {
<i class="no-highlight">7649</i>&nbsp;            // in case of any failure, restore target table to version before we performed an
<i class="no-highlight">7650</i>&nbsp;            // alter operation
<i class="no-highlight">7651</i>&nbsp;            if (isTableAltered) {
<i class="no-highlight">7652</i>&nbsp;                try {
<i class="no-highlight">7653</i>&nbsp;                    String sqlUndoAlter = buildBigQueryRestoreTargetTableToStartTimestampSql(
<i class="no-highlight">7654</i>&nbsp;                            targetTablePath, bigQueryRestoreToTimestamp);
<i class="no-highlight">7655</i>&nbsp;                    executeSqlStmt(sqlUndoAlter, bindValues, account);
<i class="no-highlight">7656</i>&nbsp;                } catch (Exception ex) {
<i class="no-highlight">7657</i>&nbsp;                    handleFailures(ERR_ROLLBACK_BULK_LOAD_TABLE);
<i class="no-highlight">7658</i>&nbsp;                    throw new SnapDataException(ex, ERR_ROLLBACK_BULK_LOAD_TABLE)
<i class="no-highlight">7659</i>&nbsp;                            .withReason(ex.getMessage())
<i class="no-highlight">7660</i>&nbsp;                            .withResolution(CONTACT_SUPPORT);
<i class="no-highlight">7661</i>&nbsp;                }
<i class="no-highlight">7662</i>&nbsp;            }
<i class="no-highlight">7663</i>&nbsp;
<i class="no-highlight">7664</i>&nbsp;            handleFailures(ERR_BULK_LOAD);
<i class="no-highlight">7665</i>&nbsp;            String error = StringUtils.isNotBlank(e.toString()) ? e.toString() : ERR_BULK_LOAD;
<i class="no-highlight">7666</i>&nbsp;            throw new SnapDataException(e, error)
<i class="no-highlight">7667</i>&nbsp;                    .withReason(getErrorReason(e, ERR_BULK_LOAD))
<i class="no-highlight">7668</i>&nbsp;                    .withResolution(getErrorResolution(e, CONTACT_SUPPORT));
<i class="no-highlight">7669</i>&nbsp;        }
<i class="no-highlight">7670</i>&nbsp;    }
<i class="no-highlight">7671</i>&nbsp;
<i class="no-highlight">7672</i>&nbsp;    private TableId getTableIdBigQuery(
<i class="no-highlight">7673</i>&nbsp;            String projectName, String datasetName, String tableName) {
<i class="no-highlight">7674</i>&nbsp;        return TableId.of(projectName, datasetName, tableName);
<i class="no-highlight">7675</i>&nbsp;    }
<i class="no-highlight">7676</i>&nbsp;
<i class="no-highlight">7677</i>&nbsp;    @Override
<i class="no-highlight">7678</i>&nbsp;    public SnapStatistic&lt;StatisticHolder&gt; getSnapStatistic() {
<i class="no-highlight">7679</i>&nbsp;        return statistic.getSnapStatus() != null ?
<i class="no-highlight">7680</i>&nbsp;                new SnapStatistic&lt;&gt;(statistic) : null;
<i class="no-highlight">7681</i>&nbsp;    }
<i class="no-highlight">7682</i>&nbsp;}
</div>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
        var codeBlock = document.getElementById('sourceCode');

        if (codeBlock) {
            hljs.highlightBlock(codeBlock);
        }
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-01-19 15:49</div>
</div>
</body>
</html>
